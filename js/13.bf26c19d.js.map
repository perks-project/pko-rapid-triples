{"version":3,"file":"js/13.bf26c19d.js","mappings":"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","sources":["webpack://rapid-triples/./node_modules/@rubensworks/saxes/saxes.js","webpack://rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/index.js","webpack://rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/lib/ParseError.js","webpack://rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/lib/RdfXmlParser.js","webpack://rapid-triples/./node_modules/rdf-data-factory/index.js","webpack://rapid-triples/./node_modules/rdf-data-factory/lib/BlankNode.js","webpack://rapid-triples/./node_modules/rdf-data-factory/lib/DataFactory.js","webpack://rapid-triples/./node_modules/rdf-data-factory/lib/DefaultGraph.js","webpack://rapid-triples/./node_modules/rdf-data-factory/lib/Literal.js","webpack://rapid-triples/./node_modules/rdf-data-factory/lib/NamedNode.js","webpack://rapid-triples/./node_modules/rdf-data-factory/lib/Quad.js","webpack://rapid-triples/./node_modules/rdf-data-factory/lib/Variable.js","webpack://rapid-triples/./node_modules/relative-to-absolute-iri/index.js","webpack://rapid-triples/./node_modules/relative-to-absolute-iri/lib/Resolve.js","webpack://rapid-triples/./node_modules/validate-iri/index.js","webpack://rapid-triples/./node_modules/validate-iri/lib/Validate.js","webpack://rapid-triples/./node_modules/xmlchars/xml/1.0/ed5.js","webpack://rapid-triples/./node_modules/xmlchars/xml/1.1/ed2.js","webpack://rapid-triples/./node_modules/xmlchars/xmlns/1.0/ed3.js","webpack://rapid-triples/./node_modules/@zazuko/formats-lazy/lib/CustomRdfXmlParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SaxesParser = exports.EVENTS = void 0;\nconst ed5 = require(\"xmlchars/xml/1.0/ed5\");\nconst ed2 = require(\"xmlchars/xml/1.1/ed2\");\nconst NSed3 = require(\"xmlchars/xmlns/1.0/ed3\");\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n    __proto__: null,\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE,\n};\nconst XML_ENTITIES = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n    __proto__: null,\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: \"\\\"\",\n    apos: \"'\",\n};\n// EOC: end-of-chunk\nconst EOC = -1;\nconst NL_LIKE = -2;\nconst S_BEGIN = 0; // Initial state.\nconst S_BEGIN_WHITESPACE = 1; // leading whitespace\nconst S_DOCTYPE = 2; // <!DOCTYPE\nconst S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\nconst S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\nconst S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\nconst S_DTD_OPEN_WAKA = 6;\nconst S_DTD_OPEN_WAKA_BANG = 7;\nconst S_DTD_COMMENT = 8; // <!--\nconst S_DTD_COMMENT_ENDING = 9; // <!-- blah -\nconst S_DTD_COMMENT_ENDED = 10; // <!-- blah --\nconst S_DTD_PI = 11; // <?\nconst S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\nconst S_TEXT = 13; // general stuff\nconst S_ENTITY = 14; // &amp and such\nconst S_OPEN_WAKA = 15; // <\nconst S_OPEN_WAKA_BANG = 16; // <!...\nconst S_COMMENT = 17; // <!--\nconst S_COMMENT_ENDING = 18; // <!-- blah -\nconst S_COMMENT_ENDED = 19; // <!-- blah --\nconst S_CDATA = 20; // <![CDATA[ something\nconst S_CDATA_ENDING = 21; // ]\nconst S_CDATA_ENDING_2 = 22; // ]]\nconst S_PI_FIRST_CHAR = 23; // <?hi, first char\nconst S_PI_REST = 24; // <?hi, rest of the name\nconst S_PI_BODY = 25; // <?hi there\nconst S_PI_ENDING = 26; // <?hi \"there\" ?\nconst S_XML_DECL_NAME_START = 27; // <?xml\nconst S_XML_DECL_NAME = 28; // <?xml foo\nconst S_XML_DECL_EQ = 29; // <?xml foo=\nconst S_XML_DECL_VALUE_START = 30; // <?xml foo=\nconst S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\nconst S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\nconst S_XML_DECL_ENDING = 33; // <?xml ... ?\nconst S_OPEN_TAG = 34; // <strong\nconst S_OPEN_TAG_SLASH = 35; // <strong /\nconst S_ATTRIB = 36; // <a\nconst S_ATTRIB_NAME = 37; // <a foo\nconst S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\nconst S_ATTRIB_VALUE = 39; // <a foo=\nconst S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\nconst S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\nconst S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\nconst S_CLOSE_TAG = 43; // </a\nconst S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\nconst TAB = 9;\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\nconst NEL = 0x85;\nconst LS = 0x2028; // Line Separator\nconst isQuote = (c) => c === DQUOTE || c === SQUOTE;\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\nfunction nsPairCheck(parser, prefix, uri) {\n    switch (prefix) {\n        case \"xml\":\n            if (uri !== XML_NAMESPACE) {\n                parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n            }\n            break;\n        case \"xmlns\":\n            if (uri !== XMLNS_NAMESPACE) {\n                parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n            }\n            break;\n        default:\n    }\n    switch (uri) {\n        case XMLNS_NAMESPACE:\n            parser.fail(prefix === \"\" ?\n                `the default namespace may not be set to ${uri}.` :\n                `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n            break;\n        case XML_NAMESPACE:\n            switch (prefix) {\n                case \"xml\":\n                    // Assinging the XML namespace to \"xml\" is fine.\n                    break;\n                case \"\":\n                    parser.fail(`the default namespace may not be set to ${uri}.`);\n                    break;\n                default:\n                    parser.fail(\"may not assign the xml namespace to another prefix.\");\n            }\n            break;\n        default:\n    }\n}\nfunction nsMappingCheck(parser, mapping) {\n    for (const local of Object.keys(mapping)) {\n        nsPairCheck(parser, local, mapping[local]);\n    }\n}\nconst isNCName = (name) => NC_NAME_RE.test(name);\nconst isName = (name) => NAME_RE.test(name);\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * The list of supported events.\n */\nexports.EVENTS = [\n    \"xmldecl\",\n    \"text\",\n    \"processinginstruction\",\n    \"doctype\",\n    \"comment\",\n    \"opentagstart\",\n    \"attribute\",\n    \"opentag\",\n    \"closetag\",\n    \"cdata\",\n    \"error\",\n    \"end\",\n    \"ready\",\n];\nconst EVENT_NAME_TO_HANDLER_NAME = {\n    xmldecl: \"xmldeclHandler\",\n    text: \"textHandler\",\n    processinginstruction: \"piHandler\",\n    doctype: \"doctypeHandler\",\n    comment: \"commentHandler\",\n    opentagstart: \"openTagStartHandler\",\n    attribute: \"attributeHandler\",\n    opentag: \"openTagHandler\",\n    closetag: \"closeTagHandler\",\n    cdata: \"cdataHandler\",\n    error: \"errorHandler\",\n    end: \"endHandler\",\n    ready: \"readyHandler\",\n};\n// eslint-disable-next-line @typescript-eslint/ban-types\nclass SaxesParser {\n    /**\n     * Indicates whether or not the parser is closed. If ``true``, wait for\n     * the ``ready`` event to write again.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * @param opt The parser options.\n     */\n    constructor(opt) {\n        this.opt = opt !== null && opt !== void 0 ? opt : {};\n        this.fragmentOpt = !!this.opt.fragment;\n        const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n        this.trackPosition = this.opt.position !== false;\n        this.fileName = this.opt.fileName;\n        if (xmlnsOpt) {\n            // This is the function we use to perform name checks on PIs and entities.\n            // When namespaces are used, colons are not allowed in PI target names or\n            // entity names. So the check depends on whether namespaces are used. See:\n            //\n            // https://www.w3.org/XML/xml-names-19990114-errata.html\n            // NE08\n            //\n            this.nameStartCheck = isNCNameStartChar;\n            this.nameCheck = isNCNameChar;\n            this.isName = isNCName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsNS;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribNS;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n            this.ns = Object.assign({ __proto__: null }, rootNS);\n            const additional = this.opt.additionalNamespaces;\n            if (additional != null) {\n                nsMappingCheck(this, additional);\n                Object.assign(this.ns, additional);\n            }\n        }\n        else {\n            this.nameStartCheck = isNameStartChar;\n            this.nameCheck = isNameChar;\n            this.isName = isName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsPlain;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribPlain;\n        }\n        //\n        // The order of the members in this table needs to correspond to the state\n        // numbers given to the states that correspond to the methods being recorded\n        // here.\n        //\n        this.stateTable = [\n            /* eslint-disable @typescript-eslint/unbound-method */\n            this.sBegin,\n            this.sBeginWhitespace,\n            this.sDoctype,\n            this.sDoctypeQuote,\n            this.sDTD,\n            this.sDTDQuoted,\n            this.sDTDOpenWaka,\n            this.sDTDOpenWakaBang,\n            this.sDTDComment,\n            this.sDTDCommentEnding,\n            this.sDTDCommentEnded,\n            this.sDTDPI,\n            this.sDTDPIEnding,\n            this.sText,\n            this.sEntity,\n            this.sOpenWaka,\n            this.sOpenWakaBang,\n            this.sComment,\n            this.sCommentEnding,\n            this.sCommentEnded,\n            this.sCData,\n            this.sCDataEnding,\n            this.sCDataEnding2,\n            this.sPIFirstChar,\n            this.sPIRest,\n            this.sPIBody,\n            this.sPIEnding,\n            this.sXMLDeclNameStart,\n            this.sXMLDeclName,\n            this.sXMLDeclEq,\n            this.sXMLDeclValueStart,\n            this.sXMLDeclValue,\n            this.sXMLDeclSeparator,\n            this.sXMLDeclEnding,\n            this.sOpenTag,\n            this.sOpenTagSlash,\n            this.sAttrib,\n            this.sAttribName,\n            this.sAttribNameSawWhite,\n            this.sAttribValue,\n            this.sAttribValueQuoted,\n            this.sAttribValueClosed,\n            this.sAttribValueUnquoted,\n            this.sCloseTag,\n            this.sCloseTagSawWhite,\n            /* eslint-enable @typescript-eslint/unbound-method */\n        ];\n        this._init();\n    }\n    _init() {\n        var _a;\n        this.openWakaBang = \"\";\n        this.text = \"\";\n        this.name = \"\";\n        this.piTarget = \"\";\n        this.entity = \"\";\n        this.q = null;\n        this.tags = [];\n        this.tag = null;\n        this.topNS = null;\n        this.chunk = \"\";\n        this.chunkPosition = 0;\n        this.i = 0;\n        this.prevI = 0;\n        this.carriedFromPrevious = undefined;\n        this.forbiddenState = FORBIDDEN_START;\n        this.attribList = [];\n        // The logic is organized so as to minimize the need to check\n        // this.opt.fragment while parsing.\n        const { fragmentOpt } = this;\n        this.state = fragmentOpt ? S_TEXT : S_BEGIN;\n        // We want these to be all true if we are dealing with a fragment.\n        this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot =\n            this.sawRoot = fragmentOpt;\n        // An XML declaration is intially possible only when parsing whole\n        // documents.\n        this.xmlDeclPossible = !fragmentOpt;\n        this.xmlDeclExpects = [\"version\"];\n        this.entityReturnState = undefined;\n        let { defaultXMLVersion } = this.opt;\n        if (defaultXMLVersion === undefined) {\n            if (this.opt.forceXMLVersion === true) {\n                throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n            }\n            defaultXMLVersion = \"1.0\";\n        }\n        this.setXMLVersion(defaultXMLVersion);\n        this.positionAtNewLine = 0;\n        this.doctype = false;\n        this._closed = false;\n        this.xmlDecl = {\n            version: undefined,\n            encoding: undefined,\n            standalone: undefined,\n        };\n        this.line = 1;\n        this.column = 0;\n        this.ENTITIES = Object.create(XML_ENTITIES);\n        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    /**\n     * The stream position the parser is currently looking at. This field is\n     * zero-based.\n     *\n     * This field is not based on counting Unicode characters but is to be\n     * interpreted as a plain index into a JavaScript string.\n     */\n    get position() {\n        return this.chunkPosition + this.i;\n    }\n    /**\n     * The column number of the next character to be read by the parser.  *\n     * This field is zero-based. (The first column in a line is 0.)\n     *\n     * This field reports the index at which the next character would be in the\n     * line if the line were represented as a JavaScript string.  Note that this\n     * *can* be different to a count based on the number of *Unicode characters*\n     * due to how JavaScript handles astral plane characters.\n     *\n     * See [[column]] for a number that corresponds to a count of Unicode\n     * characters.\n     */\n    get columnIndex() {\n        return this.position - this.positionAtNewLine;\n    }\n    /**\n     * Set an event listener on an event. The parser supports one handler per\n     * event type. If you try to set an event handler over an existing handler,\n     * the old handler is silently overwritten.\n     *\n     * @param name The event to listen to.\n     *\n     * @param handler The handler to set.\n     */\n    on(name, handler) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n    }\n    /**\n     * Unset an event handler.\n     *\n     * @parma name The event to stop listening to.\n     */\n    off(name) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n    }\n    /**\n     * Make an error object. The error object will have a message that contains\n     * the ``fileName`` option passed at the creation of the parser. If position\n     * tracking was turned on, it will also have line and column number\n     * information.\n     *\n     * @param message The message describing the error to report.\n     *\n     * @returns An error object with a properly formatted message.\n     */\n    makeError(message) {\n        var _a;\n        let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n        if (this.trackPosition) {\n            if (msg.length > 0) {\n                msg += \":\";\n            }\n            msg += `${this.line}:${this.column}`;\n        }\n        if (msg.length > 0) {\n            msg += \": \";\n        }\n        return new Error(msg + message);\n    }\n    /**\n     * Report a parsing error. This method is made public so that client code may\n     * check for issues that are outside the scope of this project and can report\n     * errors.\n     *\n     * @param message The error to report.\n     *\n     * @returns this\n     */\n    fail(message) {\n        const err = this.makeError(message);\n        const handler = this.errorHandler;\n        if (handler === undefined) {\n            throw err;\n        }\n        else {\n            handler(err);\n        }\n        return this;\n    }\n    /**\n     * Write a XML data to the parser.\n     *\n     * @param chunk The XML data to write.\n     *\n     * @returns this\n     */\n    // We do need object for the type here. Yes, it often causes problems\n    // but not in this case.\n    write(chunk) {\n        if (this.closed) {\n            return this.fail(\"cannot write after close; assign an onready handler.\");\n        }\n        let end = false;\n        if (chunk === null) {\n            // We cannot return immediately because carriedFromPrevious may need\n            // processing.\n            end = true;\n            chunk = \"\";\n        }\n        else if (typeof chunk === \"object\") {\n            chunk = chunk.toString();\n        }\n        // We checked if performing a pre-decomposition of the string into an array\n        // of single complete characters (``Array.from(chunk)``) would be faster\n        // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n        // isn't. (There may be Node-specific code that would perform faster than\n        // ``Array.from`` but don't want to be dependent on Node.)\n        if (this.carriedFromPrevious !== undefined) {\n            // The previous chunk had char we must carry over.\n            chunk = `${this.carriedFromPrevious}${chunk}`;\n            this.carriedFromPrevious = undefined;\n        }\n        let limit = chunk.length;\n        const lastCode = chunk.charCodeAt(limit - 1);\n        if (!end &&\n            // A trailing CR or surrogate must be carried over to the next\n            // chunk.\n            (lastCode === CR || (lastCode >= 0xD800 && lastCode <= 0xDBFF))) {\n            // The chunk ends with a character that must be carried over. We cannot\n            // know how to handle it until we get the next chunk or the end of the\n            // stream. So save it for later.\n            this.carriedFromPrevious = chunk[limit - 1];\n            limit--;\n            chunk = chunk.slice(0, limit);\n        }\n        const { stateTable } = this;\n        this.chunk = chunk;\n        this.i = 0;\n        while (this.i < limit) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument\n            stateTable[this.state].call(this);\n        }\n        this.chunkPosition += limit;\n        return end ? this.end() : this;\n    }\n    /**\n     * Close the current stream. Perform final well-formedness checks and reset\n     * the parser tstate.\n     *\n     * @returns this\n     */\n    close() {\n        return this.write(null);\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.0.\n     *\n     * @returns The character read.\n     */\n    getCode10() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if (code >= SPACE || code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL:\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR:\n                    // We may get NaN if we read past the end of the chunk, which is fine.\n                    if (chunk.charCodeAt(i + 1) === NL) {\n                        // A \\r\\n sequence is converted to \\n so we have to skip over the\n                        // next character. We already know it has a size of 1 so ++ is fine\n                        // here.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n                    // ahead.\n                    // In either case, \\r becomes \\n.\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    // If we get here, then code < SPACE and it is not NL CR or TAB.\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isChar10 that takes into account\n            // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n            // test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isChar10 that takes into account that in\n        // this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.1.\n     *\n     * @returns {number} The character read.\n     */\n    getCode11() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if ((code > 0x1F && code < 0x7F) || (code > 0x9F && code !== LS) ||\n                code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL: // 0xA\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR: { // 0xD\n                    // We may get NaN if we read past the end of the chunk, which is\n                    // fine.\n                    const next = chunk.charCodeAt(i + 1);\n                    if (next === NL || next === NEL) {\n                        // A CR NL or CR NEL sequence is converted to NL so we have to skip\n                        // over the next character. We already know it has a size of 1.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a CR is just converted to NL, no skip.\n                }\n                /* yes, fall through */\n                case NEL: // 0x85\n                case LS: // Ox2028\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isCharAndNotRestricted that takes into\n            // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n            // does not test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isCharAndNotRestricted that takes into\n        // account that in this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Like ``getCode`` but with the return value normalized so that ``NL`` is\n     * returned for ``NL_LIKE``.\n     */\n    getCodeNorm() {\n        const c = this.getCode();\n        return c === NL_LIKE ? NL : c;\n    }\n    unget() {\n        this.i = this.prevI;\n        this.column--;\n    }\n    /**\n     * Capture characters into a buffer until encountering one of a set of\n     * characters.\n     *\n     * @param chars An array of codepoints. Encountering a character in the array\n     * ends the capture. (``chars`` may safely contain ``NL``.)\n     *\n     * @return The character code that made the capture end, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureTo(chars) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            const isNLLike = c === NL_LIKE;\n            const final = isNLLike ? NL : c;\n            if (final === EOC || chars.includes(final)) {\n                this.text += chunk.slice(start, this.prevI);\n                return final;\n            }\n            if (isNLLike) {\n                this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                start = this.i;\n            }\n        }\n    }\n    /**\n     * Capture characters into a buffer until encountering a character.\n     *\n     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\n     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\n     *\n     * @return ``true`` if we ran into the character. Otherwise, we ran into the\n     * end of the current chunk.\n     */\n    captureToChar(char) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            let c = this.getCode();\n            switch (c) {\n                case NL_LIKE:\n                    this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    c = NL;\n                    break;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return false;\n                default:\n            }\n            if (c === char) {\n                this.text += chunk.slice(start, this.prevI);\n                return true;\n            }\n        }\n    }\n    /**\n     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n     * this parser.\n     *\n     * @return The character code that made the test fail, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureNameChars() {\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            if (c === EOC) {\n                this.name += chunk.slice(start);\n                return EOC;\n            }\n            // NL is not a name char so we don't have to test specifically for it.\n            if (!isNameChar(c)) {\n                this.name += chunk.slice(start, this.prevI);\n                return c === NL_LIKE ? NL : c;\n            }\n        }\n    }\n    /**\n     * Skip white spaces.\n     *\n     * @return The character that ended the skip, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    skipSpaces() {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC || !isS(c)) {\n                return c;\n            }\n        }\n    }\n    setXMLVersion(version) {\n        this.currentXMLVersion = version;\n        /*  eslint-disable @typescript-eslint/unbound-method */\n        if (version === \"1.0\") {\n            this.isChar = isChar10;\n            this.getCode = this.getCode10;\n        }\n        else {\n            this.isChar = isChar11;\n            this.getCode = this.getCode11;\n        }\n        /* eslint-enable @typescript-eslint/unbound-method */\n    }\n    // STATE ENGINE METHODS\n    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n    // to be sure never to come back to this state later.\n    sBegin() {\n        // We are essentially peeking at the first character of the chunk. Since\n        // S_BEGIN can be in effect only when we start working on the first chunk,\n        // the index at which we must look is necessarily 0. Note also that the\n        // following test does not depend on decoding surrogates.\n        // If the initial character is 0xFEFF, ignore it.\n        if (this.chunk.charCodeAt(0) === 0xFEFF) {\n            this.i++;\n            this.column++;\n        }\n        this.state = S_BEGIN_WHITESPACE;\n    }\n    sBeginWhitespace() {\n        // We need to know whether we've encountered spaces or not because as soon\n        // as we run into a space, an XML declaration is no longer possible. Rather\n        // than slow down skipSpaces even in places where we don't care whether it\n        // skipped anything or not, we check whether prevI is equal to the value of\n        // i from before we skip spaces.\n        const iBefore = this.i;\n        const c = this.skipSpaces();\n        if (this.prevI !== iBefore) {\n            this.xmlDeclPossible = false;\n        }\n        switch (c) {\n            case LESS:\n                this.state = S_OPEN_WAKA;\n                // We could naively call closeText but in this state, it is not normal\n                // to have text be filled with any data.\n                if (this.text.length !== 0) {\n                    throw new Error(\"no-empty text at start\");\n                }\n                break;\n            case EOC:\n                break;\n            default:\n                this.unget();\n                this.state = S_TEXT;\n                this.xmlDeclPossible = false;\n        }\n    }\n    sDoctype() {\n        var _a;\n        const c = this.captureTo(DOCTYPE_TERMINATOR);\n        switch (c) {\n            case GREATER: {\n                (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                this.doctype = true; // just remember that we saw it.\n                break;\n            }\n            case EOC:\n                break;\n            default:\n                this.text += String.fromCodePoint(c);\n                if (c === OPEN_BRACKET) {\n                    this.state = S_DTD;\n                }\n                else if (isQuote(c)) {\n                    this.state = S_DOCTYPE_QUOTE;\n                    this.q = c;\n                }\n        }\n    }\n    sDoctypeQuote() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.q = null;\n            this.state = S_DOCTYPE;\n        }\n    }\n    sDTD() {\n        const c = this.captureTo(DTD_TERMINATOR);\n        if (c === EOC) {\n            return;\n        }\n        this.text += String.fromCodePoint(c);\n        if (c === CLOSE_BRACKET) {\n            this.state = S_DOCTYPE;\n        }\n        else if (c === LESS) {\n            this.state = S_DTD_OPEN_WAKA;\n        }\n        else if (isQuote(c)) {\n            this.state = S_DTD_QUOTED;\n            this.q = c;\n        }\n    }\n    sDTDQuoted() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.state = S_DTD;\n            this.q = null;\n        }\n    }\n    sDTDOpenWaka() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        switch (c) {\n            case BANG:\n                this.state = S_DTD_OPEN_WAKA_BANG;\n                this.openWakaBang = \"\";\n                break;\n            case QUESTION:\n                this.state = S_DTD_PI;\n                break;\n            default:\n                this.state = S_DTD;\n        }\n    }\n    sDTDOpenWakaBang() {\n        const char = String.fromCodePoint(this.getCodeNorm());\n        const owb = this.openWakaBang += char;\n        this.text += char;\n        if (owb !== \"-\") {\n            this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n            this.openWakaBang = \"\";\n        }\n    }\n    sDTDComment() {\n        if (this.captureToChar(MINUS)) {\n            this.text += \"-\";\n            this.state = S_DTD_COMMENT_ENDING;\n        }\n    }\n    sDTDCommentEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n    }\n    sDTDCommentEnded() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n        else {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.state = S_DTD_COMMENT;\n        }\n    }\n    sDTDPI() {\n        if (this.captureToChar(QUESTION)) {\n            this.text += \"?\";\n            this.state = S_DTD_PI_ENDING;\n        }\n    }\n    sDTDPIEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n    }\n    sText() {\n        //\n        // We did try a version of saxes where the S_TEXT state was split in two\n        // states: one for text inside the root element, and one for text\n        // outside. This was avoiding having to test this.tags.length to decide\n        // what implementation to actually use.\n        //\n        // Peformance testing on gigabyte-size files did not show any advantage to\n        // using the two states solution instead of the current one. Conversely, it\n        // made the code a bit more complicated elsewhere. For instance, a comment\n        // can appear before the root element so when a comment ended it was\n        // necessary to determine whether to return to the S_TEXT state or to the\n        // new text-outside-root state.\n        //\n        if (this.tags.length !== 0) {\n            this.handleTextInRoot();\n        }\n        else {\n            this.handleTextOutsideRoot();\n        }\n    }\n    sEntity() {\n        // This is essentially a specialized version of captureToChar(SEMICOLON...)\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        loop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case NL_LIKE:\n                    this.entity += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    break;\n                case SEMICOLON: {\n                    const { entityReturnState } = this;\n                    const entity = this.entity + chunk.slice(start, this.prevI);\n                    this.state = entityReturnState;\n                    let parsed;\n                    if (entity === \"\") {\n                        this.fail(\"empty entity name.\");\n                        parsed = \"&;\";\n                    }\n                    else {\n                        parsed = this.parseEntity(entity);\n                        this.entity = \"\";\n                    }\n                    if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n                        this.text += parsed;\n                    }\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                }\n                case EOC:\n                    this.entity += chunk.slice(start);\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                default:\n            }\n        }\n    }\n    sOpenWaka() {\n        // Reminder: a state handler is called with at least one character\n        // available in the current chunk. So the first call to get code inside of\n        // a state handler cannot return ``EOC``. That's why we don't test\n        // for it.\n        const c = this.getCode();\n        // either a /, ?, !, or text is coming next.\n        if (isNameStartChar(c)) {\n            this.state = S_OPEN_TAG;\n            this.unget();\n            this.xmlDeclPossible = false;\n        }\n        else {\n            switch (c) {\n                case FORWARD_SLASH:\n                    this.state = S_CLOSE_TAG;\n                    this.xmlDeclPossible = false;\n                    break;\n                case BANG:\n                    this.state = S_OPEN_WAKA_BANG;\n                    this.openWakaBang = \"\";\n                    this.xmlDeclPossible = false;\n                    break;\n                case QUESTION:\n                    this.state = S_PI_FIRST_CHAR;\n                    break;\n                default:\n                    this.fail(\"disallowed character in tag name\");\n                    this.state = S_TEXT;\n                    this.xmlDeclPossible = false;\n            }\n        }\n    }\n    sOpenWakaBang() {\n        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n        switch (this.openWakaBang) {\n            case \"[CDATA[\":\n                if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextBeforeRoot = true;\n                }\n                if (this.closedRoot && !this.reportedTextAfterRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextAfterRoot = true;\n                }\n                this.state = S_CDATA;\n                this.openWakaBang = \"\";\n                break;\n            case \"--\":\n                this.state = S_COMMENT;\n                this.openWakaBang = \"\";\n                break;\n            case \"DOCTYPE\":\n                this.state = S_DOCTYPE;\n                if (this.doctype || this.sawRoot) {\n                    this.fail(\"inappropriately located doctype declaration.\");\n                }\n                this.openWakaBang = \"\";\n                break;\n            default:\n                // 7 happens to be the maximum length of the string that can possibly\n                // match one of the cases above.\n                if (this.openWakaBang.length >= 7) {\n                    this.fail(\"incorrect syntax.\");\n                }\n        }\n    }\n    sComment() {\n        if (this.captureToChar(MINUS)) {\n            this.state = S_COMMENT_ENDING;\n        }\n    }\n    sCommentEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === MINUS) {\n            this.state = S_COMMENT_ENDED;\n            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n            this.text = \"\";\n        }\n        else {\n            this.text += `-${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n    }\n    sCommentEnded() {\n        const c = this.getCodeNorm();\n        if (c !== GREATER) {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.text += `--${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n        else {\n            this.state = S_TEXT;\n        }\n    }\n    sCData() {\n        if (this.captureToChar(CLOSE_BRACKET)) {\n            this.state = S_CDATA_ENDING;\n        }\n    }\n    sCDataEnding() {\n        const c = this.getCodeNorm();\n        if (c === CLOSE_BRACKET) {\n            this.state = S_CDATA_ENDING_2;\n        }\n        else {\n            this.text += `]${String.fromCodePoint(c)}`;\n            this.state = S_CDATA;\n        }\n    }\n    sCDataEnding2() {\n        var _a;\n        const c = this.getCodeNorm();\n        switch (c) {\n            case GREATER: {\n                (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                break;\n            }\n            case CLOSE_BRACKET:\n                this.text += \"]\";\n                break;\n            default:\n                this.text += `]]${String.fromCodePoint(c)}`;\n                this.state = S_CDATA;\n        }\n    }\n    // We need this separate state to check the first character fo the pi target\n    // with this.nameStartCheck which allows less characters than this.nameCheck.\n    sPIFirstChar() {\n        const c = this.getCodeNorm();\n        // This is first because in the case where the file is well-formed this is\n        // the branch taken. We optimize for well-formedness.\n        if (this.nameStartCheck(c)) {\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n        else if (c === QUESTION || isS(c)) {\n            this.fail(\"processing instruction without a target.\");\n            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n        }\n        else {\n            this.fail(\"disallowed character in processing instruction name.\");\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n    }\n    sPIRest() {\n        // Capture characters into a piTarget while ``this.nameCheck`` run on the\n        // character read returns true.\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC) {\n                this.piTarget += chunk.slice(start);\n                return;\n            }\n            // NL cannot satisfy this.nameCheck so we don't have to test specifically\n            // for it.\n            if (!this.nameCheck(c)) {\n                this.piTarget += chunk.slice(start, this.prevI);\n                const isQuestion = c === QUESTION;\n                if (isQuestion || isS(c)) {\n                    if (this.piTarget === \"xml\") {\n                        if (!this.xmlDeclPossible) {\n                            this.fail(\"an XML declaration must be at the start of the document.\");\n                        }\n                        this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n                    }\n                    else {\n                        this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n                    }\n                }\n                else {\n                    this.fail(\"disallowed character in processing instruction name.\");\n                    this.piTarget += String.fromCodePoint(c);\n                }\n                break;\n            }\n        }\n    }\n    sPIBody() {\n        if (this.text.length === 0) {\n            const c = this.getCodeNorm();\n            if (c === QUESTION) {\n                this.state = S_PI_ENDING;\n            }\n            else if (!isS(c)) {\n                this.text = String.fromCodePoint(c);\n            }\n        }\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        else if (this.captureToChar(QUESTION)) {\n            this.state = S_PI_ENDING;\n        }\n    }\n    sPIEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            const { piTarget } = this;\n            if (piTarget.toLowerCase() === \"xml\") {\n                this.fail(\"the XML declaration must appear at the start of the document.\");\n            }\n            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n                target: piTarget,\n                body: this.text,\n            });\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else if (c === QUESTION) {\n            // We ran into ?? as part of a processing instruction. We initially took\n            // the first ? as a sign that the PI was ending, but it is not. So we have\n            // to add it to the body but we take the new ? as a sign that the PI is\n            // ending.\n            this.text += \"?\";\n        }\n        else {\n            this.text += `?${String.fromCodePoint(c)}`;\n            this.state = S_PI_BODY;\n        }\n        this.xmlDeclPossible = false;\n    }\n    sXMLDeclNameStart() {\n        const c = this.skipSpaces();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (c !== EOC) {\n            this.state = S_XML_DECL_NAME;\n            this.name = String.fromCodePoint(c);\n        }\n    }\n    sXMLDeclName() {\n        const c = this.captureTo(XML_DECL_NAME_TERMINATOR);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.name += this.text;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (!(isS(c) || c === EQUAL)) {\n            return;\n        }\n        this.name += this.text;\n        this.text = \"\";\n        if (!this.xmlDeclExpects.includes(this.name)) {\n            switch (this.name.length) {\n                case 0:\n                    this.fail(\"did not expect any more name/value pairs.\");\n                    break;\n                case 1:\n                    this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n                    break;\n                default:\n                    this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n            }\n        }\n        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n    }\n    sXMLDeclEq() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (c !== EQUAL) {\n            this.fail(\"value required.\");\n        }\n        this.state = S_XML_DECL_VALUE_START;\n    }\n    sXMLDeclValueStart() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (!isQuote(c)) {\n            this.fail(\"value must be quoted.\");\n            this.q = SPACE;\n        }\n        else {\n            this.q = c;\n        }\n        this.state = S_XML_DECL_VALUE;\n    }\n    sXMLDeclValue() {\n        const c = this.captureTo([this.q, QUESTION]);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (c === EOC) {\n            return;\n        }\n        const value = this.text;\n        this.text = \"\";\n        switch (this.name) {\n            case \"version\": {\n                this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n                const version = value;\n                this.xmlDecl.version = version;\n                // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n                if (!/^1\\.[0-9]+$/.test(version)) {\n                    this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n                }\n                // When forceXMLVersion is set, the XML declaration is ignored.\n                else if (!this.opt.forceXMLVersion) {\n                    this.setXMLVersion(version);\n                }\n                break;\n            }\n            case \"encoding\":\n                if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n                    this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n                }\n                this.xmlDeclExpects = [\"standalone\"];\n                this.xmlDecl.encoding = value;\n                break;\n            case \"standalone\":\n                if (value !== \"yes\" && value !== \"no\") {\n                    this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n                }\n                this.xmlDeclExpects = [];\n                this.xmlDecl.standalone = value;\n                break;\n            default:\n            // We don't need to raise an error here since we've already raised one\n            // when checking what name was expected.\n        }\n        this.name = \"\";\n        this.state = S_XML_DECL_SEPARATOR;\n    }\n    sXMLDeclSeparator() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (!isS(c)) {\n            this.fail(\"whitespace required.\");\n            this.unget();\n        }\n        this.state = S_XML_DECL_NAME_START;\n    }\n    sXMLDeclEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            if (this.piTarget !== \"xml\") {\n                this.fail(\"processing instructions are not allowed before root.\");\n            }\n            else if (this.name !== \"version\" &&\n                this.xmlDeclExpects.includes(\"version\")) {\n                this.fail(\"XML declaration must contain a version.\");\n            }\n            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n            this.name = \"\";\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else {\n            // We got here because the previous character was a ?, but the question\n            // mark character is not valid inside any of the XML declaration\n            // name/value pairs.\n            this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n        }\n        this.xmlDeclPossible = false;\n    }\n    sOpenTag() {\n        var _a;\n        const c = this.captureNameChars();\n        if (c === EOC) {\n            return;\n        }\n        const tag = this.tag = {\n            name: this.name,\n            attributes: Object.create(null),\n        };\n        this.name = \"\";\n        if (this.xmlnsOpt) {\n            this.topNS = tag.ns = Object.create(null);\n        }\n        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        this.sawRoot = true;\n        if (!this.fragmentOpt && this.closedRoot) {\n            this.fail(\"documents may contain only one root.\");\n        }\n        switch (c) {\n            case GREATER:\n                this.openTag();\n                break;\n            case FORWARD_SLASH:\n                this.state = S_OPEN_TAG_SLASH;\n                break;\n            default:\n                if (!isS(c)) {\n                    this.fail(\"disallowed character in tag name.\");\n                }\n                this.state = S_ATTRIB;\n        }\n    }\n    sOpenTagSlash() {\n        if (this.getCode() === GREATER) {\n            this.openSelfClosingTag();\n        }\n        else {\n            this.fail(\"forward-slash in opening tag not followed by >.\");\n            this.state = S_ATTRIB;\n        }\n    }\n    sAttrib() {\n        const c = this.skipSpaces();\n        if (c === EOC) {\n            return;\n        }\n        if (isNameStartChar(c)) {\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribName() {\n        const c = this.captureNameChars();\n        if (c === EQUAL) {\n            this.state = S_ATTRIB_VALUE;\n        }\n        else if (isS(c)) {\n            this.state = S_ATTRIB_NAME_SAW_WHITE;\n        }\n        else if (c === GREATER) {\n            this.fail(\"attribute without value.\");\n            this.pushAttrib(this.name, this.name);\n            this.name = this.text = \"\";\n            this.openTag();\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribNameSawWhite() {\n        const c = this.skipSpaces();\n        switch (c) {\n            case EOC:\n                return;\n            case EQUAL:\n                this.state = S_ATTRIB_VALUE;\n                break;\n            default:\n                this.fail(\"attribute without value.\");\n                // Should we do this???\n                // this.tag.attributes[this.name] = \"\";\n                this.text = \"\";\n                this.name = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else if (isNameStartChar(c)) {\n                    this.unget();\n                    this.state = S_ATTRIB_NAME;\n                }\n                else {\n                    this.fail(\"disallowed character in attribute name.\");\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sAttribValue() {\n        const c = this.getCodeNorm();\n        if (isQuote(c)) {\n            this.q = c;\n            this.state = S_ATTRIB_VALUE_QUOTED;\n        }\n        else if (!isS(c)) {\n            this.fail(\"unquoted attribute value.\");\n            this.state = S_ATTRIB_VALUE_UNQUOTED;\n            this.unget();\n        }\n    }\n    sAttribValueQuoted() {\n        // We deliberately do not use captureTo here. The specialized code we use\n        // here is faster than using captureTo.\n        const { q, chunk } = this;\n        let { i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case q:\n                    this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n                    this.name = this.text = \"\";\n                    this.q = null;\n                    this.state = S_ATTRIB_VALUE_CLOSED;\n                    return;\n                case AMP:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n                    return;\n                case NL:\n                case NL_LIKE:\n                case TAB:\n                    this.text += `${chunk.slice(start, this.prevI)} `;\n                    start = this.i;\n                    break;\n                case LESS:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.fail(\"disallowed character.\");\n                    return;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return;\n                default:\n            }\n        }\n    }\n    sAttribValueClosed() {\n        const c = this.getCodeNorm();\n        if (isS(c)) {\n            this.state = S_ATTRIB;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else if (isNameStartChar(c)) {\n            this.fail(\"no whitespace between attributes.\");\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribValueUnquoted() {\n        // We don't do anything regarding EOL or space handling for unquoted\n        // attributes. We already have failed by the time we get here, and the\n        // contract that saxes upholds states that upon failure, it is not safe to\n        // rely on the data passed to event handlers (other than\n        // ``onerror``). Passing \"bad\" data is not a problem.\n        const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n        switch (c) {\n            case AMP:\n                this.state = S_ENTITY;\n                this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n                break;\n            case LESS:\n                this.fail(\"disallowed character.\");\n                break;\n            case EOC:\n                break;\n            default:\n                if (this.text.includes(\"]]>\")) {\n                    this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                }\n                this.pushAttrib(this.name, this.text);\n                this.name = this.text = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else {\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sCloseTag() {\n        const c = this.captureNameChars();\n        if (c === GREATER) {\n            this.closeTag();\n        }\n        else if (isS(c)) {\n            this.state = S_CLOSE_TAG_SAW_WHITE;\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    sCloseTagSawWhite() {\n        switch (this.skipSpaces()) {\n            case GREATER:\n                this.closeTag();\n                break;\n            case EOC:\n                break;\n            default:\n                this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    // END OF STATE ENGINE METHODS\n    handleTextInRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for performing the ]]> check. A previous version of this code, checked\n        // ``this.text`` for the presence of ]]>. It simplified the code but was\n        // very costly when character data contained a lot of entities to be parsed.\n        //\n        // Since we are using a specialized loop, we also keep track of the presence\n        // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n        //\n        let { i: start, forbiddenState } = this;\n        const { chunk, textHandler: handler } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        scanLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                case CLOSE_BRACKET:\n                    switch (forbiddenState) {\n                        case FORBIDDEN_START:\n                            forbiddenState = FORBIDDEN_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET:\n                            forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET_BRACKET:\n                            break;\n                        default:\n                            throw new Error(\"impossible state\");\n                    }\n                    break;\n                case GREATER:\n                    if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n                        this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                default:\n                    forbiddenState = FORBIDDEN_START;\n            }\n        }\n        this.forbiddenState = forbiddenState;\n    }\n    handleTextOutsideRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for a specialized task. We keep track of the presence of non-space\n        // characters in the text since these are errors when appearing outside the\n        // document root element.\n        let { i: start } = this;\n        const { chunk, textHandler: handler } = this;\n        let nonSpace = false;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        outRootLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const code = this.getCode();\n            switch (code) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    nonSpace = true;\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                default:\n                    if (!isS(code)) {\n                        nonSpace = true;\n                    }\n            }\n        }\n        if (!nonSpace) {\n            return;\n        }\n        // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n        // to avoid reporting errors for every single character that is out of\n        // place.\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextBeforeRoot = true;\n        }\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextAfterRoot = true;\n        }\n    }\n    pushAttribNS(name, value) {\n        var _a;\n        const { prefix, local } = this.qname(name);\n        const attr = { name, prefix, local, value };\n        this.attribList.push(attr);\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n        if (prefix === \"xmlns\") {\n            const trimmed = value.trim();\n            if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n                this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n            }\n            this.topNS[local] = trimmed;\n            nsPairCheck(this, local, trimmed);\n        }\n        else if (name === \"xmlns\") {\n            const trimmed = value.trim();\n            this.topNS[\"\"] = trimmed;\n            nsPairCheck(this, \"\", trimmed);\n        }\n    }\n    pushAttribPlain(name, value) {\n        var _a;\n        const attr = { name, value };\n        this.attribList.push(attr);\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n    }\n    /**\n     * End parsing. This performs final well-formedness checks and resets the\n     * parser to a clean state.\n     *\n     * @returns this\n     */\n    end() {\n        var _a, _b;\n        if (!this.sawRoot) {\n            this.fail(\"document must contain a root element.\");\n        }\n        const { tags } = this;\n        while (tags.length > 0) {\n            const tag = tags.pop();\n            this.fail(`unclosed tag: ${tag.name}`);\n        }\n        if ((this.state !== S_BEGIN) && (this.state !== S_TEXT)) {\n            this.fail(\"unexpected end.\");\n        }\n        const { text } = this;\n        if (text.length !== 0) {\n            (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n            this.text = \"\";\n        }\n        this._closed = true;\n        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n        this._init();\n        return this;\n    }\n    /**\n     * Resolve a namespace prefix.\n     *\n     * @param prefix The prefix to resolve.\n     *\n     * @returns The namespace URI or ``undefined`` if the prefix is not defined.\n     */\n    resolve(prefix) {\n        var _a, _b;\n        let uri = this.topNS[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        const { tags } = this;\n        for (let index = tags.length - 1; index >= 0; index--) {\n            uri = tags[index].ns[prefix];\n            if (uri !== undefined) {\n                return uri;\n            }\n        }\n        uri = this.ns[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n    }\n    /**\n     * Parse a qname into its prefix and local name parts.\n     *\n     * @param name The name to parse\n     *\n     * @returns\n     */\n    qname(name) {\n        // This is faster than using name.split(\":\").\n        const colon = name.indexOf(\":\");\n        if (colon === -1) {\n            return { prefix: \"\", local: name };\n        }\n        const local = name.slice(colon + 1);\n        const prefix = name.slice(0, colon);\n        if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n            this.fail(`malformed name: ${name}.`);\n        }\n        return { prefix, local };\n    }\n    processAttribsNS() {\n        var _a;\n        const { attribList } = this;\n        const tag = this.tag;\n        {\n            // add namespace info to tag\n            const { prefix, local } = this.qname(tag.name);\n            tag.prefix = prefix;\n            tag.local = local;\n            const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n            if (prefix !== \"\") {\n                if (prefix === \"xmlns\") {\n                    this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n                }\n                if (uri === \"\") {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    tag.uri = prefix;\n                }\n            }\n        }\n        if (attribList.length === 0) {\n            return;\n        }\n        const { attributes } = tag;\n        const seen = new Set();\n        // Note: do not apply default ns to attributes:\n        //   http://www.w3.org/TR/REC-xml-names/#defaulting\n        for (const attr of attribList) {\n            const { name, prefix, local } = attr;\n            let uri;\n            let eqname;\n            if (prefix === \"\") {\n                uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n                eqname = name;\n            }\n            else {\n                uri = this.resolve(prefix);\n                // if there's any attributes with an undefined namespace,\n                // then fail on them now.\n                if (uri === undefined) {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    uri = prefix;\n                }\n                eqname = `{${uri}}${local}`;\n            }\n            if (seen.has(eqname)) {\n                this.fail(`duplicate attribute: ${eqname}.`);\n            }\n            seen.add(eqname);\n            attr.uri = uri;\n            attributes[name] = attr;\n        }\n        this.attribList = [];\n    }\n    processAttribsPlain() {\n        const { attribList } = this;\n        // eslint-disable-next-line prefer-destructuring\n        const attributes = this.tag.attributes;\n        for (const { name, value } of attribList) {\n            if (attributes[name] !== undefined) {\n                this.fail(`duplicate attribute: ${name}.`);\n            }\n            attributes[name] = value;\n        }\n        this.attribList = [];\n    }\n    /**\n     * Handle a complete open tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag``.\n     */\n    openTag() {\n        var _a;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = false;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        tags.push(tag);\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete self-closing tag. This parser code calls this once it has\n     * seen the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag`` and ``onclosetag``.\n     */\n    openSelfClosingTag() {\n        var _a, _b, _c;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = true;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n        const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n        if (top === null) {\n            this.closedRoot = true;\n        }\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete close tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onclosetag``.\n     */\n    closeTag() {\n        const { tags, name } = this;\n        // Our state after this will be S_TEXT, no matter what, and we can clear\n        // tagName now.\n        this.state = S_TEXT;\n        this.name = \"\";\n        if (name === \"\") {\n            this.fail(\"weird empty close tag.\");\n            this.text += \"</>\";\n            return;\n        }\n        const handler = this.closeTagHandler;\n        let l = tags.length;\n        while (l-- > 0) {\n            const tag = this.tag = tags.pop();\n            this.topNS = tag.ns;\n            handler === null || handler === void 0 ? void 0 : handler(tag);\n            if (tag.name === name) {\n                break;\n            }\n            this.fail(\"unexpected close tag.\");\n        }\n        if (l === 0) {\n            this.closedRoot = true;\n        }\n        else if (l < 0) {\n            this.fail(`unmatched closing tag: ${name}.`);\n            this.text += `</${name}>`;\n        }\n    }\n    /**\n     * Resolves an entity. Makes any necessary well-formedness checks.\n     *\n     * @param entity The entity to resolve.\n     *\n     * @returns The parsed entity.\n     */\n    parseEntity(entity) {\n        // startsWith would be significantly slower for this test.\n        if (entity[0] !== \"#\") {\n            const defined = this.ENTITIES[entity];\n            if (defined !== undefined) {\n                return defined;\n            }\n            this.fail(this.isName(entity) ? \"undefined entity.\" :\n                \"disallowed character in entity name.\");\n            return `&${entity};`;\n        }\n        let num = NaN;\n        if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n            num = parseInt(entity.slice(2), 16);\n        }\n        else if (/^#[0-9]+$/.test(entity)) {\n            num = parseInt(entity.slice(1), 10);\n        }\n        // The character reference is required to match the CHAR production.\n        if (!this.isChar(num)) {\n            this.fail(\"malformed character entity.\");\n            return `&${entity};`;\n        }\n        return String.fromCodePoint(num);\n    }\n}\nexports.SaxesParser = SaxesParser;\n//# sourceMappingURL=saxes.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/RdfXmlParser\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParseError = void 0;\n/**\n * An error that includes line and column in the error message.\n */\nclass ParseError extends Error {\n    constructor(parser, message) {\n        const saxParser = parser.saxParser;\n        super(parser.trackPosition ? `Line ${saxParser.line} column ${saxParser.column + 1}: ${message}` : message);\n    }\n}\nexports.ParseError = ParseError;\n//# sourceMappingURL=ParseError.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParseType = exports.RdfXmlParser = void 0;\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst saxes_1 = require(\"@rubensworks/saxes\");\nconst readable_stream_1 = require(\"readable-stream\");\nconst ParseError_1 = require(\"./ParseError\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst validate_iri_1 = require(\"validate-iri\");\nclass RdfXmlParser extends readable_stream_1.Transform {\n    constructor(args) {\n        super({ readableObjectMode: true });\n        this.activeTagStack = [];\n        this.nodeIds = {};\n        if (args) {\n            Object.assign(this, args);\n            this.options = args;\n        }\n        if (!this.dataFactory) {\n            this.dataFactory = new rdf_data_factory_1.DataFactory();\n        }\n        if (!this.baseIRI) {\n            this.baseIRI = '';\n        }\n        if (!this.defaultGraph) {\n            this.defaultGraph = this.dataFactory.defaultGraph();\n        }\n        if (this.validateUri !== false) {\n            this.validateUri = true;\n        }\n        if (!this.iriValidationStrategy) {\n            this.iriValidationStrategy = this.validateUri ? validate_iri_1.IriValidationStrategy.Pragmatic : validate_iri_1.IriValidationStrategy.None;\n        }\n        this.saxParser = new saxes_1.SaxesParser({ xmlns: true, position: this.trackPosition });\n        this.attachSaxListeners();\n    }\n    /**\n     * Parses the given text stream into a quad stream.\n     * @param {NodeJS.EventEmitter} stream A text stream.\n     * @return {RDF.Stream} A quad stream.\n     */\n    import(stream) {\n        const output = new readable_stream_1.PassThrough({ readableObjectMode: true });\n        stream.on('error', (error) => parsed.emit('error', error));\n        stream.on('data', (data) => output.push(data));\n        stream.on('end', () => output.push(null));\n        const parsed = output.pipe(new RdfXmlParser(this.options));\n        return parsed;\n    }\n    _transform(chunk, encoding, callback) {\n        try {\n            this.saxParser.write(chunk);\n        }\n        catch (e) {\n            return callback(e);\n        }\n        callback();\n    }\n    /**\n     * Create a new parse error instance.\n     * @param {string} message An error message.\n     * @return {Error} An error instance.\n     */\n    newParseError(message) {\n        return new ParseError_1.ParseError(this, message);\n    }\n    /**\n     * Convert the given value to a IRI by taking into account the baseIRI.\n     *\n     * This will follow the RDF/XML spec for converting values with baseIRIs to a IRI.\n     *\n     * @param {string} value The value to convert to an IRI.\n     * @param {IActiveTag} activeTag The active tag.\n     * @return {NamedNode} an IRI.\n     */\n    valueToUri(value, activeTag) {\n        return this.uriToNamedNode((0, relative_to_absolute_iri_1.resolve)(value, activeTag.baseIRI));\n    }\n    /**\n     * Convert the given value URI string to a named node.\n     *\n     * This throw an error if the URI is invalid.\n     *\n     * @param {string} uri A URI string.\n     * @return {NamedNode} a named node.\n     */\n    uriToNamedNode(uri) {\n        // Validate URI\n        const uriValidationResult = (0, validate_iri_1.validateIri)(uri, this.iriValidationStrategy);\n        if (uriValidationResult instanceof Error) {\n            throw this.newParseError(uriValidationResult.message);\n        }\n        return this.dataFactory.namedNode(uri);\n    }\n    /**\n     * Validate the given value as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n     * If it is invalid, an error will thrown emitted.\n     * @param {string} value A value.\n     */\n    validateNcname(value) {\n        // Validate term as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n        if (!RdfXmlParser.NCNAME_MATCHER.test(value)) {\n            throw this.newParseError(`Not a valid NCName: ${value}`);\n        }\n    }\n    attachSaxListeners() {\n        this.saxParser.on('error', (error) => this.emit('error', error));\n        this.saxParser.on('opentag', this.onTag.bind(this));\n        this.saxParser.on('text', this.onText.bind(this));\n        this.saxParser.on('cdata', this.onText.bind(this));\n        this.saxParser.on('closetag', this.onCloseTag.bind(this));\n        this.saxParser.on('doctype', this.onDoctype.bind(this));\n    }\n    /**\n     * Handle the given tag.\n     * @param {SaxesTagNS} tag A SAX tag.\n     */\n    onTag(tag) {\n        // Get parent tag\n        const parentTag = this.activeTagStack.length\n            ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n        let currentParseType = ParseType.RESOURCE;\n        if (parentTag) {\n            parentTag.hadChildren = true;\n            currentParseType = parentTag.childrenParseType;\n        }\n        // Check if this tag needs to be converted to a string\n        if (parentTag && parentTag.childrenStringTags) {\n            // Convert this tag to a string\n            const tagName = tag.name;\n            let attributes = '';\n            for (const attributeKey in tag.attributes) {\n                attributes += ` ${attributeKey}=\"${tag.attributes[attributeKey].value}\"`;\n            }\n            const tagContents = `${tagName}${attributes}`;\n            const tagString = `<${tagContents}>`;\n            parentTag.childrenStringTags.push(tagString);\n            // Inherit the array, so that deeper tags are appended to this same array\n            const stringActiveTag = { childrenStringTags: parentTag.childrenStringTags };\n            stringActiveTag.childrenStringEmitClosingTag = `</${tagName}>`;\n            this.activeTagStack.push(stringActiveTag);\n            // Halt any further processing\n            return;\n        }\n        const activeTag = {};\n        if (parentTag) {\n            // Inherit language scope and baseIRI from parent\n            activeTag.language = parentTag.language;\n            activeTag.baseIRI = parentTag.baseIRI;\n        }\n        else {\n            activeTag.baseIRI = this.baseIRI;\n        }\n        this.activeTagStack.push(activeTag);\n        if (currentParseType === ParseType.RESOURCE) {\n            this.onTagResource(tag, activeTag, parentTag, !parentTag);\n        }\n        else { // currentParseType === ParseType.PROPERTY\n            this.onTagProperty(tag, activeTag, parentTag);\n        }\n    }\n    /**\n     * Handle the given node element in resource-mode.\n     * @param {SaxesTagNS} tag A SAX tag.\n     * @param {IActiveTag} activeTag The currently active tag.\n     * @param {IActiveTag} parentTag The parent tag or null.\n     * @param {boolean} rootTag If we are currently processing the root tag.\n     */\n    onTagResource(tag, activeTag, parentTag, rootTag) {\n        activeTag.childrenParseType = ParseType.PROPERTY;\n        // Assume that the current node is a _typed_ node (2.13), unless we find an rdf:Description as node name\n        let typedNode = true;\n        if (tag.uri === RdfXmlParser.RDF) {\n            // Check forbidden property element names\n            if (!rootTag && RdfXmlParser.FORBIDDEN_NODE_ELEMENTS.indexOf(tag.local) >= 0) {\n                throw this.newParseError(`Illegal node element name: ${tag.local}`);\n            }\n            switch (tag.local) {\n                case 'RDF':\n                    // Tags under <rdf:RDF> must always be resources\n                    activeTag.childrenParseType = ParseType.RESOURCE;\n                case 'Description':\n                    typedNode = false;\n            }\n        }\n        const predicates = [];\n        const objects = [];\n        // Collect all attributes as triples\n        // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n        let activeSubjectValue = null;\n        let claimSubjectNodeId = false;\n        let subjectValueBlank = false;\n        let explicitType = null;\n        for (const attributeKey in tag.attributes) {\n            const attribute = tag.attributes[attributeKey];\n            if (parentTag && attribute.uri === RdfXmlParser.RDF) {\n                switch (attribute.local) {\n                    case 'about':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        activeSubjectValue = attribute.value;\n                        continue;\n                    case 'ID':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        this.validateNcname(attribute.value);\n                        activeSubjectValue = '#' + attribute.value;\n                        claimSubjectNodeId = true;\n                        continue;\n                    case 'nodeID':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        this.validateNcname(attribute.value);\n                        activeSubjectValue = attribute.value;\n                        subjectValueBlank = true;\n                        continue;\n                    case 'bagID':\n                        throw this.newParseError(`rdf:bagID is not supported.`);\n                    case 'type':\n                        // Emit the rdf:type later as named node instead of the default literal\n                        explicitType = attribute.value;\n                        continue;\n                    case 'aboutEach':\n                        throw this.newParseError(`rdf:aboutEach is not supported.`);\n                    case 'aboutEachPrefix':\n                        throw this.newParseError(`rdf:aboutEachPrefix is not supported.`);\n                    case 'li':\n                        throw this.newParseError(`rdf:li on node elements are not supported.`);\n                }\n            }\n            else if (attribute.uri === RdfXmlParser.XML) {\n                if (attribute.local === 'lang') {\n                    activeTag.language = attribute.value === '' ? null : attribute.value.toLowerCase();\n                    continue;\n                }\n                else if (attribute.local === 'base') {\n                    // SAX Parser does not expand xml:base, based on DOCTYPE, so we have to do it manually\n                    activeTag.baseIRI = (0, relative_to_absolute_iri_1.resolve)(attribute.value, activeTag.baseIRI);\n                    continue;\n                }\n            }\n            // Interpret attributes at this point as properties on this node,\n            // but we ignore attributes that have no prefix or known expanded URI\n            if (attribute.prefix !== 'xml' && attribute.prefix !== 'xmlns'\n                && (attribute.prefix !== '' || attribute.local !== 'xmlns')\n                && attribute.uri) {\n                predicates.push(this.uriToNamedNode(attribute.uri + attribute.local));\n                objects.push(attribute.value);\n            }\n        }\n        // Create the subject value _after_ all attributes have been processed\n        if (activeSubjectValue !== null) {\n            activeTag.subject = subjectValueBlank\n                ? this.dataFactory.blankNode(activeSubjectValue) : this.valueToUri(activeSubjectValue, activeTag);\n            if (claimSubjectNodeId) {\n                this.claimNodeId(activeTag.subject);\n            }\n        }\n        // Force the creation of a subject if it doesn't exist yet\n        if (!activeTag.subject) {\n            activeTag.subject = this.dataFactory.blankNode();\n        }\n        // Emit the type if we're at a typed node\n        if (typedNode) {\n            const type = this.uriToNamedNode(tag.uri + tag.local);\n            this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), type, parentTag ? parentTag.reifiedStatementId : null);\n        }\n        if (parentTag) {\n            // If the parent tag defined a predicate, add the current tag as property value\n            if (parentTag.predicate) {\n                if (parentTag.childrenCollectionSubject) {\n                    // RDF:List-based properties\n                    const linkTerm = this.dataFactory.blankNode();\n                    // Emit <x> <p> <current-chain> OR <previous-chain> <rdf:rest> <current-chain>\n                    this.emitTriple(parentTag.childrenCollectionSubject, parentTag.childrenCollectionPredicate, linkTerm, parentTag.reifiedStatementId);\n                    // Emit <current-chain> <rdf:first> value\n                    this.emitTriple(linkTerm, this.dataFactory.namedNode(RdfXmlParser.RDF + 'first'), activeTag.subject, activeTag.reifiedStatementId);\n                    // Store <current-chain> in the parent node\n                    parentTag.childrenCollectionSubject = linkTerm;\n                    parentTag.childrenCollectionPredicate = this.dataFactory.namedNode(RdfXmlParser.RDF + 'rest');\n                }\n                else { // !parentTag.predicateEmitted\n                    // Set-based properties\n                    this.emitTriple(parentTag.subject, parentTag.predicate, activeTag.subject, parentTag.reifiedStatementId);\n                    // Emit pending properties on the parent tag that had no defined subject yet.\n                    for (let i = 0; i < parentTag.predicateSubPredicates.length; i++) {\n                        this.emitTriple(activeTag.subject, parentTag.predicateSubPredicates[i], parentTag.predicateSubObjects[i], null);\n                    }\n                    // Cleanup so we don't emit them again when the parent tag is closed\n                    parentTag.predicateSubPredicates = [];\n                    parentTag.predicateSubObjects = [];\n                    parentTag.predicateEmitted = true;\n                }\n            }\n            // Emit all collected triples\n            for (let i = 0; i < predicates.length; i++) {\n                const object = this.dataFactory.literal(objects[i], activeTag.datatype || activeTag.language);\n                this.emitTriple(activeTag.subject, predicates[i], object, parentTag.reifiedStatementId);\n            }\n            // Emit the rdf:type as named node instead of literal\n            if (explicitType) {\n                this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), this.uriToNamedNode(explicitType), null);\n            }\n        }\n    }\n    /**\n     * Handle the given property element in property-mode.\n     * @param {SaxesTagNS} tag A SAX tag.\n     * @param {IActiveTag} activeTag The currently active tag.\n     * @param {IActiveTag} parentTag The parent tag or null.\n     */\n    onTagProperty(tag, activeTag, parentTag) {\n        activeTag.childrenParseType = ParseType.RESOURCE;\n        activeTag.subject = parentTag.subject; // Inherit parent subject\n        if (tag.uri === RdfXmlParser.RDF && tag.local === 'li') {\n            // Convert rdf:li to rdf:_x\n            if (!parentTag.listItemCounter) {\n                parentTag.listItemCounter = 1;\n            }\n            activeTag.predicate = this.uriToNamedNode(tag.uri + '_' + parentTag.listItemCounter++);\n        }\n        else {\n            activeTag.predicate = this.uriToNamedNode(tag.uri + tag.local);\n        }\n        // Check forbidden property element names\n        if (tag.uri === RdfXmlParser.RDF\n            && RdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS.indexOf(tag.local) >= 0) {\n            throw this.newParseError(`Illegal property element name: ${tag.local}`);\n        }\n        activeTag.predicateSubPredicates = [];\n        activeTag.predicateSubObjects = [];\n        let parseType = false;\n        let attributedProperty = false;\n        // Collect all attributes as triples\n        // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n        let activeSubSubjectValue = null;\n        let subSubjectValueBlank = true;\n        const predicates = [];\n        const objects = [];\n        for (const propertyAttributeKey in tag.attributes) {\n            const propertyAttribute = tag.attributes[propertyAttributeKey];\n            if (propertyAttribute.uri === RdfXmlParser.RDF) {\n                switch (propertyAttribute.local) {\n                    case 'resource':\n                        if (activeSubSubjectValue) {\n                            throw this.newParseError(`Found both rdf:resource (${propertyAttribute.value}) and rdf:nodeID (${activeSubSubjectValue}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:resource (${propertyAttribute.value})`);\n                        }\n                        activeTag.hadChildren = true;\n                        activeSubSubjectValue = propertyAttribute.value;\n                        subSubjectValueBlank = false;\n                        continue;\n                    case 'datatype':\n                        if (attributedProperty) {\n                            throw this.newParseError(`Found both non-rdf:* property attributes and rdf:datatype (${propertyAttribute.value}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${propertyAttribute.value})`);\n                        }\n                        activeTag.datatype = this.valueToUri(propertyAttribute.value, activeTag);\n                        continue;\n                    case 'nodeID':\n                        if (attributedProperty) {\n                            throw this.newParseError(`Found both non-rdf:* property attributes and rdf:nodeID (${propertyAttribute.value}).`);\n                        }\n                        if (activeTag.hadChildren) {\n                            throw this.newParseError(`Found both rdf:resource and rdf:nodeID (${propertyAttribute.value}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID (${propertyAttribute.value})`);\n                        }\n                        this.validateNcname(propertyAttribute.value);\n                        activeTag.hadChildren = true;\n                        activeSubSubjectValue = propertyAttribute.value;\n                        subSubjectValueBlank = true;\n                        continue;\n                    case 'bagID':\n                        throw this.newParseError(`rdf:bagID is not supported.`);\n                    case 'parseType':\n                        // Validation\n                        if (attributedProperty) {\n                            throw this.newParseError(`rdf:parseType is not allowed when non-rdf:* property attributes are present`);\n                        }\n                        if (activeTag.datatype) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${activeTag.datatype.value})`);\n                        }\n                        if (activeSubSubjectValue) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID or rdf:resource (${activeSubSubjectValue})`);\n                        }\n                        if (propertyAttribute.value === 'Resource') {\n                            parseType = true;\n                            activeTag.childrenParseType = ParseType.PROPERTY;\n                            // Turn this property element into a node element\n                            const nestedBNode = this.dataFactory.blankNode();\n                            this.emitTriple(activeTag.subject, activeTag.predicate, nestedBNode, activeTag.reifiedStatementId);\n                            activeTag.subject = nestedBNode;\n                            activeTag.predicate = null;\n                        }\n                        else if (propertyAttribute.value === 'Collection') {\n                            parseType = true;\n                            // Interpret children as being part of an rdf:List\n                            activeTag.hadChildren = true;\n                            activeTag.childrenCollectionSubject = activeTag.subject;\n                            activeTag.childrenCollectionPredicate = activeTag.predicate;\n                            subSubjectValueBlank = false;\n                        }\n                        else if (propertyAttribute.value === 'Literal') {\n                            parseType = true;\n                            // Interpret children as being part of a literal string\n                            activeTag.childrenTagsToString = true;\n                            activeTag.childrenStringTags = [];\n                        }\n                        continue;\n                    case 'ID':\n                        this.validateNcname(propertyAttribute.value);\n                        activeTag.reifiedStatementId = this.valueToUri('#' + propertyAttribute.value, activeTag);\n                        this.claimNodeId(activeTag.reifiedStatementId);\n                        continue;\n                }\n            }\n            else if (propertyAttribute.uri === RdfXmlParser.XML && propertyAttribute.local === 'lang') {\n                activeTag.language = propertyAttribute.value === ''\n                    ? null : propertyAttribute.value.toLowerCase();\n                continue;\n            }\n            // Interpret attributes at this point as properties via implicit blank nodes on the property,\n            // but we ignore attributes that have no prefix or known expanded URI\n            if (propertyAttribute.prefix !== 'xml' && propertyAttribute.prefix !== 'xmlns'\n                && (propertyAttribute.prefix !== '' || propertyAttribute.local !== 'xmlns')\n                && propertyAttribute.uri) {\n                if (parseType || activeTag.datatype) {\n                    throw this.newParseError(`Found illegal rdf:* properties on property element with attribute: ${propertyAttribute.value}`);\n                }\n                activeTag.hadChildren = true;\n                attributedProperty = true;\n                predicates.push(this.uriToNamedNode(propertyAttribute.uri + propertyAttribute.local));\n                objects.push(this.dataFactory.literal(propertyAttribute.value, activeTag.datatype || activeTag.language));\n            }\n        }\n        // Create the subject value _after_ all attributes have been processed\n        if (activeSubSubjectValue !== null) {\n            const subjectParent = activeTag.subject;\n            activeTag.subject = subSubjectValueBlank\n                ? this.dataFactory.blankNode(activeSubSubjectValue) : this.valueToUri(activeSubSubjectValue, activeTag);\n            this.emitTriple(subjectParent, activeTag.predicate, activeTag.subject, activeTag.reifiedStatementId);\n            // Emit our buffered triples\n            for (let i = 0; i < predicates.length; i++) {\n                this.emitTriple(activeTag.subject, predicates[i], objects[i], null);\n            }\n            activeTag.predicateEmitted = true;\n        }\n        else if (subSubjectValueBlank) {\n            // The current property element has no defined subject\n            // Let's buffer the properties until the child node defines a subject,\n            // or if the tag closes.\n            activeTag.predicateSubPredicates = predicates;\n            activeTag.predicateSubObjects = objects;\n            activeTag.predicateEmitted = false;\n        }\n    }\n    /**\n     * Emit the given triple to the stream.\n     * @param {Term} subject A subject term.\n     * @param {Term} predicate A predicate term.\n     * @param {Term} object An object term.\n     * @param {Term} statementId An optional resource that identifies the triple.\n     *                           If truthy, then the given triple will also be emitted reified.\n     */\n    emitTriple(subject, predicate, object, statementId) {\n        this.push(this.dataFactory.quad(subject, predicate, object, this.defaultGraph));\n        // Reify triple\n        if (statementId) {\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), this.dataFactory.namedNode(RdfXmlParser.RDF + 'Statement'), this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'subject'), subject, this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'predicate'), predicate, this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'object'), object, this.defaultGraph));\n        }\n    }\n    /**\n     * Register the given term as a node ID.\n     * If one was already registered, this will emit an error.\n     *\n     * This is used to check duplicate occurrences of rdf:ID in scope of the baseIRI.\n     * @param {Term} term An RDF term.\n     */\n    claimNodeId(term) {\n        if (!this.allowDuplicateRdfIds) {\n            if (this.nodeIds[term.value]) {\n                throw this.newParseError(`Found multiple occurrences of rdf:ID='${term.value}'.`);\n            }\n            this.nodeIds[term.value] = true;\n        }\n    }\n    /**\n     * Handle the given text string.\n     * @param {string} text A parsed text string.\n     */\n    onText(text) {\n        const activeTag = this.activeTagStack.length\n            ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n        if (activeTag) {\n            if (activeTag.childrenStringTags) {\n                activeTag.childrenStringTags.push(text);\n            }\n            else if (activeTag.predicate) {\n                activeTag.text = text;\n            }\n        }\n    }\n    /**\n     * Handle the closing of the last tag.\n     */\n    onCloseTag() {\n        const poppedTag = this.activeTagStack.pop();\n        // If we were converting a tag to a string, and the tag was not self-closing, close it here.\n        if (poppedTag.childrenStringEmitClosingTag) {\n            poppedTag.childrenStringTags.push(poppedTag.childrenStringEmitClosingTag);\n        }\n        // Set the literal value if we were collecting XML tags to string\n        if (poppedTag.childrenTagsToString) {\n            poppedTag.datatype = this.dataFactory.namedNode(RdfXmlParser.RDF + 'XMLLiteral');\n            poppedTag.text = poppedTag.childrenStringTags.join('');\n            poppedTag.hadChildren = false; // Force a literal triple to be emitted hereafter\n        }\n        if (poppedTag.childrenCollectionSubject) {\n            // Terminate the rdf:List\n            this.emitTriple(poppedTag.childrenCollectionSubject, poppedTag.childrenCollectionPredicate, this.dataFactory.namedNode(RdfXmlParser.RDF + 'nil'), poppedTag.reifiedStatementId);\n        }\n        else if (poppedTag.predicate) {\n            if (!poppedTag.hadChildren && poppedTag.childrenParseType !== ParseType.PROPERTY) {\n                // Property element contains text\n                this.emitTriple(poppedTag.subject, poppedTag.predicate, this.dataFactory.literal(poppedTag.text || '', poppedTag.datatype || poppedTag.language), poppedTag.reifiedStatementId);\n            }\n            else if (!poppedTag.predicateEmitted) {\n                // Emit remaining properties on an anonymous property element\n                const subject = this.dataFactory.blankNode();\n                this.emitTriple(poppedTag.subject, poppedTag.predicate, subject, poppedTag.reifiedStatementId);\n                for (let i = 0; i < poppedTag.predicateSubPredicates.length; i++) {\n                    this.emitTriple(subject, poppedTag.predicateSubPredicates[i], poppedTag.predicateSubObjects[i], null);\n                }\n            }\n        }\n    }\n    /**\n     * Fetch local DOCTYPE ENTITY's and make the parser recognise them.\n     * @param {string} doctype The read doctype.\n     */\n    onDoctype(doctype) {\n        doctype.replace(/<!ENTITY\\s+([^\\s]+)\\s+[\"']([^\"']+)[\"']\\s*>/g, (match, prefix, uri) => {\n            this.saxParser.ENTITIES[prefix] = uri;\n            return '';\n        });\n    }\n}\nexports.RdfXmlParser = RdfXmlParser;\nRdfXmlParser.MIME_TYPE = 'application/rdf+xml';\nRdfXmlParser.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nRdfXmlParser.XML = 'http://www.w3.org/XML/1998/namespace';\nRdfXmlParser.FORBIDDEN_NODE_ELEMENTS = [\n    'RDF',\n    'ID',\n    'about',\n    'bagID',\n    'parseType',\n    'resource',\n    'nodeID',\n    'li',\n    'aboutEach',\n    'aboutEachPrefix',\n];\nRdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS = [\n    'Description',\n    'RDF',\n    'ID',\n    'about',\n    'bagID',\n    'parseType',\n    'resource',\n    'nodeID',\n    'aboutEach',\n    'aboutEachPrefix',\n];\n// tslint:disable-next-line:max-line-length\nRdfXmlParser.NCNAME_MATCHER = /^([A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\u{F8}-\\u{2FF}\\u{370}-\\u{37D}\\u{37F}-\\u{1FFF}\\u{200C}-\\u{200D}\\u{2070}-\\u{218F}\\u{2C00}-\\u{2FEF}\\u{3001}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFFD}\\u{10000}-\\u{EFFFF}_])([A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\u{F8}-\\u{2FF}\\u{370}-\\u{37D}\\u{37F}-\\u{1FFF}\\u{200C}-\\u{200D}\\u{2070}-\\u{218F}\\u{2C00}-\\u{2FEF}\\u{3001}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFFD}\\u{10000}-\\u{EFFFF}_\\-.0-9#xB7\\u{0300}-\\u{036F}\\u{203F}-\\u{2040}])*$/u;\nvar ParseType;\n(function (ParseType) {\n    ParseType[ParseType[\"RESOURCE\"] = 0] = \"RESOURCE\";\n    ParseType[ParseType[\"PROPERTY\"] = 1] = \"PROPERTY\";\n})(ParseType || (exports.ParseType = ParseType = {}));\n//# sourceMappingURL=RdfXmlParser.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/BlankNode\"), exports);\n__exportStar(require(\"./lib/DataFactory\"), exports);\n__exportStar(require(\"./lib/DefaultGraph\"), exports);\n__exportStar(require(\"./lib/Literal\"), exports);\n__exportStar(require(\"./lib/NamedNode\"), exports);\n__exportStar(require(\"./lib/Quad\"), exports);\n__exportStar(require(\"./lib/Variable\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlankNode = void 0;\n/**\n * A term that represents an RDF blank node with a label.\n */\nclass BlankNode {\n    constructor(value) {\n        this.termType = 'BlankNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'BlankNode' && other.value === this.value;\n    }\n}\nexports.BlankNode = BlankNode;\n//# sourceMappingURL=BlankNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataFactory = void 0;\nconst BlankNode_1 = require(\"./BlankNode\");\nconst DefaultGraph_1 = require(\"./DefaultGraph\");\nconst Literal_1 = require(\"./Literal\");\nconst NamedNode_1 = require(\"./NamedNode\");\nconst Quad_1 = require(\"./Quad\");\nconst Variable_1 = require(\"./Variable\");\nlet dataFactoryCounter = 0;\n/**\n * A factory for instantiating RDF terms and quads.\n */\nclass DataFactory {\n    constructor(options) {\n        this.blankNodeCounter = 0;\n        options = options || {};\n        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;\n    }\n    /**\n     * @param value The IRI for the named node.\n     * @return A new instance of NamedNode.\n     * @see NamedNode\n     */\n    namedNode(value) {\n        return new NamedNode_1.NamedNode(value);\n    }\n    /**\n     * @param value The optional blank node identifier.\n     * @return A new instance of BlankNode.\n     *         If the `value` parameter is undefined a new identifier\n     *         for the blank node is generated for each call.\n     * @see BlankNode\n     */\n    blankNode(value) {\n        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);\n    }\n    /**\n     * @param value              The literal value.\n     * @param languageOrDatatype The optional language or datatype.\n     *                           If `languageOrDatatype` is a NamedNode,\n     *                           then it is used for the value of `NamedNode.datatype`.\n     *                           Otherwise `languageOrDatatype` is used for the value\n     *                           of `NamedNode.language`.\n     * @return A new instance of Literal.\n     * @see Literal\n     */\n    literal(value, languageOrDatatype) {\n        return new Literal_1.Literal(value, languageOrDatatype);\n    }\n    /**\n     * This method is optional.\n     * @param value The variable name\n     * @return A new instance of Variable.\n     * @see Variable\n     */\n    variable(value) {\n        return new Variable_1.Variable(value);\n    }\n    /**\n     * @return An instance of DefaultGraph.\n     */\n    defaultGraph() {\n        return DefaultGraph_1.DefaultGraph.INSTANCE;\n    }\n    /**\n     * @param subject   The quad subject term.\n     * @param predicate The quad predicate term.\n     * @param object    The quad object term.\n     * @param graph     The quad graph term.\n     * @return A new instance of Quad.\n     * @see Quad\n     */\n    quad(subject, predicate, object, graph) {\n        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());\n    }\n    /**\n     * Create a deep copy of the given term using this data factory.\n     * @param original An RDF term.\n     * @return A deep copy of the given term.\n     */\n    fromTerm(original) {\n        // TODO: remove nasty any casts when this TS bug has been fixed:\n        //  https://github.com/microsoft/TypeScript/issues/26933\n        switch (original.termType) {\n            case 'NamedNode':\n                return this.namedNode(original.value);\n            case 'BlankNode':\n                return this.blankNode(original.value);\n            case 'Literal':\n                if (original.language) {\n                    return this.literal(original.value, original.language);\n                }\n                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {\n                    return this.literal(original.value, this.fromTerm(original.datatype));\n                }\n                return this.literal(original.value);\n            case 'Variable':\n                return this.variable(original.value);\n            case 'DefaultGraph':\n                return this.defaultGraph();\n            case 'Quad':\n                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));\n        }\n    }\n    /**\n     * Create a deep copy of the given quad using this data factory.\n     * @param original An RDF quad.\n     * @return A deep copy of the given quad.\n     */\n    fromQuad(original) {\n        return this.fromTerm(original);\n    }\n    /**\n     * Reset the internal blank node counter.\n     */\n    resetBlankNodeCounter() {\n        this.blankNodeCounter = 0;\n    }\n}\nexports.DataFactory = DataFactory;\n//# sourceMappingURL=DataFactory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultGraph = void 0;\n/**\n * A singleton term instance that represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass DefaultGraph {\n    constructor() {\n        this.termType = 'DefaultGraph';\n        this.value = '';\n        // Private constructor\n    }\n    equals(other) {\n        return !!other && other.termType === 'DefaultGraph';\n    }\n}\nexports.DefaultGraph = DefaultGraph;\nDefaultGraph.INSTANCE = new DefaultGraph();\n//# sourceMappingURL=DefaultGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Literal = void 0;\nconst NamedNode_1 = require(\"./NamedNode\");\n/**\n * A term that represents an RDF literal, containing a string with an optional language tag or datatype.\n */\nclass Literal {\n    constructor(value, languageOrDatatype) {\n        this.termType = 'Literal';\n        this.value = value;\n        if (typeof languageOrDatatype === 'string') {\n            this.language = languageOrDatatype;\n            this.datatype = Literal.RDF_LANGUAGE_STRING;\n        }\n        else if (languageOrDatatype) {\n            this.language = '';\n            this.datatype = languageOrDatatype;\n        }\n        else {\n            this.language = '';\n            this.datatype = Literal.XSD_STRING;\n        }\n    }\n    equals(other) {\n        return !!other && other.termType === 'Literal' && other.value === this.value &&\n            other.language === this.language && this.datatype.equals(other.datatype);\n    }\n}\nexports.Literal = Literal;\nLiteral.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');\nLiteral.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');\n//# sourceMappingURL=Literal.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NamedNode = void 0;\n/**\n * A term that contains an IRI.\n */\nclass NamedNode {\n    constructor(value) {\n        this.termType = 'NamedNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'NamedNode' && other.value === this.value;\n    }\n}\nexports.NamedNode = NamedNode;\n//# sourceMappingURL=NamedNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quad = void 0;\n/**\n * An instance of DefaultGraph represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass Quad {\n    constructor(subject, predicate, object, graph) {\n        this.termType = 'Quad';\n        this.value = '';\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph;\n    }\n    equals(other) {\n        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n        return !!other && (other.termType === 'Quad' || !other.termType) &&\n            this.subject.equals(other.subject) &&\n            this.predicate.equals(other.predicate) &&\n            this.object.equals(other.object) &&\n            this.graph.equals(other.graph);\n    }\n}\nexports.Quad = Quad;\n//# sourceMappingURL=Quad.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\n/**\n * A term that represents a variable.\n */\nclass Variable {\n    constructor(value) {\n        this.termType = 'Variable';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'Variable' && other.value === this.value;\n    }\n}\nexports.Variable = Variable;\n//# sourceMappingURL=Variable.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Resolve\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDotSegmentsOfPath = exports.removeDotSegments = exports.resolve = void 0;\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Validate\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateIri = exports.IriValidationStrategy = void 0;\nfunction buildAbsoluteIriRfc3987Regex() {\n    // The syntax is defined in https://www.rfc-editor.org/rfc/rfc3987#section-2.2\n    // Rules are defined in reversed order\n    const sub_delims_raw = `!$&'()*+,;=`;\n    const sub_delims = `[${sub_delims_raw}]`;\n    const pct_encoded = `%[a-fA-F0-9]{2}`;\n    const dec_octet = '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\n    const ipv4address = `${dec_octet}\\\\.${dec_octet}\\\\.${dec_octet}\\\\.${dec_octet}`;\n    const h16 = `[a-fA-F0-9]{1,4}`;\n    const ls32 = `(${h16}:${h16}|${ipv4address})`;\n    const ipv6address = `((${h16}:){6}${ls32}|::(${h16}:){5}${ls32}|(${h16})?::(${h16}:){4}${ls32}|((${h16}:){0,1}${h16})?::(${h16}:){3}${ls32}|((${h16}:){0,2}${h16})?::(${h16}:){2}${ls32}|((${h16}:){0,3}${h16})?::${h16}:${ls32}|((${h16}:){0,4}${h16})?::${ls32}|((${h16}:){0,5}${h16})?::${h16}|((${h16}:){0,6}${h16})?::)`;\n    const ipvfuture = `v[a-fA-F0-9]+\\\\.(${sub_delims}|${sub_delims}|\":)+`;\n    const ip_literal = `\\\\[(${ipv6address}|${ipvfuture})\\\\]`;\n    const port = `[0-9]*`;\n    const scheme = `[a-zA-Z][a-zA-Z0-9+\\\\-.]*`;\n    const iprivate_raw = `\\u{E000}-\\u{F8FF}\\u{F0000}-\\u{FFFFD}\\u{100000}-\\u{10FFFD}`;\n    const iprivate = `[${iprivate_raw}]`;\n    const ucschar_raw = `\\u{A0}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFEF}\\u{10000}-\\u{1FFFD}\\u{20000}-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}\\u{50000}-\\u{5FFFD}\\u{60000}-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}\\u{90000}-\\u{9FFFD}\\u{A0000}-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}\\u{D0000}-\\u{DFFFD}\\u{E1000}-\\u{EFFFD}`;\n    const iunreserved_raw = `a-zA-Z0-9\\\\-._~${ucschar_raw}`;\n    const iunreserved = `[${iunreserved_raw}]`;\n    const ipchar = `(${iunreserved}|${pct_encoded}|${sub_delims}|[:@])*`;\n    const ifragment = `(${ipchar}|[\\\\/?])*`;\n    const iquery = `(${ipchar}|${iprivate}|[\\\\/?])*`;\n    const isegment_nz = `(${ipchar})+`;\n    const isegment = `(${ipchar})*`;\n    const ipath_empty = '';\n    const ipath_rootless = `${isegment_nz}(\\\\/${isegment})*`;\n    const ipath_absolute = `\\\\/(${isegment_nz}(\\\\/${isegment})*)?`;\n    const ipath_abempty = `(\\\\/${isegment})*`;\n    const ireg_name = `(${iunreserved}|${pct_encoded}|${sub_delims})*`;\n    const ihost = `(${ip_literal}|${ipv4address}|${ireg_name})`;\n    const iuserinfo = `(${iunreserved}|${pct_encoded}|${sub_delims}|:)*`;\n    const iauthority = `(${iuserinfo}@)?${ihost}(:${port})?`;\n    const ihier_part = `(\\\\/\\\\/${iauthority}${ipath_abempty}|${ipath_absolute}|${ipath_rootless}|${ipath_empty})`;\n    const iri = `^${scheme}:${ihier_part}(\\\\?${iquery})?(#${ifragment})?$`;\n    return new RegExp(iri, 'u');\n}\nconst STRICT_IRI_REGEX = buildAbsoluteIriRfc3987Regex();\n// eslint-disable-next-line no-control-regex\nconst PRAGMATIC_IRI_REGEX = /^[A-Za-z][\\d+-.A-Za-z]*:[^\\u0000-\\u0020\"<>\\\\^`{|}]*$/u;\n/**\n * Possible ways of validating an IRI\n */\nvar IriValidationStrategy;\n(function (IriValidationStrategy) {\n    /**\n     * Validates the IRI according to RFC 3987.\n     */\n    IriValidationStrategy[\"Strict\"] = \"strict\";\n    /**\n     * Validates that the IRI has a valid scheme and does not contain any character forbidden by the Turtle specification.\n     */\n    IriValidationStrategy[\"Pragmatic\"] = \"pragmatic\";\n    /**\n     * Does not validate the IRI at all.\n     */\n    IriValidationStrategy[\"None\"] = \"none\";\n})(IriValidationStrategy = exports.IriValidationStrategy || (exports.IriValidationStrategy = {}));\n/**\n * Validate a given IRI according to the given strategy.\n *\n * By default the IRI is fully validated according to RFC 3987.\n * But it is possible to do a lighter a faster validation using the \"pragmatic\" strategy.\n *\n * @param {string} iri a string that may be an IRI.\n * @param {IriValidationStrategy} strategy IRI validation strategy.\n * @return {Error | undefined} An error if the IRI is invalid, or undefined if it is valid.\n */\nfunction validateIri(iri, strategy = IriValidationStrategy.Strict) {\n    switch (strategy) {\n        case IriValidationStrategy.Strict:\n            return STRICT_IRI_REGEX.test(iri) ? undefined : new Error(`Invalid IRI according to RFC 3987: '${iri}'`);\n        case IriValidationStrategy.Pragmatic:\n            return PRAGMATIC_IRI_REGEX.test(iri) ? undefined : new Error(`Invalid IRI according to RDF Turtle: '${iri}'`);\n        case IriValidationStrategy.None:\n            return undefined;\n        default:\n            return new Error(`Not supported validation strategy \"${strategy}\"`);\n    }\n}\nexports.validateIri = validateIri;\n//# sourceMappingURL=Validate.js.map","\"use strict\";\n/**\n * Character classes and associated utilities for the 5th edition of XML 1.0.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\nexports.CHAR = \"\\t\\n\\r -\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\";\nexports.S = \" \\t\\r\\n\";\n// tslint:disable-next-line:max-line-length\nexports.NAME_START_CHAR = \":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NAME_CHAR = \"-\" + exports.NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.CHAR_RE = new RegExp(\"^[\" + exports.CHAR + \"]$\", \"u\");\nexports.S_RE = new RegExp(\"^[\" + exports.S + \"]+$\", \"u\");\nexports.NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"]$\", \"u\");\nexports.NAME_CHAR_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]$\", \"u\");\nexports.NAME_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"][\" + exports.NAME_CHAR + \"]*$\", \"u\");\nexports.NMTOKEN_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]+$\", \"u\");\nvar TAB = 9;\nvar NL = 0xA;\nvar CR = 0xD;\nvar SPACE = 0x20;\n//\n// Lists.\n//\n/** All characters in the ``S`` production. */\nexports.S_LIST = [SPACE, NL, CR, TAB];\n/**\n * Determines whether a codepoint matches the ``CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR``.\n */\nfunction isChar(c) {\n    return (c >= SPACE && c <= 0xD7FF) ||\n        c === NL || c === CR || c === TAB ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isChar = isChar;\n/**\n * Determines whether a codepoint matches the ``S`` (space) production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``S``.\n */\nfunction isS(c) {\n    return c === SPACE || c === NL || c === CR || c === TAB;\n}\nexports.isS = isS;\n/**\n * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.\n */\nfunction isNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        (c >= 0x61 && c <= 0x7A) ||\n        c === 0x3A ||\n        c === 0x5F ||\n        c === 0x200C ||\n        c === 0x200D ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNameStartChar = isNameStartChar;\n/**\n * Determines whether a codepoint matches the ``NAME_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_CHAR``.\n */\nfunction isNameChar(c) {\n    return isNameStartChar(c) ||\n        (c >= 0x30 && c <= 0x39) ||\n        c === 0x2D ||\n        c === 0x2E ||\n        c === 0xB7 ||\n        (c >= 0x0300 && c <= 0x036F) ||\n        (c >= 0x203F && c <= 0x2040);\n}\nexports.isNameChar = isNameChar;\n//# sourceMappingURL=ed5.js.map","\"use strict\";\n/**\n * Character classes and associated utilities for the 2nd edition of XML 1.1.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\nexports.CHAR = \"\\u0001-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\";\nexports.RESTRICTED_CHAR = \"\\u0001-\\u0008\\u000B\\u000C\\u000E-\\u001F\\u007F-\\u0084\\u0086-\\u009F\";\nexports.S = \" \\t\\r\\n\";\n// tslint:disable-next-line:max-line-length\nexports.NAME_START_CHAR = \":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NAME_CHAR = \"-\" + exports.NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.CHAR_RE = new RegExp(\"^[\" + exports.CHAR + \"]$\", \"u\");\nexports.RESTRICTED_CHAR_RE = new RegExp(\"^[\" + exports.RESTRICTED_CHAR + \"]$\", \"u\");\nexports.S_RE = new RegExp(\"^[\" + exports.S + \"]+$\", \"u\");\nexports.NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"]$\", \"u\");\nexports.NAME_CHAR_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]$\", \"u\");\nexports.NAME_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"][\" + exports.NAME_CHAR + \"]*$\", \"u\");\nexports.NMTOKEN_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]+$\", \"u\");\nvar TAB = 9;\nvar NL = 0xA;\nvar CR = 0xD;\nvar SPACE = 0x20;\n//\n// Lists.\n//\n/** All characters in the ``S`` production. */\nexports.S_LIST = [SPACE, NL, CR, TAB];\n/**\n * Determines whether a codepoint matches the ``CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR``.\n */\nfunction isChar(c) {\n    return (c >= 0x0001 && c <= 0xD7FF) ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isChar = isChar;\n/**\n * Determines whether a codepoint matches the ``RESTRICTED_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``RESTRICTED_CHAR``.\n */\nfunction isRestrictedChar(c) {\n    return (c >= 0x1 && c <= 0x8) ||\n        c === 0xB ||\n        c === 0xC ||\n        (c >= 0xE && c <= 0x1F) ||\n        (c >= 0x7F && c <= 0x84) ||\n        (c >= 0x86 && c <= 0x9F);\n}\nexports.isRestrictedChar = isRestrictedChar;\n/**\n * Determines whether a codepoint matches the ``CHAR`` production and does not\n * match the ``RESTRICTED_CHAR`` production. ``isCharAndNotRestricted(x)`` is\n * equivalent to ``isChar(x) && !isRestrictedChar(x)``. This function is faster\n * than running the two-call equivalent.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR`` and does not match\n * ``RESTRICTED_CHAR``.\n */\nfunction isCharAndNotRestricted(c) {\n    return (c === 0x9) ||\n        (c === 0xA) ||\n        (c === 0xD) ||\n        (c > 0x1F && c < 0x7F) ||\n        (c === 0x85) ||\n        (c > 0x9F && c <= 0xD7FF) ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isCharAndNotRestricted = isCharAndNotRestricted;\n/**\n * Determines whether a codepoint matches the ``S`` (space) production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``S``.\n */\nfunction isS(c) {\n    return c === SPACE || c === NL || c === CR || c === TAB;\n}\nexports.isS = isS;\n/**\n * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.\n */\n// tslint:disable-next-line:cyclomatic-complexity\nfunction isNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        (c >= 0x61 && c <= 0x7A) ||\n        c === 0x3A ||\n        c === 0x5F ||\n        c === 0x200C ||\n        c === 0x200D ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNameStartChar = isNameStartChar;\n/**\n * Determines whether a codepoint matches the ``NAME_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_CHAR``.\n */\nfunction isNameChar(c) {\n    return isNameStartChar(c) ||\n        (c >= 0x30 && c <= 0x39) ||\n        c === 0x2D ||\n        c === 0x2E ||\n        c === 0xB7 ||\n        (c >= 0x0300 && c <= 0x036F) ||\n        (c >= 0x203F && c <= 0x2040);\n}\nexports.isNameChar = isNameChar;\n//# sourceMappingURL=ed2.js.map","\"use strict\";\n/**\n * Character class utilities for XML NS 1.0 edition 3.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\n// tslint:disable-next-line:max-line-length\nexports.NC_NAME_START_CHAR = \"A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NC_NAME_CHAR = \"-\" + exports.NC_NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.NC_NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NC_NAME_START_CHAR + \"]$\", \"u\");\nexports.NC_NAME_CHAR_RE = new RegExp(\"^[\" + exports.NC_NAME_CHAR + \"]$\", \"u\");\nexports.NC_NAME_RE = new RegExp(\"^[\" + exports.NC_NAME_START_CHAR + \"][\" + exports.NC_NAME_CHAR + \"]*$\", \"u\");\n/**\n * Determines whether a codepoint matches [[NC_NAME_START_CHAR]].\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches.\n */\n// tslint:disable-next-line:cyclomatic-complexity\nfunction isNCNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        c === 0x5F ||\n        (c >= 0x61 && c <= 0x7A) ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x200C && c <= 0x200D) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNCNameStartChar = isNCNameStartChar;\n/**\n * Determines whether a codepoint matches [[NC_NAME_CHAR]].\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches.\n */\nfunction isNCNameChar(c) {\n    return isNCNameStartChar(c) ||\n        (c === 0x2D ||\n            c === 0x2E ||\n            (c >= 0x30 && c <= 0x39) ||\n            c === 0x00B7 ||\n            (c >= 0x0300 && c <= 0x036F) ||\n            (c >= 0x203F && c <= 0x2040));\n}\nexports.isNCNameChar = isNCNameChar;\n//# sourceMappingURL=ed3.js.map","import { RdfXmlParser } from 'rdfxml-streaming-parser';\nclass CustomRdfXmlParser extends RdfXmlParser {\n    constructor({ factory, ...args } = {}) {\n        super({ ...args, dataFactory: factory });\n    }\n}\nexport default CustomRdfXmlParser;\n"],"names":["Object","defineProperty","exports","value","SaxesParser","EVENTS","ed5","ed2","NSed3","isS","isChar10","isChar","isNameStartChar","isNameChar","S_LIST","NAME_RE","isChar11","isNCNameStartChar","isNCNameChar","NC_NAME_RE","XML_NAMESPACE","XMLNS_NAMESPACE","rootNS","__proto__","xml","xmlns","XML_ENTITIES","amp","gt","lt","quot","apos","EOC","NL_LIKE","S_BEGIN","S_BEGIN_WHITESPACE","S_DOCTYPE","S_DOCTYPE_QUOTE","S_DTD","S_DTD_QUOTED","S_DTD_OPEN_WAKA","S_DTD_OPEN_WAKA_BANG","S_DTD_COMMENT","S_DTD_COMMENT_ENDING","S_DTD_COMMENT_ENDED","S_DTD_PI","S_DTD_PI_ENDING","S_TEXT","S_ENTITY","S_OPEN_WAKA","S_OPEN_WAKA_BANG","S_COMMENT","S_COMMENT_ENDING","S_COMMENT_ENDED","S_CDATA","S_CDATA_ENDING","S_CDATA_ENDING_2","S_PI_FIRST_CHAR","S_PI_REST","S_PI_BODY","S_PI_ENDING","S_XML_DECL_NAME_START","S_XML_DECL_NAME","S_XML_DECL_EQ","S_XML_DECL_VALUE_START","S_XML_DECL_VALUE","S_XML_DECL_SEPARATOR","S_XML_DECL_ENDING","S_OPEN_TAG","S_OPEN_TAG_SLASH","S_ATTRIB","S_ATTRIB_NAME","S_ATTRIB_NAME_SAW_WHITE","S_ATTRIB_VALUE","S_ATTRIB_VALUE_QUOTED","S_ATTRIB_VALUE_CLOSED","S_ATTRIB_VALUE_UNQUOTED","S_CLOSE_TAG","S_CLOSE_TAG_SAW_WHITE","TAB","NL","CR","SPACE","BANG","DQUOTE","AMP","SQUOTE","MINUS","FORWARD_SLASH","SEMICOLON","LESS","EQUAL","GREATER","QUESTION","OPEN_BRACKET","CLOSE_BRACKET","NEL","LS","isQuote","c","QUOTES","DOCTYPE_TERMINATOR","DTD_TERMINATOR","XML_DECL_NAME_TERMINATOR","ATTRIB_VALUE_UNQUOTED_TERMINATOR","nsPairCheck","parser","prefix","uri","fail","nsMappingCheck","mapping","local","keys","isNCName","name","test","isName","FORBIDDEN_START","FORBIDDEN_BRACKET","FORBIDDEN_BRACKET_BRACKET","EVENT_NAME_TO_HANDLER_NAME","xmldecl","text","processinginstruction","doctype","comment","opentagstart","attribute","opentag","closetag","cdata","error","end","ready","closed","this","_closed","constructor","opt","fragmentOpt","fragment","xmlnsOpt","trackPosition","position","fileName","nameStartCheck","nameCheck","processAttribs","processAttribsNS","pushAttrib","pushAttribNS","ns","assign","additional","additionalNamespaces","processAttribsPlain","pushAttribPlain","stateTable","sBegin","sBeginWhitespace","sDoctype","sDoctypeQuote","sDTD","sDTDQuoted","sDTDOpenWaka","sDTDOpenWakaBang","sDTDComment","sDTDCommentEnding","sDTDCommentEnded","sDTDPI","sDTDPIEnding","sText","sEntity","sOpenWaka","sOpenWakaBang","sComment","sCommentEnding","sCommentEnded","sCData","sCDataEnding","sCDataEnding2","sPIFirstChar","sPIRest","sPIBody","sPIEnding","sXMLDeclNameStart","sXMLDeclName","sXMLDeclEq","sXMLDeclValueStart","sXMLDeclValue","sXMLDeclSeparator","sXMLDeclEnding","sOpenTag","sOpenTagSlash","sAttrib","sAttribName","sAttribNameSawWhite","sAttribValue","sAttribValueQuoted","sAttribValueClosed","sAttribValueUnquoted","sCloseTag","sCloseTagSawWhite","_init","_a","openWakaBang","piTarget","entity","q","tags","tag","topNS","chunk","chunkPosition","i","prevI","carriedFromPrevious","undefined","forbiddenState","attribList","state","reportedTextBeforeRoot","reportedTextAfterRoot","closedRoot","sawRoot","xmlDeclPossible","xmlDeclExpects","entityReturnState","defaultXMLVersion","forceXMLVersion","Error","setXMLVersion","positionAtNewLine","xmlDecl","version","encoding","standalone","line","column","ENTITIES","create","readyHandler","call","columnIndex","on","handler","off","makeError","message","msg","length","err","errorHandler","write","toString","limit","lastCode","charCodeAt","slice","close","getCode10","code","final","getCode11","next","getCodeNorm","getCode","unget","captureTo","chars","start","isNLLike","includes","captureToChar","char","captureNameChars","skipSpaces","currentXMLVersion","iBefore","doctypeHandler","String","fromCodePoint","owb","handleTextInRoot","handleTextOutsideRoot","loop","parsed","parseEntity","textHandler","commentHandler","cdataHandler","isQuestion","toLowerCase","piHandler","target","body","join","xmldeclHandler","attributes","openTagStartHandler","openTag","openSelfClosingTag","closeTag","scanLoop","nonSpace","outRootLoop","qname","attr","push","attributeHandler","trimmed","trim","_b","pop","endHandler","resolve","index","resolvePrefix","colon","indexOf","JSON","stringify","seen","Set","eqname","has","add","isSelfClosing","openTagHandler","_c","closeTagHandler","top","l","defined","num","NaN","parseInt","__createBinding","o","m","k","k2","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","__exportStar","p","prototype","hasOwnProperty","ParseError","saxParser","super","ParseType","RdfXmlParser","relative_to_absolute_iri_1","saxes_1","readable_stream_1","ParseError_1","rdf_data_factory_1","validate_iri_1","Transform","args","readableObjectMode","activeTagStack","nodeIds","options","dataFactory","DataFactory","baseIRI","defaultGraph","validateUri","iriValidationStrategy","IriValidationStrategy","Pragmatic","None","attachSaxListeners","import","stream","output","PassThrough","emit","data","pipe","_transform","callback","e","newParseError","valueToUri","activeTag","uriToNamedNode","uriValidationResult","validateIri","namedNode","validateNcname","NCNAME_MATCHER","onTag","bind","onText","onCloseTag","onDoctype","parentTag","currentParseType","RESOURCE","hadChildren","childrenParseType","childrenStringTags","tagName","attributeKey","tagContents","tagString","stringActiveTag","childrenStringEmitClosingTag","language","onTagResource","onTagProperty","rootTag","PROPERTY","typedNode","RDF","FORBIDDEN_NODE_ELEMENTS","predicates","objects","activeSubjectValue","claimSubjectNodeId","subjectValueBlank","explicitType","XML","subject","blankNode","claimNodeId","type","emitTriple","reifiedStatementId","predicate","childrenCollectionSubject","linkTerm","childrenCollectionPredicate","predicateSubPredicates","predicateSubObjects","predicateEmitted","object","literal","datatype","listItemCounter","FORBIDDEN_PROPERTY_ELEMENTS","parseType","attributedProperty","activeSubSubjectValue","subSubjectValueBlank","propertyAttributeKey","propertyAttribute","nestedBNode","childrenTagsToString","subjectParent","statementId","quad","term","allowDuplicateRdfIds","poppedTag","replace","match","MIME_TYPE","BlankNode","termType","equals","other","BlankNode_1","DefaultGraph_1","Literal_1","NamedNode_1","Quad_1","Variable_1","dataFactoryCounter","blankNodeCounter","blankNodePrefix","NamedNode","languageOrDatatype","Literal","variable","Variable","DefaultGraph","INSTANCE","graph","Quad","fromTerm","original","XSD_STRING","fromQuad","resetBlankNodeCounter","RDF_LANGUAGE_STRING","relativeIRI","baseFragmentPos","substr","startsWith","baseQueryPos","relativeColonPos","removeDotSegmentsOfPath","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","removeDotSegments","baseIRIPath","baseIRILastSlashPos","lastIndexOf","path","segmentBuffers","isCharacterAllowedAfterRelativePathSegment","map","buffer","iri","colonPosition","searchOffset","pathSeparator","base","character","buildAbsoluteIriRfc3987Regex","sub_delims_raw","sub_delims","pct_encoded","dec_octet","ipv4address","h16","ls32","ipv6address","ipvfuture","ip_literal","port","scheme","iprivate_raw","iprivate","ucschar_raw","iunreserved_raw","iunreserved","ipchar","ifragment","iquery","isegment_nz","isegment","ipath_empty","ipath_rootless","ipath_absolute","ipath_abempty","ireg_name","ihost","iuserinfo","iauthority","ihier_part","RegExp","STRICT_IRI_REGEX","PRAGMATIC_IRI_REGEX","strategy","Strict","CHAR","S","NAME_START_CHAR","NAME_CHAR","CHAR_RE","S_RE","NAME_START_CHAR_RE","NAME_CHAR_RE","NMTOKEN_RE","RESTRICTED_CHAR","RESTRICTED_CHAR_RE","isRestrictedChar","isCharAndNotRestricted","NC_NAME_START_CHAR","NC_NAME_CHAR","NC_NAME_START_CHAR_RE","NC_NAME_CHAR_RE","CustomRdfXmlParser","factory"],"sourceRoot":""}