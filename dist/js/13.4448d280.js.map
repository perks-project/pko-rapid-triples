{"version":3,"file":"js/13.4448d280.js","mappings":"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","sources":["webpack://pko-rapid-triples/./node_modules/@zazuko/formats-lazy/lib/CustomRdfXmlParser.js","webpack://pko-rapid-triples/./node_modules/validate-iri/index.js","webpack://pko-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/index.js","webpack://pko-rapid-triples/./node_modules/relative-to-absolute-iri/lib/Resolve.js","webpack://pko-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/lib/ParseError.js","webpack://pko-rapid-triples/./node_modules/xmlchars/xml/1.0/ed5.js","webpack://pko-rapid-triples/./node_modules/validate-iri/lib/Validate.js","webpack://pko-rapid-triples/./node_modules/rdf-data-factory/lib/Quad.js","webpack://pko-rapid-triples/./node_modules/rdf-data-factory/lib/NamedNode.js","webpack://pko-rapid-triples/./node_modules/rdf-data-factory/index.js","webpack://pko-rapid-triples/./node_modules/rdf-data-factory/lib/BlankNode.js","webpack://pko-rapid-triples/./node_modules/@rubensworks/saxes/saxes.js","webpack://pko-rapid-triples/./node_modules/xmlchars/xmlns/1.0/ed3.js","webpack://pko-rapid-triples/./node_modules/rdf-data-factory/lib/Literal.js","webpack://pko-rapid-triples/./node_modules/relative-to-absolute-iri/index.js","webpack://pko-rapid-triples/./node_modules/xmlchars/xml/1.1/ed2.js","webpack://pko-rapid-triples/./node_modules/rdf-data-factory/lib/Variable.js","webpack://pko-rapid-triples/./node_modules/rdf-data-factory/lib/DataFactory.js","webpack://pko-rapid-triples/./node_modules/rdf-data-factory/lib/DefaultGraph.js","webpack://pko-rapid-triples/./node_modules/@zazuko/formats-lazy/node_modules/rdfxml-streaming-parser/lib/RdfXmlParser.js"],"sourcesContent":["import { RdfXmlParser } from 'rdfxml-streaming-parser';\nclass CustomRdfXmlParser extends RdfXmlParser {\n    constructor({ factory, ...args } = {}) {\n        super({ ...args, dataFactory: factory });\n    }\n}\nexport default CustomRdfXmlParser;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Validate\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/RdfXmlParser\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDotSegmentsOfPath = exports.removeDotSegments = exports.resolve = void 0;\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParseError = void 0;\n/**\n * An error that includes line and column in the error message.\n */\nclass ParseError extends Error {\n    constructor(parser, message) {\n        const saxParser = parser.saxParser;\n        super(parser.trackPosition ? `Line ${saxParser.line} column ${saxParser.column + 1}: ${message}` : message);\n    }\n}\nexports.ParseError = ParseError;\n//# sourceMappingURL=ParseError.js.map","\"use strict\";\n/**\n * Character classes and associated utilities for the 5th edition of XML 1.0.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\nexports.CHAR = \"\\t\\n\\r -\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\";\nexports.S = \" \\t\\r\\n\";\n// tslint:disable-next-line:max-line-length\nexports.NAME_START_CHAR = \":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NAME_CHAR = \"-\" + exports.NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.CHAR_RE = new RegExp(\"^[\" + exports.CHAR + \"]$\", \"u\");\nexports.S_RE = new RegExp(\"^[\" + exports.S + \"]+$\", \"u\");\nexports.NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"]$\", \"u\");\nexports.NAME_CHAR_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]$\", \"u\");\nexports.NAME_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"][\" + exports.NAME_CHAR + \"]*$\", \"u\");\nexports.NMTOKEN_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]+$\", \"u\");\nvar TAB = 9;\nvar NL = 0xA;\nvar CR = 0xD;\nvar SPACE = 0x20;\n//\n// Lists.\n//\n/** All characters in the ``S`` production. */\nexports.S_LIST = [SPACE, NL, CR, TAB];\n/**\n * Determines whether a codepoint matches the ``CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR``.\n */\nfunction isChar(c) {\n    return (c >= SPACE && c <= 0xD7FF) ||\n        c === NL || c === CR || c === TAB ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isChar = isChar;\n/**\n * Determines whether a codepoint matches the ``S`` (space) production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``S``.\n */\nfunction isS(c) {\n    return c === SPACE || c === NL || c === CR || c === TAB;\n}\nexports.isS = isS;\n/**\n * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.\n */\nfunction isNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        (c >= 0x61 && c <= 0x7A) ||\n        c === 0x3A ||\n        c === 0x5F ||\n        c === 0x200C ||\n        c === 0x200D ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNameStartChar = isNameStartChar;\n/**\n * Determines whether a codepoint matches the ``NAME_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_CHAR``.\n */\nfunction isNameChar(c) {\n    return isNameStartChar(c) ||\n        (c >= 0x30 && c <= 0x39) ||\n        c === 0x2D ||\n        c === 0x2E ||\n        c === 0xB7 ||\n        (c >= 0x0300 && c <= 0x036F) ||\n        (c >= 0x203F && c <= 0x2040);\n}\nexports.isNameChar = isNameChar;\n//# sourceMappingURL=ed5.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateIri = exports.IriValidationStrategy = void 0;\nfunction buildAbsoluteIriRfc3987Regex() {\n    // The syntax is defined in https://www.rfc-editor.org/rfc/rfc3987#section-2.2\n    // Rules are defined in reversed order\n    const sub_delims_raw = `!$&'()*+,;=`;\n    const sub_delims = `[${sub_delims_raw}]`;\n    const pct_encoded = `%[a-fA-F0-9]{2}`;\n    const dec_octet = '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\n    const ipv4address = `${dec_octet}\\\\.${dec_octet}\\\\.${dec_octet}\\\\.${dec_octet}`;\n    const h16 = `[a-fA-F0-9]{1,4}`;\n    const ls32 = `(${h16}:${h16}|${ipv4address})`;\n    const ipv6address = `((${h16}:){6}${ls32}|::(${h16}:){5}${ls32}|(${h16})?::(${h16}:){4}${ls32}|((${h16}:){0,1}${h16})?::(${h16}:){3}${ls32}|((${h16}:){0,2}${h16})?::(${h16}:){2}${ls32}|((${h16}:){0,3}${h16})?::${h16}:${ls32}|((${h16}:){0,4}${h16})?::${ls32}|((${h16}:){0,5}${h16})?::${h16}|((${h16}:){0,6}${h16})?::)`;\n    const ipvfuture = `v[a-fA-F0-9]+\\\\.(${sub_delims}|${sub_delims}|\":)+`;\n    const ip_literal = `\\\\[(${ipv6address}|${ipvfuture})\\\\]`;\n    const port = `[0-9]*`;\n    const scheme = `[a-zA-Z][a-zA-Z0-9+\\\\-.]*`;\n    const iprivate_raw = `\\u{E000}-\\u{F8FF}\\u{F0000}-\\u{FFFFD}\\u{100000}-\\u{10FFFD}`;\n    const iprivate = `[${iprivate_raw}]`;\n    const ucschar_raw = `\\u{A0}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFEF}\\u{10000}-\\u{1FFFD}\\u{20000}-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}\\u{50000}-\\u{5FFFD}\\u{60000}-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}\\u{90000}-\\u{9FFFD}\\u{A0000}-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}\\u{D0000}-\\u{DFFFD}\\u{E1000}-\\u{EFFFD}`;\n    const iunreserved_raw = `a-zA-Z0-9\\\\-._~${ucschar_raw}`;\n    const iunreserved = `[${iunreserved_raw}]`;\n    const ipchar = `(${iunreserved}|${pct_encoded}|${sub_delims}|[:@])*`;\n    const ifragment = `(${ipchar}|[\\\\/?])*`;\n    const iquery = `(${ipchar}|${iprivate}|[\\\\/?])*`;\n    const isegment_nz = `(${ipchar})+`;\n    const isegment = `(${ipchar})*`;\n    const ipath_empty = '';\n    const ipath_rootless = `${isegment_nz}(\\\\/${isegment})*`;\n    const ipath_absolute = `\\\\/(${isegment_nz}(\\\\/${isegment})*)?`;\n    const ipath_abempty = `(\\\\/${isegment})*`;\n    const ireg_name = `(${iunreserved}|${pct_encoded}|${sub_delims})*`;\n    const ihost = `(${ip_literal}|${ipv4address}|${ireg_name})`;\n    const iuserinfo = `(${iunreserved}|${pct_encoded}|${sub_delims}|:)*`;\n    const iauthority = `(${iuserinfo}@)?${ihost}(:${port})?`;\n    const ihier_part = `(\\\\/\\\\/${iauthority}${ipath_abempty}|${ipath_absolute}|${ipath_rootless}|${ipath_empty})`;\n    const iri = `^${scheme}:${ihier_part}(\\\\?${iquery})?(#${ifragment})?$`;\n    return new RegExp(iri, 'u');\n}\nconst STRICT_IRI_REGEX = buildAbsoluteIriRfc3987Regex();\n// eslint-disable-next-line no-control-regex\nconst PRAGMATIC_IRI_REGEX = /^[A-Za-z][\\d+-.A-Za-z]*:[^\\u0000-\\u0020\"<>\\\\^`{|}]*$/u;\n/**\n * Possible ways of validating an IRI\n */\nvar IriValidationStrategy;\n(function (IriValidationStrategy) {\n    /**\n     * Validates the IRI according to RFC 3987.\n     */\n    IriValidationStrategy[\"Strict\"] = \"strict\";\n    /**\n     * Validates that the IRI has a valid scheme and does not contain any character forbidden by the Turtle specification.\n     */\n    IriValidationStrategy[\"Pragmatic\"] = \"pragmatic\";\n    /**\n     * Does not validate the IRI at all.\n     */\n    IriValidationStrategy[\"None\"] = \"none\";\n})(IriValidationStrategy = exports.IriValidationStrategy || (exports.IriValidationStrategy = {}));\n/**\n * Validate a given IRI according to the given strategy.\n *\n * By default the IRI is fully validated according to RFC 3987.\n * But it is possible to do a lighter a faster validation using the \"pragmatic\" strategy.\n *\n * @param {string} iri a string that may be an IRI.\n * @param {IriValidationStrategy} strategy IRI validation strategy.\n * @return {Error | undefined} An error if the IRI is invalid, or undefined if it is valid.\n */\nfunction validateIri(iri, strategy = IriValidationStrategy.Strict) {\n    switch (strategy) {\n        case IriValidationStrategy.Strict:\n            return STRICT_IRI_REGEX.test(iri) ? undefined : new Error(`Invalid IRI according to RFC 3987: '${iri}'`);\n        case IriValidationStrategy.Pragmatic:\n            return PRAGMATIC_IRI_REGEX.test(iri) ? undefined : new Error(`Invalid IRI according to RDF Turtle: '${iri}'`);\n        case IriValidationStrategy.None:\n            return undefined;\n        default:\n            return new Error(`Not supported validation strategy \"${strategy}\"`);\n    }\n}\nexports.validateIri = validateIri;\n//# sourceMappingURL=Validate.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quad = void 0;\n/**\n * An instance of DefaultGraph represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass Quad {\n    constructor(subject, predicate, object, graph) {\n        this.termType = 'Quad';\n        this.value = '';\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph;\n    }\n    equals(other) {\n        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n        return !!other && (other.termType === 'Quad' || !other.termType) &&\n            this.subject.equals(other.subject) &&\n            this.predicate.equals(other.predicate) &&\n            this.object.equals(other.object) &&\n            this.graph.equals(other.graph);\n    }\n}\nexports.Quad = Quad;\n//# sourceMappingURL=Quad.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NamedNode = void 0;\n/**\n * A term that contains an IRI.\n */\nclass NamedNode {\n    constructor(value) {\n        this.termType = 'NamedNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'NamedNode' && other.value === this.value;\n    }\n}\nexports.NamedNode = NamedNode;\n//# sourceMappingURL=NamedNode.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/BlankNode\"), exports);\n__exportStar(require(\"./lib/DataFactory\"), exports);\n__exportStar(require(\"./lib/DefaultGraph\"), exports);\n__exportStar(require(\"./lib/Literal\"), exports);\n__exportStar(require(\"./lib/NamedNode\"), exports);\n__exportStar(require(\"./lib/Quad\"), exports);\n__exportStar(require(\"./lib/Variable\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlankNode = void 0;\n/**\n * A term that represents an RDF blank node with a label.\n */\nclass BlankNode {\n    constructor(value) {\n        this.termType = 'BlankNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'BlankNode' && other.value === this.value;\n    }\n}\nexports.BlankNode = BlankNode;\n//# sourceMappingURL=BlankNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SaxesParser = exports.EVENTS = void 0;\nconst ed5 = require(\"xmlchars/xml/1.0/ed5\");\nconst ed2 = require(\"xmlchars/xml/1.1/ed2\");\nconst NSed3 = require(\"xmlchars/xmlns/1.0/ed3\");\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n    __proto__: null,\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE,\n};\nconst XML_ENTITIES = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n    __proto__: null,\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: \"\\\"\",\n    apos: \"'\",\n};\n// EOC: end-of-chunk\nconst EOC = -1;\nconst NL_LIKE = -2;\nconst S_BEGIN = 0; // Initial state.\nconst S_BEGIN_WHITESPACE = 1; // leading whitespace\nconst S_DOCTYPE = 2; // <!DOCTYPE\nconst S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\nconst S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\nconst S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\nconst S_DTD_OPEN_WAKA = 6;\nconst S_DTD_OPEN_WAKA_BANG = 7;\nconst S_DTD_COMMENT = 8; // <!--\nconst S_DTD_COMMENT_ENDING = 9; // <!-- blah -\nconst S_DTD_COMMENT_ENDED = 10; // <!-- blah --\nconst S_DTD_PI = 11; // <?\nconst S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\nconst S_TEXT = 13; // general stuff\nconst S_ENTITY = 14; // &amp and such\nconst S_OPEN_WAKA = 15; // <\nconst S_OPEN_WAKA_BANG = 16; // <!...\nconst S_COMMENT = 17; // <!--\nconst S_COMMENT_ENDING = 18; // <!-- blah -\nconst S_COMMENT_ENDED = 19; // <!-- blah --\nconst S_CDATA = 20; // <![CDATA[ something\nconst S_CDATA_ENDING = 21; // ]\nconst S_CDATA_ENDING_2 = 22; // ]]\nconst S_PI_FIRST_CHAR = 23; // <?hi, first char\nconst S_PI_REST = 24; // <?hi, rest of the name\nconst S_PI_BODY = 25; // <?hi there\nconst S_PI_ENDING = 26; // <?hi \"there\" ?\nconst S_XML_DECL_NAME_START = 27; // <?xml\nconst S_XML_DECL_NAME = 28; // <?xml foo\nconst S_XML_DECL_EQ = 29; // <?xml foo=\nconst S_XML_DECL_VALUE_START = 30; // <?xml foo=\nconst S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\nconst S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\nconst S_XML_DECL_ENDING = 33; // <?xml ... ?\nconst S_OPEN_TAG = 34; // <strong\nconst S_OPEN_TAG_SLASH = 35; // <strong /\nconst S_ATTRIB = 36; // <a\nconst S_ATTRIB_NAME = 37; // <a foo\nconst S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\nconst S_ATTRIB_VALUE = 39; // <a foo=\nconst S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\nconst S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\nconst S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\nconst S_CLOSE_TAG = 43; // </a\nconst S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\nconst TAB = 9;\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\nconst NEL = 0x85;\nconst LS = 0x2028; // Line Separator\nconst isQuote = (c) => c === DQUOTE || c === SQUOTE;\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\nfunction nsPairCheck(parser, prefix, uri) {\n    switch (prefix) {\n        case \"xml\":\n            if (uri !== XML_NAMESPACE) {\n                parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n            }\n            break;\n        case \"xmlns\":\n            if (uri !== XMLNS_NAMESPACE) {\n                parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n            }\n            break;\n        default:\n    }\n    switch (uri) {\n        case XMLNS_NAMESPACE:\n            parser.fail(prefix === \"\" ?\n                `the default namespace may not be set to ${uri}.` :\n                `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n            break;\n        case XML_NAMESPACE:\n            switch (prefix) {\n                case \"xml\":\n                    // Assinging the XML namespace to \"xml\" is fine.\n                    break;\n                case \"\":\n                    parser.fail(`the default namespace may not be set to ${uri}.`);\n                    break;\n                default:\n                    parser.fail(\"may not assign the xml namespace to another prefix.\");\n            }\n            break;\n        default:\n    }\n}\nfunction nsMappingCheck(parser, mapping) {\n    for (const local of Object.keys(mapping)) {\n        nsPairCheck(parser, local, mapping[local]);\n    }\n}\nconst isNCName = (name) => NC_NAME_RE.test(name);\nconst isName = (name) => NAME_RE.test(name);\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * The list of supported events.\n */\nexports.EVENTS = [\n    \"xmldecl\",\n    \"text\",\n    \"processinginstruction\",\n    \"doctype\",\n    \"comment\",\n    \"opentagstart\",\n    \"attribute\",\n    \"opentag\",\n    \"closetag\",\n    \"cdata\",\n    \"error\",\n    \"end\",\n    \"ready\",\n];\nconst EVENT_NAME_TO_HANDLER_NAME = {\n    xmldecl: \"xmldeclHandler\",\n    text: \"textHandler\",\n    processinginstruction: \"piHandler\",\n    doctype: \"doctypeHandler\",\n    comment: \"commentHandler\",\n    opentagstart: \"openTagStartHandler\",\n    attribute: \"attributeHandler\",\n    opentag: \"openTagHandler\",\n    closetag: \"closeTagHandler\",\n    cdata: \"cdataHandler\",\n    error: \"errorHandler\",\n    end: \"endHandler\",\n    ready: \"readyHandler\",\n};\n// eslint-disable-next-line @typescript-eslint/ban-types\nclass SaxesParser {\n    /**\n     * Indicates whether or not the parser is closed. If ``true``, wait for\n     * the ``ready`` event to write again.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * @param opt The parser options.\n     */\n    constructor(opt) {\n        this.opt = opt !== null && opt !== void 0 ? opt : {};\n        this.fragmentOpt = !!this.opt.fragment;\n        const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n        this.trackPosition = this.opt.position !== false;\n        this.fileName = this.opt.fileName;\n        if (xmlnsOpt) {\n            // This is the function we use to perform name checks on PIs and entities.\n            // When namespaces are used, colons are not allowed in PI target names or\n            // entity names. So the check depends on whether namespaces are used. See:\n            //\n            // https://www.w3.org/XML/xml-names-19990114-errata.html\n            // NE08\n            //\n            this.nameStartCheck = isNCNameStartChar;\n            this.nameCheck = isNCNameChar;\n            this.isName = isNCName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsNS;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribNS;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n            this.ns = Object.assign({ __proto__: null }, rootNS);\n            const additional = this.opt.additionalNamespaces;\n            if (additional != null) {\n                nsMappingCheck(this, additional);\n                Object.assign(this.ns, additional);\n            }\n        }\n        else {\n            this.nameStartCheck = isNameStartChar;\n            this.nameCheck = isNameChar;\n            this.isName = isName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsPlain;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribPlain;\n        }\n        //\n        // The order of the members in this table needs to correspond to the state\n        // numbers given to the states that correspond to the methods being recorded\n        // here.\n        //\n        this.stateTable = [\n            /* eslint-disable @typescript-eslint/unbound-method */\n            this.sBegin,\n            this.sBeginWhitespace,\n            this.sDoctype,\n            this.sDoctypeQuote,\n            this.sDTD,\n            this.sDTDQuoted,\n            this.sDTDOpenWaka,\n            this.sDTDOpenWakaBang,\n            this.sDTDComment,\n            this.sDTDCommentEnding,\n            this.sDTDCommentEnded,\n            this.sDTDPI,\n            this.sDTDPIEnding,\n            this.sText,\n            this.sEntity,\n            this.sOpenWaka,\n            this.sOpenWakaBang,\n            this.sComment,\n            this.sCommentEnding,\n            this.sCommentEnded,\n            this.sCData,\n            this.sCDataEnding,\n            this.sCDataEnding2,\n            this.sPIFirstChar,\n            this.sPIRest,\n            this.sPIBody,\n            this.sPIEnding,\n            this.sXMLDeclNameStart,\n            this.sXMLDeclName,\n            this.sXMLDeclEq,\n            this.sXMLDeclValueStart,\n            this.sXMLDeclValue,\n            this.sXMLDeclSeparator,\n            this.sXMLDeclEnding,\n            this.sOpenTag,\n            this.sOpenTagSlash,\n            this.sAttrib,\n            this.sAttribName,\n            this.sAttribNameSawWhite,\n            this.sAttribValue,\n            this.sAttribValueQuoted,\n            this.sAttribValueClosed,\n            this.sAttribValueUnquoted,\n            this.sCloseTag,\n            this.sCloseTagSawWhite,\n            /* eslint-enable @typescript-eslint/unbound-method */\n        ];\n        this._init();\n    }\n    _init() {\n        var _a;\n        this.openWakaBang = \"\";\n        this.text = \"\";\n        this.name = \"\";\n        this.piTarget = \"\";\n        this.entity = \"\";\n        this.q = null;\n        this.tags = [];\n        this.tag = null;\n        this.topNS = null;\n        this.chunk = \"\";\n        this.chunkPosition = 0;\n        this.i = 0;\n        this.prevI = 0;\n        this.carriedFromPrevious = undefined;\n        this.forbiddenState = FORBIDDEN_START;\n        this.attribList = [];\n        // The logic is organized so as to minimize the need to check\n        // this.opt.fragment while parsing.\n        const { fragmentOpt } = this;\n        this.state = fragmentOpt ? S_TEXT : S_BEGIN;\n        // We want these to be all true if we are dealing with a fragment.\n        this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot =\n            this.sawRoot = fragmentOpt;\n        // An XML declaration is intially possible only when parsing whole\n        // documents.\n        this.xmlDeclPossible = !fragmentOpt;\n        this.xmlDeclExpects = [\"version\"];\n        this.entityReturnState = undefined;\n        let { defaultXMLVersion } = this.opt;\n        if (defaultXMLVersion === undefined) {\n            if (this.opt.forceXMLVersion === true) {\n                throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n            }\n            defaultXMLVersion = \"1.0\";\n        }\n        this.setXMLVersion(defaultXMLVersion);\n        this.positionAtNewLine = 0;\n        this.doctype = false;\n        this._closed = false;\n        this.xmlDecl = {\n            version: undefined,\n            encoding: undefined,\n            standalone: undefined,\n        };\n        this.line = 1;\n        this.column = 0;\n        this.ENTITIES = Object.create(XML_ENTITIES);\n        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    /**\n     * The stream position the parser is currently looking at. This field is\n     * zero-based.\n     *\n     * This field is not based on counting Unicode characters but is to be\n     * interpreted as a plain index into a JavaScript string.\n     */\n    get position() {\n        return this.chunkPosition + this.i;\n    }\n    /**\n     * The column number of the next character to be read by the parser.  *\n     * This field is zero-based. (The first column in a line is 0.)\n     *\n     * This field reports the index at which the next character would be in the\n     * line if the line were represented as a JavaScript string.  Note that this\n     * *can* be different to a count based on the number of *Unicode characters*\n     * due to how JavaScript handles astral plane characters.\n     *\n     * See [[column]] for a number that corresponds to a count of Unicode\n     * characters.\n     */\n    get columnIndex() {\n        return this.position - this.positionAtNewLine;\n    }\n    /**\n     * Set an event listener on an event. The parser supports one handler per\n     * event type. If you try to set an event handler over an existing handler,\n     * the old handler is silently overwritten.\n     *\n     * @param name The event to listen to.\n     *\n     * @param handler The handler to set.\n     */\n    on(name, handler) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n    }\n    /**\n     * Unset an event handler.\n     *\n     * @parma name The event to stop listening to.\n     */\n    off(name) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n    }\n    /**\n     * Make an error object. The error object will have a message that contains\n     * the ``fileName`` option passed at the creation of the parser. If position\n     * tracking was turned on, it will also have line and column number\n     * information.\n     *\n     * @param message The message describing the error to report.\n     *\n     * @returns An error object with a properly formatted message.\n     */\n    makeError(message) {\n        var _a;\n        let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n        if (this.trackPosition) {\n            if (msg.length > 0) {\n                msg += \":\";\n            }\n            msg += `${this.line}:${this.column}`;\n        }\n        if (msg.length > 0) {\n            msg += \": \";\n        }\n        return new Error(msg + message);\n    }\n    /**\n     * Report a parsing error. This method is made public so that client code may\n     * check for issues that are outside the scope of this project and can report\n     * errors.\n     *\n     * @param message The error to report.\n     *\n     * @returns this\n     */\n    fail(message) {\n        const err = this.makeError(message);\n        const handler = this.errorHandler;\n        if (handler === undefined) {\n            throw err;\n        }\n        else {\n            handler(err);\n        }\n        return this;\n    }\n    /**\n     * Write a XML data to the parser.\n     *\n     * @param chunk The XML data to write.\n     *\n     * @returns this\n     */\n    // We do need object for the type here. Yes, it often causes problems\n    // but not in this case.\n    write(chunk) {\n        if (this.closed) {\n            return this.fail(\"cannot write after close; assign an onready handler.\");\n        }\n        let end = false;\n        if (chunk === null) {\n            // We cannot return immediately because carriedFromPrevious may need\n            // processing.\n            end = true;\n            chunk = \"\";\n        }\n        else if (typeof chunk === \"object\") {\n            chunk = chunk.toString();\n        }\n        // We checked if performing a pre-decomposition of the string into an array\n        // of single complete characters (``Array.from(chunk)``) would be faster\n        // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n        // isn't. (There may be Node-specific code that would perform faster than\n        // ``Array.from`` but don't want to be dependent on Node.)\n        if (this.carriedFromPrevious !== undefined) {\n            // The previous chunk had char we must carry over.\n            chunk = `${this.carriedFromPrevious}${chunk}`;\n            this.carriedFromPrevious = undefined;\n        }\n        let limit = chunk.length;\n        const lastCode = chunk.charCodeAt(limit - 1);\n        if (!end &&\n            // A trailing CR or surrogate must be carried over to the next\n            // chunk.\n            (lastCode === CR || (lastCode >= 0xD800 && lastCode <= 0xDBFF))) {\n            // The chunk ends with a character that must be carried over. We cannot\n            // know how to handle it until we get the next chunk or the end of the\n            // stream. So save it for later.\n            this.carriedFromPrevious = chunk[limit - 1];\n            limit--;\n            chunk = chunk.slice(0, limit);\n        }\n        const { stateTable } = this;\n        this.chunk = chunk;\n        this.i = 0;\n        while (this.i < limit) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument\n            stateTable[this.state].call(this);\n        }\n        this.chunkPosition += limit;\n        return end ? this.end() : this;\n    }\n    /**\n     * Close the current stream. Perform final well-formedness checks and reset\n     * the parser tstate.\n     *\n     * @returns this\n     */\n    close() {\n        return this.write(null);\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.0.\n     *\n     * @returns The character read.\n     */\n    getCode10() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if (code >= SPACE || code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL:\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR:\n                    // We may get NaN if we read past the end of the chunk, which is fine.\n                    if (chunk.charCodeAt(i + 1) === NL) {\n                        // A \\r\\n sequence is converted to \\n so we have to skip over the\n                        // next character. We already know it has a size of 1 so ++ is fine\n                        // here.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n                    // ahead.\n                    // In either case, \\r becomes \\n.\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    // If we get here, then code < SPACE and it is not NL CR or TAB.\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isChar10 that takes into account\n            // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n            // test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isChar10 that takes into account that in\n        // this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.1.\n     *\n     * @returns {number} The character read.\n     */\n    getCode11() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if ((code > 0x1F && code < 0x7F) || (code > 0x9F && code !== LS) ||\n                code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL: // 0xA\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR: { // 0xD\n                    // We may get NaN if we read past the end of the chunk, which is\n                    // fine.\n                    const next = chunk.charCodeAt(i + 1);\n                    if (next === NL || next === NEL) {\n                        // A CR NL or CR NEL sequence is converted to NL so we have to skip\n                        // over the next character. We already know it has a size of 1.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a CR is just converted to NL, no skip.\n                }\n                /* yes, fall through */\n                case NEL: // 0x85\n                case LS: // Ox2028\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isCharAndNotRestricted that takes into\n            // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n            // does not test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isCharAndNotRestricted that takes into\n        // account that in this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Like ``getCode`` but with the return value normalized so that ``NL`` is\n     * returned for ``NL_LIKE``.\n     */\n    getCodeNorm() {\n        const c = this.getCode();\n        return c === NL_LIKE ? NL : c;\n    }\n    unget() {\n        this.i = this.prevI;\n        this.column--;\n    }\n    /**\n     * Capture characters into a buffer until encountering one of a set of\n     * characters.\n     *\n     * @param chars An array of codepoints. Encountering a character in the array\n     * ends the capture. (``chars`` may safely contain ``NL``.)\n     *\n     * @return The character code that made the capture end, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureTo(chars) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            const isNLLike = c === NL_LIKE;\n            const final = isNLLike ? NL : c;\n            if (final === EOC || chars.includes(final)) {\n                this.text += chunk.slice(start, this.prevI);\n                return final;\n            }\n            if (isNLLike) {\n                this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                start = this.i;\n            }\n        }\n    }\n    /**\n     * Capture characters into a buffer until encountering a character.\n     *\n     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\n     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\n     *\n     * @return ``true`` if we ran into the character. Otherwise, we ran into the\n     * end of the current chunk.\n     */\n    captureToChar(char) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            let c = this.getCode();\n            switch (c) {\n                case NL_LIKE:\n                    this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    c = NL;\n                    break;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return false;\n                default:\n            }\n            if (c === char) {\n                this.text += chunk.slice(start, this.prevI);\n                return true;\n            }\n        }\n    }\n    /**\n     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n     * this parser.\n     *\n     * @return The character code that made the test fail, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureNameChars() {\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            if (c === EOC) {\n                this.name += chunk.slice(start);\n                return EOC;\n            }\n            // NL is not a name char so we don't have to test specifically for it.\n            if (!isNameChar(c)) {\n                this.name += chunk.slice(start, this.prevI);\n                return c === NL_LIKE ? NL : c;\n            }\n        }\n    }\n    /**\n     * Skip white spaces.\n     *\n     * @return The character that ended the skip, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    skipSpaces() {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC || !isS(c)) {\n                return c;\n            }\n        }\n    }\n    setXMLVersion(version) {\n        this.currentXMLVersion = version;\n        /*  eslint-disable @typescript-eslint/unbound-method */\n        if (version === \"1.0\") {\n            this.isChar = isChar10;\n            this.getCode = this.getCode10;\n        }\n        else {\n            this.isChar = isChar11;\n            this.getCode = this.getCode11;\n        }\n        /* eslint-enable @typescript-eslint/unbound-method */\n    }\n    // STATE ENGINE METHODS\n    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n    // to be sure never to come back to this state later.\n    sBegin() {\n        // We are essentially peeking at the first character of the chunk. Since\n        // S_BEGIN can be in effect only when we start working on the first chunk,\n        // the index at which we must look is necessarily 0. Note also that the\n        // following test does not depend on decoding surrogates.\n        // If the initial character is 0xFEFF, ignore it.\n        if (this.chunk.charCodeAt(0) === 0xFEFF) {\n            this.i++;\n            this.column++;\n        }\n        this.state = S_BEGIN_WHITESPACE;\n    }\n    sBeginWhitespace() {\n        // We need to know whether we've encountered spaces or not because as soon\n        // as we run into a space, an XML declaration is no longer possible. Rather\n        // than slow down skipSpaces even in places where we don't care whether it\n        // skipped anything or not, we check whether prevI is equal to the value of\n        // i from before we skip spaces.\n        const iBefore = this.i;\n        const c = this.skipSpaces();\n        if (this.prevI !== iBefore) {\n            this.xmlDeclPossible = false;\n        }\n        switch (c) {\n            case LESS:\n                this.state = S_OPEN_WAKA;\n                // We could naively call closeText but in this state, it is not normal\n                // to have text be filled with any data.\n                if (this.text.length !== 0) {\n                    throw new Error(\"no-empty text at start\");\n                }\n                break;\n            case EOC:\n                break;\n            default:\n                this.unget();\n                this.state = S_TEXT;\n                this.xmlDeclPossible = false;\n        }\n    }\n    sDoctype() {\n        var _a;\n        const c = this.captureTo(DOCTYPE_TERMINATOR);\n        switch (c) {\n            case GREATER: {\n                (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                this.doctype = true; // just remember that we saw it.\n                break;\n            }\n            case EOC:\n                break;\n            default:\n                this.text += String.fromCodePoint(c);\n                if (c === OPEN_BRACKET) {\n                    this.state = S_DTD;\n                }\n                else if (isQuote(c)) {\n                    this.state = S_DOCTYPE_QUOTE;\n                    this.q = c;\n                }\n        }\n    }\n    sDoctypeQuote() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.q = null;\n            this.state = S_DOCTYPE;\n        }\n    }\n    sDTD() {\n        const c = this.captureTo(DTD_TERMINATOR);\n        if (c === EOC) {\n            return;\n        }\n        this.text += String.fromCodePoint(c);\n        if (c === CLOSE_BRACKET) {\n            this.state = S_DOCTYPE;\n        }\n        else if (c === LESS) {\n            this.state = S_DTD_OPEN_WAKA;\n        }\n        else if (isQuote(c)) {\n            this.state = S_DTD_QUOTED;\n            this.q = c;\n        }\n    }\n    sDTDQuoted() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.state = S_DTD;\n            this.q = null;\n        }\n    }\n    sDTDOpenWaka() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        switch (c) {\n            case BANG:\n                this.state = S_DTD_OPEN_WAKA_BANG;\n                this.openWakaBang = \"\";\n                break;\n            case QUESTION:\n                this.state = S_DTD_PI;\n                break;\n            default:\n                this.state = S_DTD;\n        }\n    }\n    sDTDOpenWakaBang() {\n        const char = String.fromCodePoint(this.getCodeNorm());\n        const owb = this.openWakaBang += char;\n        this.text += char;\n        if (owb !== \"-\") {\n            this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n            this.openWakaBang = \"\";\n        }\n    }\n    sDTDComment() {\n        if (this.captureToChar(MINUS)) {\n            this.text += \"-\";\n            this.state = S_DTD_COMMENT_ENDING;\n        }\n    }\n    sDTDCommentEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n    }\n    sDTDCommentEnded() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n        else {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.state = S_DTD_COMMENT;\n        }\n    }\n    sDTDPI() {\n        if (this.captureToChar(QUESTION)) {\n            this.text += \"?\";\n            this.state = S_DTD_PI_ENDING;\n        }\n    }\n    sDTDPIEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n    }\n    sText() {\n        //\n        // We did try a version of saxes where the S_TEXT state was split in two\n        // states: one for text inside the root element, and one for text\n        // outside. This was avoiding having to test this.tags.length to decide\n        // what implementation to actually use.\n        //\n        // Peformance testing on gigabyte-size files did not show any advantage to\n        // using the two states solution instead of the current one. Conversely, it\n        // made the code a bit more complicated elsewhere. For instance, a comment\n        // can appear before the root element so when a comment ended it was\n        // necessary to determine whether to return to the S_TEXT state or to the\n        // new text-outside-root state.\n        //\n        if (this.tags.length !== 0) {\n            this.handleTextInRoot();\n        }\n        else {\n            this.handleTextOutsideRoot();\n        }\n    }\n    sEntity() {\n        // This is essentially a specialized version of captureToChar(SEMICOLON...)\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        loop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case NL_LIKE:\n                    this.entity += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    break;\n                case SEMICOLON: {\n                    const { entityReturnState } = this;\n                    const entity = this.entity + chunk.slice(start, this.prevI);\n                    this.state = entityReturnState;\n                    let parsed;\n                    if (entity === \"\") {\n                        this.fail(\"empty entity name.\");\n                        parsed = \"&;\";\n                    }\n                    else {\n                        parsed = this.parseEntity(entity);\n                        this.entity = \"\";\n                    }\n                    if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n                        this.text += parsed;\n                    }\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                }\n                case EOC:\n                    this.entity += chunk.slice(start);\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                default:\n            }\n        }\n    }\n    sOpenWaka() {\n        // Reminder: a state handler is called with at least one character\n        // available in the current chunk. So the first call to get code inside of\n        // a state handler cannot return ``EOC``. That's why we don't test\n        // for it.\n        const c = this.getCode();\n        // either a /, ?, !, or text is coming next.\n        if (isNameStartChar(c)) {\n            this.state = S_OPEN_TAG;\n            this.unget();\n            this.xmlDeclPossible = false;\n        }\n        else {\n            switch (c) {\n                case FORWARD_SLASH:\n                    this.state = S_CLOSE_TAG;\n                    this.xmlDeclPossible = false;\n                    break;\n                case BANG:\n                    this.state = S_OPEN_WAKA_BANG;\n                    this.openWakaBang = \"\";\n                    this.xmlDeclPossible = false;\n                    break;\n                case QUESTION:\n                    this.state = S_PI_FIRST_CHAR;\n                    break;\n                default:\n                    this.fail(\"disallowed character in tag name\");\n                    this.state = S_TEXT;\n                    this.xmlDeclPossible = false;\n            }\n        }\n    }\n    sOpenWakaBang() {\n        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n        switch (this.openWakaBang) {\n            case \"[CDATA[\":\n                if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextBeforeRoot = true;\n                }\n                if (this.closedRoot && !this.reportedTextAfterRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextAfterRoot = true;\n                }\n                this.state = S_CDATA;\n                this.openWakaBang = \"\";\n                break;\n            case \"--\":\n                this.state = S_COMMENT;\n                this.openWakaBang = \"\";\n                break;\n            case \"DOCTYPE\":\n                this.state = S_DOCTYPE;\n                if (this.doctype || this.sawRoot) {\n                    this.fail(\"inappropriately located doctype declaration.\");\n                }\n                this.openWakaBang = \"\";\n                break;\n            default:\n                // 7 happens to be the maximum length of the string that can possibly\n                // match one of the cases above.\n                if (this.openWakaBang.length >= 7) {\n                    this.fail(\"incorrect syntax.\");\n                }\n        }\n    }\n    sComment() {\n        if (this.captureToChar(MINUS)) {\n            this.state = S_COMMENT_ENDING;\n        }\n    }\n    sCommentEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === MINUS) {\n            this.state = S_COMMENT_ENDED;\n            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n            this.text = \"\";\n        }\n        else {\n            this.text += `-${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n    }\n    sCommentEnded() {\n        const c = this.getCodeNorm();\n        if (c !== GREATER) {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.text += `--${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n        else {\n            this.state = S_TEXT;\n        }\n    }\n    sCData() {\n        if (this.captureToChar(CLOSE_BRACKET)) {\n            this.state = S_CDATA_ENDING;\n        }\n    }\n    sCDataEnding() {\n        const c = this.getCodeNorm();\n        if (c === CLOSE_BRACKET) {\n            this.state = S_CDATA_ENDING_2;\n        }\n        else {\n            this.text += `]${String.fromCodePoint(c)}`;\n            this.state = S_CDATA;\n        }\n    }\n    sCDataEnding2() {\n        var _a;\n        const c = this.getCodeNorm();\n        switch (c) {\n            case GREATER: {\n                (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                break;\n            }\n            case CLOSE_BRACKET:\n                this.text += \"]\";\n                break;\n            default:\n                this.text += `]]${String.fromCodePoint(c)}`;\n                this.state = S_CDATA;\n        }\n    }\n    // We need this separate state to check the first character fo the pi target\n    // with this.nameStartCheck which allows less characters than this.nameCheck.\n    sPIFirstChar() {\n        const c = this.getCodeNorm();\n        // This is first because in the case where the file is well-formed this is\n        // the branch taken. We optimize for well-formedness.\n        if (this.nameStartCheck(c)) {\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n        else if (c === QUESTION || isS(c)) {\n            this.fail(\"processing instruction without a target.\");\n            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n        }\n        else {\n            this.fail(\"disallowed character in processing instruction name.\");\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n    }\n    sPIRest() {\n        // Capture characters into a piTarget while ``this.nameCheck`` run on the\n        // character read returns true.\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC) {\n                this.piTarget += chunk.slice(start);\n                return;\n            }\n            // NL cannot satisfy this.nameCheck so we don't have to test specifically\n            // for it.\n            if (!this.nameCheck(c)) {\n                this.piTarget += chunk.slice(start, this.prevI);\n                const isQuestion = c === QUESTION;\n                if (isQuestion || isS(c)) {\n                    if (this.piTarget === \"xml\") {\n                        if (!this.xmlDeclPossible) {\n                            this.fail(\"an XML declaration must be at the start of the document.\");\n                        }\n                        this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n                    }\n                    else {\n                        this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n                    }\n                }\n                else {\n                    this.fail(\"disallowed character in processing instruction name.\");\n                    this.piTarget += String.fromCodePoint(c);\n                }\n                break;\n            }\n        }\n    }\n    sPIBody() {\n        if (this.text.length === 0) {\n            const c = this.getCodeNorm();\n            if (c === QUESTION) {\n                this.state = S_PI_ENDING;\n            }\n            else if (!isS(c)) {\n                this.text = String.fromCodePoint(c);\n            }\n        }\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        else if (this.captureToChar(QUESTION)) {\n            this.state = S_PI_ENDING;\n        }\n    }\n    sPIEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            const { piTarget } = this;\n            if (piTarget.toLowerCase() === \"xml\") {\n                this.fail(\"the XML declaration must appear at the start of the document.\");\n            }\n            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n                target: piTarget,\n                body: this.text,\n            });\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else if (c === QUESTION) {\n            // We ran into ?? as part of a processing instruction. We initially took\n            // the first ? as a sign that the PI was ending, but it is not. So we have\n            // to add it to the body but we take the new ? as a sign that the PI is\n            // ending.\n            this.text += \"?\";\n        }\n        else {\n            this.text += `?${String.fromCodePoint(c)}`;\n            this.state = S_PI_BODY;\n        }\n        this.xmlDeclPossible = false;\n    }\n    sXMLDeclNameStart() {\n        const c = this.skipSpaces();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (c !== EOC) {\n            this.state = S_XML_DECL_NAME;\n            this.name = String.fromCodePoint(c);\n        }\n    }\n    sXMLDeclName() {\n        const c = this.captureTo(XML_DECL_NAME_TERMINATOR);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.name += this.text;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (!(isS(c) || c === EQUAL)) {\n            return;\n        }\n        this.name += this.text;\n        this.text = \"\";\n        if (!this.xmlDeclExpects.includes(this.name)) {\n            switch (this.name.length) {\n                case 0:\n                    this.fail(\"did not expect any more name/value pairs.\");\n                    break;\n                case 1:\n                    this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n                    break;\n                default:\n                    this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n            }\n        }\n        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n    }\n    sXMLDeclEq() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (c !== EQUAL) {\n            this.fail(\"value required.\");\n        }\n        this.state = S_XML_DECL_VALUE_START;\n    }\n    sXMLDeclValueStart() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (!isQuote(c)) {\n            this.fail(\"value must be quoted.\");\n            this.q = SPACE;\n        }\n        else {\n            this.q = c;\n        }\n        this.state = S_XML_DECL_VALUE;\n    }\n    sXMLDeclValue() {\n        const c = this.captureTo([this.q, QUESTION]);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (c === EOC) {\n            return;\n        }\n        const value = this.text;\n        this.text = \"\";\n        switch (this.name) {\n            case \"version\": {\n                this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n                const version = value;\n                this.xmlDecl.version = version;\n                // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n                if (!/^1\\.[0-9]+$/.test(version)) {\n                    this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n                }\n                // When forceXMLVersion is set, the XML declaration is ignored.\n                else if (!this.opt.forceXMLVersion) {\n                    this.setXMLVersion(version);\n                }\n                break;\n            }\n            case \"encoding\":\n                if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n                    this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n                }\n                this.xmlDeclExpects = [\"standalone\"];\n                this.xmlDecl.encoding = value;\n                break;\n            case \"standalone\":\n                if (value !== \"yes\" && value !== \"no\") {\n                    this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n                }\n                this.xmlDeclExpects = [];\n                this.xmlDecl.standalone = value;\n                break;\n            default:\n            // We don't need to raise an error here since we've already raised one\n            // when checking what name was expected.\n        }\n        this.name = \"\";\n        this.state = S_XML_DECL_SEPARATOR;\n    }\n    sXMLDeclSeparator() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (!isS(c)) {\n            this.fail(\"whitespace required.\");\n            this.unget();\n        }\n        this.state = S_XML_DECL_NAME_START;\n    }\n    sXMLDeclEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            if (this.piTarget !== \"xml\") {\n                this.fail(\"processing instructions are not allowed before root.\");\n            }\n            else if (this.name !== \"version\" &&\n                this.xmlDeclExpects.includes(\"version\")) {\n                this.fail(\"XML declaration must contain a version.\");\n            }\n            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n            this.name = \"\";\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else {\n            // We got here because the previous character was a ?, but the question\n            // mark character is not valid inside any of the XML declaration\n            // name/value pairs.\n            this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n        }\n        this.xmlDeclPossible = false;\n    }\n    sOpenTag() {\n        var _a;\n        const c = this.captureNameChars();\n        if (c === EOC) {\n            return;\n        }\n        const tag = this.tag = {\n            name: this.name,\n            attributes: Object.create(null),\n        };\n        this.name = \"\";\n        if (this.xmlnsOpt) {\n            this.topNS = tag.ns = Object.create(null);\n        }\n        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        this.sawRoot = true;\n        if (!this.fragmentOpt && this.closedRoot) {\n            this.fail(\"documents may contain only one root.\");\n        }\n        switch (c) {\n            case GREATER:\n                this.openTag();\n                break;\n            case FORWARD_SLASH:\n                this.state = S_OPEN_TAG_SLASH;\n                break;\n            default:\n                if (!isS(c)) {\n                    this.fail(\"disallowed character in tag name.\");\n                }\n                this.state = S_ATTRIB;\n        }\n    }\n    sOpenTagSlash() {\n        if (this.getCode() === GREATER) {\n            this.openSelfClosingTag();\n        }\n        else {\n            this.fail(\"forward-slash in opening tag not followed by >.\");\n            this.state = S_ATTRIB;\n        }\n    }\n    sAttrib() {\n        const c = this.skipSpaces();\n        if (c === EOC) {\n            return;\n        }\n        if (isNameStartChar(c)) {\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribName() {\n        const c = this.captureNameChars();\n        if (c === EQUAL) {\n            this.state = S_ATTRIB_VALUE;\n        }\n        else if (isS(c)) {\n            this.state = S_ATTRIB_NAME_SAW_WHITE;\n        }\n        else if (c === GREATER) {\n            this.fail(\"attribute without value.\");\n            this.pushAttrib(this.name, this.name);\n            this.name = this.text = \"\";\n            this.openTag();\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribNameSawWhite() {\n        const c = this.skipSpaces();\n        switch (c) {\n            case EOC:\n                return;\n            case EQUAL:\n                this.state = S_ATTRIB_VALUE;\n                break;\n            default:\n                this.fail(\"attribute without value.\");\n                // Should we do this???\n                // this.tag.attributes[this.name] = \"\";\n                this.text = \"\";\n                this.name = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else if (isNameStartChar(c)) {\n                    this.unget();\n                    this.state = S_ATTRIB_NAME;\n                }\n                else {\n                    this.fail(\"disallowed character in attribute name.\");\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sAttribValue() {\n        const c = this.getCodeNorm();\n        if (isQuote(c)) {\n            this.q = c;\n            this.state = S_ATTRIB_VALUE_QUOTED;\n        }\n        else if (!isS(c)) {\n            this.fail(\"unquoted attribute value.\");\n            this.state = S_ATTRIB_VALUE_UNQUOTED;\n            this.unget();\n        }\n    }\n    sAttribValueQuoted() {\n        // We deliberately do not use captureTo here. The specialized code we use\n        // here is faster than using captureTo.\n        const { q, chunk } = this;\n        let { i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case q:\n                    this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n                    this.name = this.text = \"\";\n                    this.q = null;\n                    this.state = S_ATTRIB_VALUE_CLOSED;\n                    return;\n                case AMP:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n                    return;\n                case NL:\n                case NL_LIKE:\n                case TAB:\n                    this.text += `${chunk.slice(start, this.prevI)} `;\n                    start = this.i;\n                    break;\n                case LESS:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.fail(\"disallowed character.\");\n                    return;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return;\n                default:\n            }\n        }\n    }\n    sAttribValueClosed() {\n        const c = this.getCodeNorm();\n        if (isS(c)) {\n            this.state = S_ATTRIB;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else if (isNameStartChar(c)) {\n            this.fail(\"no whitespace between attributes.\");\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribValueUnquoted() {\n        // We don't do anything regarding EOL or space handling for unquoted\n        // attributes. We already have failed by the time we get here, and the\n        // contract that saxes upholds states that upon failure, it is not safe to\n        // rely on the data passed to event handlers (other than\n        // ``onerror``). Passing \"bad\" data is not a problem.\n        const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n        switch (c) {\n            case AMP:\n                this.state = S_ENTITY;\n                this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n                break;\n            case LESS:\n                this.fail(\"disallowed character.\");\n                break;\n            case EOC:\n                break;\n            default:\n                if (this.text.includes(\"]]>\")) {\n                    this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                }\n                this.pushAttrib(this.name, this.text);\n                this.name = this.text = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else {\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sCloseTag() {\n        const c = this.captureNameChars();\n        if (c === GREATER) {\n            this.closeTag();\n        }\n        else if (isS(c)) {\n            this.state = S_CLOSE_TAG_SAW_WHITE;\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    sCloseTagSawWhite() {\n        switch (this.skipSpaces()) {\n            case GREATER:\n                this.closeTag();\n                break;\n            case EOC:\n                break;\n            default:\n                this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    // END OF STATE ENGINE METHODS\n    handleTextInRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for performing the ]]> check. A previous version of this code, checked\n        // ``this.text`` for the presence of ]]>. It simplified the code but was\n        // very costly when character data contained a lot of entities to be parsed.\n        //\n        // Since we are using a specialized loop, we also keep track of the presence\n        // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n        //\n        let { i: start, forbiddenState } = this;\n        const { chunk, textHandler: handler } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        scanLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                case CLOSE_BRACKET:\n                    switch (forbiddenState) {\n                        case FORBIDDEN_START:\n                            forbiddenState = FORBIDDEN_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET:\n                            forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET_BRACKET:\n                            break;\n                        default:\n                            throw new Error(\"impossible state\");\n                    }\n                    break;\n                case GREATER:\n                    if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n                        this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                default:\n                    forbiddenState = FORBIDDEN_START;\n            }\n        }\n        this.forbiddenState = forbiddenState;\n    }\n    handleTextOutsideRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for a specialized task. We keep track of the presence of non-space\n        // characters in the text since these are errors when appearing outside the\n        // document root element.\n        let { i: start } = this;\n        const { chunk, textHandler: handler } = this;\n        let nonSpace = false;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        outRootLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const code = this.getCode();\n            switch (code) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    nonSpace = true;\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                default:\n                    if (!isS(code)) {\n                        nonSpace = true;\n                    }\n            }\n        }\n        if (!nonSpace) {\n            return;\n        }\n        // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n        // to avoid reporting errors for every single character that is out of\n        // place.\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextBeforeRoot = true;\n        }\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextAfterRoot = true;\n        }\n    }\n    pushAttribNS(name, value) {\n        var _a;\n        const { prefix, local } = this.qname(name);\n        const attr = { name, prefix, local, value };\n        this.attribList.push(attr);\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n        if (prefix === \"xmlns\") {\n            const trimmed = value.trim();\n            if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n                this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n            }\n            this.topNS[local] = trimmed;\n            nsPairCheck(this, local, trimmed);\n        }\n        else if (name === \"xmlns\") {\n            const trimmed = value.trim();\n            this.topNS[\"\"] = trimmed;\n            nsPairCheck(this, \"\", trimmed);\n        }\n    }\n    pushAttribPlain(name, value) {\n        var _a;\n        const attr = { name, value };\n        this.attribList.push(attr);\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n    }\n    /**\n     * End parsing. This performs final well-formedness checks and resets the\n     * parser to a clean state.\n     *\n     * @returns this\n     */\n    end() {\n        var _a, _b;\n        if (!this.sawRoot) {\n            this.fail(\"document must contain a root element.\");\n        }\n        const { tags } = this;\n        while (tags.length > 0) {\n            const tag = tags.pop();\n            this.fail(`unclosed tag: ${tag.name}`);\n        }\n        if ((this.state !== S_BEGIN) && (this.state !== S_TEXT)) {\n            this.fail(\"unexpected end.\");\n        }\n        const { text } = this;\n        if (text.length !== 0) {\n            (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n            this.text = \"\";\n        }\n        this._closed = true;\n        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n        this._init();\n        return this;\n    }\n    /**\n     * Resolve a namespace prefix.\n     *\n     * @param prefix The prefix to resolve.\n     *\n     * @returns The namespace URI or ``undefined`` if the prefix is not defined.\n     */\n    resolve(prefix) {\n        var _a, _b;\n        let uri = this.topNS[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        const { tags } = this;\n        for (let index = tags.length - 1; index >= 0; index--) {\n            uri = tags[index].ns[prefix];\n            if (uri !== undefined) {\n                return uri;\n            }\n        }\n        uri = this.ns[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n    }\n    /**\n     * Parse a qname into its prefix and local name parts.\n     *\n     * @param name The name to parse\n     *\n     * @returns\n     */\n    qname(name) {\n        // This is faster than using name.split(\":\").\n        const colon = name.indexOf(\":\");\n        if (colon === -1) {\n            return { prefix: \"\", local: name };\n        }\n        const local = name.slice(colon + 1);\n        const prefix = name.slice(0, colon);\n        if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n            this.fail(`malformed name: ${name}.`);\n        }\n        return { prefix, local };\n    }\n    processAttribsNS() {\n        var _a;\n        const { attribList } = this;\n        const tag = this.tag;\n        {\n            // add namespace info to tag\n            const { prefix, local } = this.qname(tag.name);\n            tag.prefix = prefix;\n            tag.local = local;\n            const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n            if (prefix !== \"\") {\n                if (prefix === \"xmlns\") {\n                    this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n                }\n                if (uri === \"\") {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    tag.uri = prefix;\n                }\n            }\n        }\n        if (attribList.length === 0) {\n            return;\n        }\n        const { attributes } = tag;\n        const seen = new Set();\n        // Note: do not apply default ns to attributes:\n        //   http://www.w3.org/TR/REC-xml-names/#defaulting\n        for (const attr of attribList) {\n            const { name, prefix, local } = attr;\n            let uri;\n            let eqname;\n            if (prefix === \"\") {\n                uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n                eqname = name;\n            }\n            else {\n                uri = this.resolve(prefix);\n                // if there's any attributes with an undefined namespace,\n                // then fail on them now.\n                if (uri === undefined) {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    uri = prefix;\n                }\n                eqname = `{${uri}}${local}`;\n            }\n            if (seen.has(eqname)) {\n                this.fail(`duplicate attribute: ${eqname}.`);\n            }\n            seen.add(eqname);\n            attr.uri = uri;\n            attributes[name] = attr;\n        }\n        this.attribList = [];\n    }\n    processAttribsPlain() {\n        const { attribList } = this;\n        // eslint-disable-next-line prefer-destructuring\n        const attributes = this.tag.attributes;\n        for (const { name, value } of attribList) {\n            if (attributes[name] !== undefined) {\n                this.fail(`duplicate attribute: ${name}.`);\n            }\n            attributes[name] = value;\n        }\n        this.attribList = [];\n    }\n    /**\n     * Handle a complete open tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag``.\n     */\n    openTag() {\n        var _a;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = false;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        tags.push(tag);\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete self-closing tag. This parser code calls this once it has\n     * seen the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag`` and ``onclosetag``.\n     */\n    openSelfClosingTag() {\n        var _a, _b, _c;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = true;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n        const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n        if (top === null) {\n            this.closedRoot = true;\n        }\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete close tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onclosetag``.\n     */\n    closeTag() {\n        const { tags, name } = this;\n        // Our state after this will be S_TEXT, no matter what, and we can clear\n        // tagName now.\n        this.state = S_TEXT;\n        this.name = \"\";\n        if (name === \"\") {\n            this.fail(\"weird empty close tag.\");\n            this.text += \"</>\";\n            return;\n        }\n        const handler = this.closeTagHandler;\n        let l = tags.length;\n        while (l-- > 0) {\n            const tag = this.tag = tags.pop();\n            this.topNS = tag.ns;\n            handler === null || handler === void 0 ? void 0 : handler(tag);\n            if (tag.name === name) {\n                break;\n            }\n            this.fail(\"unexpected close tag.\");\n        }\n        if (l === 0) {\n            this.closedRoot = true;\n        }\n        else if (l < 0) {\n            this.fail(`unmatched closing tag: ${name}.`);\n            this.text += `</${name}>`;\n        }\n    }\n    /**\n     * Resolves an entity. Makes any necessary well-formedness checks.\n     *\n     * @param entity The entity to resolve.\n     *\n     * @returns The parsed entity.\n     */\n    parseEntity(entity) {\n        // startsWith would be significantly slower for this test.\n        if (entity[0] !== \"#\") {\n            const defined = this.ENTITIES[entity];\n            if (defined !== undefined) {\n                return defined;\n            }\n            this.fail(this.isName(entity) ? \"undefined entity.\" :\n                \"disallowed character in entity name.\");\n            return `&${entity};`;\n        }\n        let num = NaN;\n        if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n            num = parseInt(entity.slice(2), 16);\n        }\n        else if (/^#[0-9]+$/.test(entity)) {\n            num = parseInt(entity.slice(1), 10);\n        }\n        // The character reference is required to match the CHAR production.\n        if (!this.isChar(num)) {\n            this.fail(\"malformed character entity.\");\n            return `&${entity};`;\n        }\n        return String.fromCodePoint(num);\n    }\n}\nexports.SaxesParser = SaxesParser;\n//# sourceMappingURL=saxes.js.map","\"use strict\";\n/**\n * Character class utilities for XML NS 1.0 edition 3.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\n// tslint:disable-next-line:max-line-length\nexports.NC_NAME_START_CHAR = \"A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NC_NAME_CHAR = \"-\" + exports.NC_NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.NC_NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NC_NAME_START_CHAR + \"]$\", \"u\");\nexports.NC_NAME_CHAR_RE = new RegExp(\"^[\" + exports.NC_NAME_CHAR + \"]$\", \"u\");\nexports.NC_NAME_RE = new RegExp(\"^[\" + exports.NC_NAME_START_CHAR + \"][\" + exports.NC_NAME_CHAR + \"]*$\", \"u\");\n/**\n * Determines whether a codepoint matches [[NC_NAME_START_CHAR]].\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches.\n */\n// tslint:disable-next-line:cyclomatic-complexity\nfunction isNCNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        c === 0x5F ||\n        (c >= 0x61 && c <= 0x7A) ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x200C && c <= 0x200D) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNCNameStartChar = isNCNameStartChar;\n/**\n * Determines whether a codepoint matches [[NC_NAME_CHAR]].\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches.\n */\nfunction isNCNameChar(c) {\n    return isNCNameStartChar(c) ||\n        (c === 0x2D ||\n            c === 0x2E ||\n            (c >= 0x30 && c <= 0x39) ||\n            c === 0x00B7 ||\n            (c >= 0x0300 && c <= 0x036F) ||\n            (c >= 0x203F && c <= 0x2040));\n}\nexports.isNCNameChar = isNCNameChar;\n//# sourceMappingURL=ed3.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Literal = void 0;\nconst NamedNode_1 = require(\"./NamedNode\");\n/**\n * A term that represents an RDF literal, containing a string with an optional language tag or datatype.\n */\nclass Literal {\n    constructor(value, languageOrDatatype) {\n        this.termType = 'Literal';\n        this.value = value;\n        if (typeof languageOrDatatype === 'string') {\n            this.language = languageOrDatatype;\n            this.datatype = Literal.RDF_LANGUAGE_STRING;\n        }\n        else if (languageOrDatatype) {\n            this.language = '';\n            this.datatype = languageOrDatatype;\n        }\n        else {\n            this.language = '';\n            this.datatype = Literal.XSD_STRING;\n        }\n    }\n    equals(other) {\n        return !!other && other.termType === 'Literal' && other.value === this.value &&\n            other.language === this.language && this.datatype.equals(other.datatype);\n    }\n}\nexports.Literal = Literal;\nLiteral.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');\nLiteral.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');\n//# sourceMappingURL=Literal.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Resolve\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/**\n * Character classes and associated utilities for the 2nd edition of XML 1.1.\n *\n * @author Louis-Dominique Dubeau\n * @license MIT\n * @copyright Louis-Dominique Dubeau\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//\n// Fragments.\n//\nexports.CHAR = \"\\u0001-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\";\nexports.RESTRICTED_CHAR = \"\\u0001-\\u0008\\u000B\\u000C\\u000E-\\u001F\\u007F-\\u0084\\u0086-\\u009F\";\nexports.S = \" \\t\\r\\n\";\n// tslint:disable-next-line:max-line-length\nexports.NAME_START_CHAR = \":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\uD800\\uDC00-\\uDB7F\\uDFFF\";\nexports.NAME_CHAR = \"-\" + exports.NAME_START_CHAR + \".0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040\";\n//\n// Regular expressions.\n//\nexports.CHAR_RE = new RegExp(\"^[\" + exports.CHAR + \"]$\", \"u\");\nexports.RESTRICTED_CHAR_RE = new RegExp(\"^[\" + exports.RESTRICTED_CHAR + \"]$\", \"u\");\nexports.S_RE = new RegExp(\"^[\" + exports.S + \"]+$\", \"u\");\nexports.NAME_START_CHAR_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"]$\", \"u\");\nexports.NAME_CHAR_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]$\", \"u\");\nexports.NAME_RE = new RegExp(\"^[\" + exports.NAME_START_CHAR + \"][\" + exports.NAME_CHAR + \"]*$\", \"u\");\nexports.NMTOKEN_RE = new RegExp(\"^[\" + exports.NAME_CHAR + \"]+$\", \"u\");\nvar TAB = 9;\nvar NL = 0xA;\nvar CR = 0xD;\nvar SPACE = 0x20;\n//\n// Lists.\n//\n/** All characters in the ``S`` production. */\nexports.S_LIST = [SPACE, NL, CR, TAB];\n/**\n * Determines whether a codepoint matches the ``CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR``.\n */\nfunction isChar(c) {\n    return (c >= 0x0001 && c <= 0xD7FF) ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isChar = isChar;\n/**\n * Determines whether a codepoint matches the ``RESTRICTED_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``RESTRICTED_CHAR``.\n */\nfunction isRestrictedChar(c) {\n    return (c >= 0x1 && c <= 0x8) ||\n        c === 0xB ||\n        c === 0xC ||\n        (c >= 0xE && c <= 0x1F) ||\n        (c >= 0x7F && c <= 0x84) ||\n        (c >= 0x86 && c <= 0x9F);\n}\nexports.isRestrictedChar = isRestrictedChar;\n/**\n * Determines whether a codepoint matches the ``CHAR`` production and does not\n * match the ``RESTRICTED_CHAR`` production. ``isCharAndNotRestricted(x)`` is\n * equivalent to ``isChar(x) && !isRestrictedChar(x)``. This function is faster\n * than running the two-call equivalent.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``CHAR`` and does not match\n * ``RESTRICTED_CHAR``.\n */\nfunction isCharAndNotRestricted(c) {\n    return (c === 0x9) ||\n        (c === 0xA) ||\n        (c === 0xD) ||\n        (c > 0x1F && c < 0x7F) ||\n        (c === 0x85) ||\n        (c > 0x9F && c <= 0xD7FF) ||\n        (c >= 0xE000 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0x10FFFF);\n}\nexports.isCharAndNotRestricted = isCharAndNotRestricted;\n/**\n * Determines whether a codepoint matches the ``S`` (space) production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``S``.\n */\nfunction isS(c) {\n    return c === SPACE || c === NL || c === CR || c === TAB;\n}\nexports.isS = isS;\n/**\n * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.\n */\n// tslint:disable-next-line:cyclomatic-complexity\nfunction isNameStartChar(c) {\n    return ((c >= 0x41 && c <= 0x5A) ||\n        (c >= 0x61 && c <= 0x7A) ||\n        c === 0x3A ||\n        c === 0x5F ||\n        c === 0x200C ||\n        c === 0x200D ||\n        (c >= 0xC0 && c <= 0xD6) ||\n        (c >= 0xD8 && c <= 0xF6) ||\n        (c >= 0x00F8 && c <= 0x02FF) ||\n        (c >= 0x0370 && c <= 0x037D) ||\n        (c >= 0x037F && c <= 0x1FFF) ||\n        (c >= 0x2070 && c <= 0x218F) ||\n        (c >= 0x2C00 && c <= 0x2FEF) ||\n        (c >= 0x3001 && c <= 0xD7FF) ||\n        (c >= 0xF900 && c <= 0xFDCF) ||\n        (c >= 0xFDF0 && c <= 0xFFFD) ||\n        (c >= 0x10000 && c <= 0xEFFFF));\n}\nexports.isNameStartChar = isNameStartChar;\n/**\n * Determines whether a codepoint matches the ``NAME_CHAR`` production.\n *\n * @param c The code point.\n *\n * @returns ``true`` if the codepoint matches ``NAME_CHAR``.\n */\nfunction isNameChar(c) {\n    return isNameStartChar(c) ||\n        (c >= 0x30 && c <= 0x39) ||\n        c === 0x2D ||\n        c === 0x2E ||\n        c === 0xB7 ||\n        (c >= 0x0300 && c <= 0x036F) ||\n        (c >= 0x203F && c <= 0x2040);\n}\nexports.isNameChar = isNameChar;\n//# sourceMappingURL=ed2.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\n/**\n * A term that represents a variable.\n */\nclass Variable {\n    constructor(value) {\n        this.termType = 'Variable';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'Variable' && other.value === this.value;\n    }\n}\nexports.Variable = Variable;\n//# sourceMappingURL=Variable.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataFactory = void 0;\nconst BlankNode_1 = require(\"./BlankNode\");\nconst DefaultGraph_1 = require(\"./DefaultGraph\");\nconst Literal_1 = require(\"./Literal\");\nconst NamedNode_1 = require(\"./NamedNode\");\nconst Quad_1 = require(\"./Quad\");\nconst Variable_1 = require(\"./Variable\");\nlet dataFactoryCounter = 0;\n/**\n * A factory for instantiating RDF terms and quads.\n */\nclass DataFactory {\n    constructor(options) {\n        this.blankNodeCounter = 0;\n        options = options || {};\n        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;\n    }\n    /**\n     * @param value The IRI for the named node.\n     * @return A new instance of NamedNode.\n     * @see NamedNode\n     */\n    namedNode(value) {\n        return new NamedNode_1.NamedNode(value);\n    }\n    /**\n     * @param value The optional blank node identifier.\n     * @return A new instance of BlankNode.\n     *         If the `value` parameter is undefined a new identifier\n     *         for the blank node is generated for each call.\n     * @see BlankNode\n     */\n    blankNode(value) {\n        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);\n    }\n    /**\n     * @param value              The literal value.\n     * @param languageOrDatatype The optional language or datatype.\n     *                           If `languageOrDatatype` is a NamedNode,\n     *                           then it is used for the value of `NamedNode.datatype`.\n     *                           Otherwise `languageOrDatatype` is used for the value\n     *                           of `NamedNode.language`.\n     * @return A new instance of Literal.\n     * @see Literal\n     */\n    literal(value, languageOrDatatype) {\n        return new Literal_1.Literal(value, languageOrDatatype);\n    }\n    /**\n     * This method is optional.\n     * @param value The variable name\n     * @return A new instance of Variable.\n     * @see Variable\n     */\n    variable(value) {\n        return new Variable_1.Variable(value);\n    }\n    /**\n     * @return An instance of DefaultGraph.\n     */\n    defaultGraph() {\n        return DefaultGraph_1.DefaultGraph.INSTANCE;\n    }\n    /**\n     * @param subject   The quad subject term.\n     * @param predicate The quad predicate term.\n     * @param object    The quad object term.\n     * @param graph     The quad graph term.\n     * @return A new instance of Quad.\n     * @see Quad\n     */\n    quad(subject, predicate, object, graph) {\n        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());\n    }\n    /**\n     * Create a deep copy of the given term using this data factory.\n     * @param original An RDF term.\n     * @return A deep copy of the given term.\n     */\n    fromTerm(original) {\n        // TODO: remove nasty any casts when this TS bug has been fixed:\n        //  https://github.com/microsoft/TypeScript/issues/26933\n        switch (original.termType) {\n            case 'NamedNode':\n                return this.namedNode(original.value);\n            case 'BlankNode':\n                return this.blankNode(original.value);\n            case 'Literal':\n                if (original.language) {\n                    return this.literal(original.value, original.language);\n                }\n                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {\n                    return this.literal(original.value, this.fromTerm(original.datatype));\n                }\n                return this.literal(original.value);\n            case 'Variable':\n                return this.variable(original.value);\n            case 'DefaultGraph':\n                return this.defaultGraph();\n            case 'Quad':\n                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));\n        }\n    }\n    /**\n     * Create a deep copy of the given quad using this data factory.\n     * @param original An RDF quad.\n     * @return A deep copy of the given quad.\n     */\n    fromQuad(original) {\n        return this.fromTerm(original);\n    }\n    /**\n     * Reset the internal blank node counter.\n     */\n    resetBlankNodeCounter() {\n        this.blankNodeCounter = 0;\n    }\n}\nexports.DataFactory = DataFactory;\n//# sourceMappingURL=DataFactory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultGraph = void 0;\n/**\n * A singleton term instance that represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass DefaultGraph {\n    constructor() {\n        this.termType = 'DefaultGraph';\n        this.value = '';\n        // Private constructor\n    }\n    equals(other) {\n        return !!other && other.termType === 'DefaultGraph';\n    }\n}\nexports.DefaultGraph = DefaultGraph;\nDefaultGraph.INSTANCE = new DefaultGraph();\n//# sourceMappingURL=DefaultGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParseType = exports.RdfXmlParser = void 0;\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst saxes_1 = require(\"@rubensworks/saxes\");\nconst readable_stream_1 = require(\"readable-stream\");\nconst ParseError_1 = require(\"./ParseError\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst validate_iri_1 = require(\"validate-iri\");\nclass RdfXmlParser extends readable_stream_1.Transform {\n    constructor(args) {\n        super({ readableObjectMode: true });\n        this.activeTagStack = [];\n        this.nodeIds = {};\n        if (args) {\n            Object.assign(this, args);\n            this.options = args;\n        }\n        if (!this.dataFactory) {\n            this.dataFactory = new rdf_data_factory_1.DataFactory();\n        }\n        if (!this.baseIRI) {\n            this.baseIRI = '';\n        }\n        if (!this.defaultGraph) {\n            this.defaultGraph = this.dataFactory.defaultGraph();\n        }\n        if (this.validateUri !== false) {\n            this.validateUri = true;\n        }\n        if (!this.iriValidationStrategy) {\n            this.iriValidationStrategy = this.validateUri ? validate_iri_1.IriValidationStrategy.Pragmatic : validate_iri_1.IriValidationStrategy.None;\n        }\n        this.saxParser = new saxes_1.SaxesParser({ xmlns: true, position: this.trackPosition });\n        this.attachSaxListeners();\n    }\n    /**\n     * Parses the given text stream into a quad stream.\n     * @param {NodeJS.EventEmitter} stream A text stream.\n     * @return {RDF.Stream} A quad stream.\n     */\n    import(stream) {\n        const output = new readable_stream_1.PassThrough({ readableObjectMode: true });\n        stream.on('error', (error) => parsed.emit('error', error));\n        stream.on('data', (data) => output.push(data));\n        stream.on('end', () => output.push(null));\n        const parsed = output.pipe(new RdfXmlParser(this.options));\n        return parsed;\n    }\n    _transform(chunk, encoding, callback) {\n        try {\n            this.saxParser.write(chunk);\n        }\n        catch (e) {\n            return callback(e);\n        }\n        callback();\n    }\n    /**\n     * Create a new parse error instance.\n     * @param {string} message An error message.\n     * @return {Error} An error instance.\n     */\n    newParseError(message) {\n        return new ParseError_1.ParseError(this, message);\n    }\n    /**\n     * Convert the given value to a IRI by taking into account the baseIRI.\n     *\n     * This will follow the RDF/XML spec for converting values with baseIRIs to a IRI.\n     *\n     * @param {string} value The value to convert to an IRI.\n     * @param {IActiveTag} activeTag The active tag.\n     * @return {NamedNode} an IRI.\n     */\n    valueToUri(value, activeTag) {\n        return this.uriToNamedNode((0, relative_to_absolute_iri_1.resolve)(value, activeTag.baseIRI));\n    }\n    /**\n     * Convert the given value URI string to a named node.\n     *\n     * This throw an error if the URI is invalid.\n     *\n     * @param {string} uri A URI string.\n     * @return {NamedNode} a named node.\n     */\n    uriToNamedNode(uri) {\n        // Validate URI\n        const uriValidationResult = (0, validate_iri_1.validateIri)(uri, this.iriValidationStrategy);\n        if (uriValidationResult instanceof Error) {\n            throw this.newParseError(uriValidationResult.message);\n        }\n        return this.dataFactory.namedNode(uri);\n    }\n    /**\n     * Validate the given value as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n     * If it is invalid, an error will thrown emitted.\n     * @param {string} value A value.\n     */\n    validateNcname(value) {\n        // Validate term as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName\n        if (!RdfXmlParser.NCNAME_MATCHER.test(value)) {\n            throw this.newParseError(`Not a valid NCName: ${value}`);\n        }\n    }\n    attachSaxListeners() {\n        this.saxParser.on('error', (error) => this.emit('error', error));\n        this.saxParser.on('opentag', this.onTag.bind(this));\n        this.saxParser.on('text', this.onText.bind(this));\n        this.saxParser.on('cdata', this.onText.bind(this));\n        this.saxParser.on('closetag', this.onCloseTag.bind(this));\n        this.saxParser.on('doctype', this.onDoctype.bind(this));\n    }\n    /**\n     * Handle the given tag.\n     * @param {SaxesTagNS} tag A SAX tag.\n     */\n    onTag(tag) {\n        // Get parent tag\n        const parentTag = this.activeTagStack.length\n            ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n        let currentParseType = ParseType.RESOURCE;\n        if (parentTag) {\n            parentTag.hadChildren = true;\n            currentParseType = parentTag.childrenParseType;\n        }\n        // Check if this tag needs to be converted to a string\n        if (parentTag && parentTag.childrenStringTags) {\n            // Convert this tag to a string\n            const tagName = tag.name;\n            let attributes = '';\n            for (const attributeKey in tag.attributes) {\n                attributes += ` ${attributeKey}=\"${tag.attributes[attributeKey].value}\"`;\n            }\n            const tagContents = `${tagName}${attributes}`;\n            const tagString = `<${tagContents}>`;\n            parentTag.childrenStringTags.push(tagString);\n            // Inherit the array, so that deeper tags are appended to this same array\n            const stringActiveTag = { childrenStringTags: parentTag.childrenStringTags };\n            stringActiveTag.childrenStringEmitClosingTag = `</${tagName}>`;\n            this.activeTagStack.push(stringActiveTag);\n            // Halt any further processing\n            return;\n        }\n        const activeTag = {};\n        if (parentTag) {\n            // Inherit language scope and baseIRI from parent\n            activeTag.language = parentTag.language;\n            activeTag.baseIRI = parentTag.baseIRI;\n        }\n        else {\n            activeTag.baseIRI = this.baseIRI;\n        }\n        this.activeTagStack.push(activeTag);\n        if (currentParseType === ParseType.RESOURCE) {\n            this.onTagResource(tag, activeTag, parentTag, !parentTag);\n        }\n        else { // currentParseType === ParseType.PROPERTY\n            this.onTagProperty(tag, activeTag, parentTag);\n        }\n    }\n    /**\n     * Handle the given node element in resource-mode.\n     * @param {SaxesTagNS} tag A SAX tag.\n     * @param {IActiveTag} activeTag The currently active tag.\n     * @param {IActiveTag} parentTag The parent tag or null.\n     * @param {boolean} rootTag If we are currently processing the root tag.\n     */\n    onTagResource(tag, activeTag, parentTag, rootTag) {\n        activeTag.childrenParseType = ParseType.PROPERTY;\n        // Assume that the current node is a _typed_ node (2.13), unless we find an rdf:Description as node name\n        let typedNode = true;\n        if (tag.uri === RdfXmlParser.RDF) {\n            // Check forbidden property element names\n            if (!rootTag && RdfXmlParser.FORBIDDEN_NODE_ELEMENTS.indexOf(tag.local) >= 0) {\n                throw this.newParseError(`Illegal node element name: ${tag.local}`);\n            }\n            switch (tag.local) {\n                case 'RDF':\n                    // Tags under <rdf:RDF> must always be resources\n                    activeTag.childrenParseType = ParseType.RESOURCE;\n                case 'Description':\n                    typedNode = false;\n            }\n        }\n        const predicates = [];\n        const objects = [];\n        // Collect all attributes as triples\n        // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n        let activeSubjectValue = null;\n        let claimSubjectNodeId = false;\n        let subjectValueBlank = false;\n        let explicitType = null;\n        for (const attributeKey in tag.attributes) {\n            const attribute = tag.attributes[attributeKey];\n            if (parentTag && attribute.uri === RdfXmlParser.RDF) {\n                switch (attribute.local) {\n                    case 'about':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        activeSubjectValue = attribute.value;\n                        continue;\n                    case 'ID':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        this.validateNcname(attribute.value);\n                        activeSubjectValue = '#' + attribute.value;\n                        claimSubjectNodeId = true;\n                        continue;\n                    case 'nodeID':\n                        if (activeSubjectValue) {\n                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, \\\nwhile ${attribute.value} and ${activeSubjectValue} where found.`);\n                        }\n                        this.validateNcname(attribute.value);\n                        activeSubjectValue = attribute.value;\n                        subjectValueBlank = true;\n                        continue;\n                    case 'bagID':\n                        throw this.newParseError(`rdf:bagID is not supported.`);\n                    case 'type':\n                        // Emit the rdf:type later as named node instead of the default literal\n                        explicitType = attribute.value;\n                        continue;\n                    case 'aboutEach':\n                        throw this.newParseError(`rdf:aboutEach is not supported.`);\n                    case 'aboutEachPrefix':\n                        throw this.newParseError(`rdf:aboutEachPrefix is not supported.`);\n                    case 'li':\n                        throw this.newParseError(`rdf:li on node elements are not supported.`);\n                }\n            }\n            else if (attribute.uri === RdfXmlParser.XML) {\n                if (attribute.local === 'lang') {\n                    activeTag.language = attribute.value === '' ? null : attribute.value.toLowerCase();\n                    continue;\n                }\n                else if (attribute.local === 'base') {\n                    // SAX Parser does not expand xml:base, based on DOCTYPE, so we have to do it manually\n                    activeTag.baseIRI = (0, relative_to_absolute_iri_1.resolve)(attribute.value, activeTag.baseIRI);\n                    continue;\n                }\n            }\n            // Interpret attributes at this point as properties on this node,\n            // but we ignore attributes that have no prefix or known expanded URI\n            if (attribute.prefix !== 'xml' && attribute.prefix !== 'xmlns'\n                && (attribute.prefix !== '' || attribute.local !== 'xmlns')\n                && attribute.uri) {\n                predicates.push(this.uriToNamedNode(attribute.uri + attribute.local));\n                objects.push(attribute.value);\n            }\n        }\n        // Create the subject value _after_ all attributes have been processed\n        if (activeSubjectValue !== null) {\n            activeTag.subject = subjectValueBlank\n                ? this.dataFactory.blankNode(activeSubjectValue) : this.valueToUri(activeSubjectValue, activeTag);\n            if (claimSubjectNodeId) {\n                this.claimNodeId(activeTag.subject);\n            }\n        }\n        // Force the creation of a subject if it doesn't exist yet\n        if (!activeTag.subject) {\n            activeTag.subject = this.dataFactory.blankNode();\n        }\n        // Emit the type if we're at a typed node\n        if (typedNode) {\n            const type = this.uriToNamedNode(tag.uri + tag.local);\n            this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), type, parentTag ? parentTag.reifiedStatementId : null);\n        }\n        if (parentTag) {\n            // If the parent tag defined a predicate, add the current tag as property value\n            if (parentTag.predicate) {\n                if (parentTag.childrenCollectionSubject) {\n                    // RDF:List-based properties\n                    const linkTerm = this.dataFactory.blankNode();\n                    // Emit <x> <p> <current-chain> OR <previous-chain> <rdf:rest> <current-chain>\n                    this.emitTriple(parentTag.childrenCollectionSubject, parentTag.childrenCollectionPredicate, linkTerm, parentTag.reifiedStatementId);\n                    // Emit <current-chain> <rdf:first> value\n                    this.emitTriple(linkTerm, this.dataFactory.namedNode(RdfXmlParser.RDF + 'first'), activeTag.subject, activeTag.reifiedStatementId);\n                    // Store <current-chain> in the parent node\n                    parentTag.childrenCollectionSubject = linkTerm;\n                    parentTag.childrenCollectionPredicate = this.dataFactory.namedNode(RdfXmlParser.RDF + 'rest');\n                }\n                else { // !parentTag.predicateEmitted\n                    // Set-based properties\n                    this.emitTriple(parentTag.subject, parentTag.predicate, activeTag.subject, parentTag.reifiedStatementId);\n                    // Emit pending properties on the parent tag that had no defined subject yet.\n                    for (let i = 0; i < parentTag.predicateSubPredicates.length; i++) {\n                        this.emitTriple(activeTag.subject, parentTag.predicateSubPredicates[i], parentTag.predicateSubObjects[i], null);\n                    }\n                    // Cleanup so we don't emit them again when the parent tag is closed\n                    parentTag.predicateSubPredicates = [];\n                    parentTag.predicateSubObjects = [];\n                    parentTag.predicateEmitted = true;\n                }\n            }\n            // Emit all collected triples\n            for (let i = 0; i < predicates.length; i++) {\n                const object = this.dataFactory.literal(objects[i], activeTag.datatype || activeTag.language);\n                this.emitTriple(activeTag.subject, predicates[i], object, parentTag.reifiedStatementId);\n            }\n            // Emit the rdf:type as named node instead of literal\n            if (explicitType) {\n                this.emitTriple(activeTag.subject, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), this.uriToNamedNode(explicitType), null);\n            }\n        }\n    }\n    /**\n     * Handle the given property element in property-mode.\n     * @param {SaxesTagNS} tag A SAX tag.\n     * @param {IActiveTag} activeTag The currently active tag.\n     * @param {IActiveTag} parentTag The parent tag or null.\n     */\n    onTagProperty(tag, activeTag, parentTag) {\n        activeTag.childrenParseType = ParseType.RESOURCE;\n        activeTag.subject = parentTag.subject; // Inherit parent subject\n        if (tag.uri === RdfXmlParser.RDF && tag.local === 'li') {\n            // Convert rdf:li to rdf:_x\n            if (!parentTag.listItemCounter) {\n                parentTag.listItemCounter = 1;\n            }\n            activeTag.predicate = this.uriToNamedNode(tag.uri + '_' + parentTag.listItemCounter++);\n        }\n        else {\n            activeTag.predicate = this.uriToNamedNode(tag.uri + tag.local);\n        }\n        // Check forbidden property element names\n        if (tag.uri === RdfXmlParser.RDF\n            && RdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS.indexOf(tag.local) >= 0) {\n            throw this.newParseError(`Illegal property element name: ${tag.local}`);\n        }\n        activeTag.predicateSubPredicates = [];\n        activeTag.predicateSubObjects = [];\n        let parseType = false;\n        let attributedProperty = false;\n        // Collect all attributes as triples\n        // Assign subject value only after all attributes have been processed, because baseIRI may change the final val\n        let activeSubSubjectValue = null;\n        let subSubjectValueBlank = true;\n        const predicates = [];\n        const objects = [];\n        for (const propertyAttributeKey in tag.attributes) {\n            const propertyAttribute = tag.attributes[propertyAttributeKey];\n            if (propertyAttribute.uri === RdfXmlParser.RDF) {\n                switch (propertyAttribute.local) {\n                    case 'resource':\n                        if (activeSubSubjectValue) {\n                            throw this.newParseError(`Found both rdf:resource (${propertyAttribute.value}) and rdf:nodeID (${activeSubSubjectValue}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:resource (${propertyAttribute.value})`);\n                        }\n                        activeTag.hadChildren = true;\n                        activeSubSubjectValue = propertyAttribute.value;\n                        subSubjectValueBlank = false;\n                        continue;\n                    case 'datatype':\n                        if (attributedProperty) {\n                            throw this.newParseError(`Found both non-rdf:* property attributes and rdf:datatype (${propertyAttribute.value}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${propertyAttribute.value})`);\n                        }\n                        activeTag.datatype = this.valueToUri(propertyAttribute.value, activeTag);\n                        continue;\n                    case 'nodeID':\n                        if (attributedProperty) {\n                            throw this.newParseError(`Found both non-rdf:* property attributes and rdf:nodeID (${propertyAttribute.value}).`);\n                        }\n                        if (activeTag.hadChildren) {\n                            throw this.newParseError(`Found both rdf:resource and rdf:nodeID (${propertyAttribute.value}).`);\n                        }\n                        if (parseType) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID (${propertyAttribute.value})`);\n                        }\n                        this.validateNcname(propertyAttribute.value);\n                        activeTag.hadChildren = true;\n                        activeSubSubjectValue = propertyAttribute.value;\n                        subSubjectValueBlank = true;\n                        continue;\n                    case 'bagID':\n                        throw this.newParseError(`rdf:bagID is not supported.`);\n                    case 'parseType':\n                        // Validation\n                        if (attributedProperty) {\n                            throw this.newParseError(`rdf:parseType is not allowed when non-rdf:* property attributes are present`);\n                        }\n                        if (activeTag.datatype) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${activeTag.datatype.value})`);\n                        }\n                        if (activeSubSubjectValue) {\n                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID or rdf:resource (${activeSubSubjectValue})`);\n                        }\n                        if (propertyAttribute.value === 'Resource') {\n                            parseType = true;\n                            activeTag.childrenParseType = ParseType.PROPERTY;\n                            // Turn this property element into a node element\n                            const nestedBNode = this.dataFactory.blankNode();\n                            this.emitTriple(activeTag.subject, activeTag.predicate, nestedBNode, activeTag.reifiedStatementId);\n                            activeTag.subject = nestedBNode;\n                            activeTag.predicate = null;\n                        }\n                        else if (propertyAttribute.value === 'Collection') {\n                            parseType = true;\n                            // Interpret children as being part of an rdf:List\n                            activeTag.hadChildren = true;\n                            activeTag.childrenCollectionSubject = activeTag.subject;\n                            activeTag.childrenCollectionPredicate = activeTag.predicate;\n                            subSubjectValueBlank = false;\n                        }\n                        else if (propertyAttribute.value === 'Literal') {\n                            parseType = true;\n                            // Interpret children as being part of a literal string\n                            activeTag.childrenTagsToString = true;\n                            activeTag.childrenStringTags = [];\n                        }\n                        continue;\n                    case 'ID':\n                        this.validateNcname(propertyAttribute.value);\n                        activeTag.reifiedStatementId = this.valueToUri('#' + propertyAttribute.value, activeTag);\n                        this.claimNodeId(activeTag.reifiedStatementId);\n                        continue;\n                }\n            }\n            else if (propertyAttribute.uri === RdfXmlParser.XML && propertyAttribute.local === 'lang') {\n                activeTag.language = propertyAttribute.value === ''\n                    ? null : propertyAttribute.value.toLowerCase();\n                continue;\n            }\n            // Interpret attributes at this point as properties via implicit blank nodes on the property,\n            // but we ignore attributes that have no prefix or known expanded URI\n            if (propertyAttribute.prefix !== 'xml' && propertyAttribute.prefix !== 'xmlns'\n                && (propertyAttribute.prefix !== '' || propertyAttribute.local !== 'xmlns')\n                && propertyAttribute.uri) {\n                if (parseType || activeTag.datatype) {\n                    throw this.newParseError(`Found illegal rdf:* properties on property element with attribute: ${propertyAttribute.value}`);\n                }\n                activeTag.hadChildren = true;\n                attributedProperty = true;\n                predicates.push(this.uriToNamedNode(propertyAttribute.uri + propertyAttribute.local));\n                objects.push(this.dataFactory.literal(propertyAttribute.value, activeTag.datatype || activeTag.language));\n            }\n        }\n        // Create the subject value _after_ all attributes have been processed\n        if (activeSubSubjectValue !== null) {\n            const subjectParent = activeTag.subject;\n            activeTag.subject = subSubjectValueBlank\n                ? this.dataFactory.blankNode(activeSubSubjectValue) : this.valueToUri(activeSubSubjectValue, activeTag);\n            this.emitTriple(subjectParent, activeTag.predicate, activeTag.subject, activeTag.reifiedStatementId);\n            // Emit our buffered triples\n            for (let i = 0; i < predicates.length; i++) {\n                this.emitTriple(activeTag.subject, predicates[i], objects[i], null);\n            }\n            activeTag.predicateEmitted = true;\n        }\n        else if (subSubjectValueBlank) {\n            // The current property element has no defined subject\n            // Let's buffer the properties until the child node defines a subject,\n            // or if the tag closes.\n            activeTag.predicateSubPredicates = predicates;\n            activeTag.predicateSubObjects = objects;\n            activeTag.predicateEmitted = false;\n        }\n    }\n    /**\n     * Emit the given triple to the stream.\n     * @param {Term} subject A subject term.\n     * @param {Term} predicate A predicate term.\n     * @param {Term} object An object term.\n     * @param {Term} statementId An optional resource that identifies the triple.\n     *                           If truthy, then the given triple will also be emitted reified.\n     */\n    emitTriple(subject, predicate, object, statementId) {\n        this.push(this.dataFactory.quad(subject, predicate, object, this.defaultGraph));\n        // Reify triple\n        if (statementId) {\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'type'), this.dataFactory.namedNode(RdfXmlParser.RDF + 'Statement'), this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'subject'), subject, this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'predicate'), predicate, this.defaultGraph));\n            this.push(this.dataFactory.quad(statementId, this.dataFactory.namedNode(RdfXmlParser.RDF + 'object'), object, this.defaultGraph));\n        }\n    }\n    /**\n     * Register the given term as a node ID.\n     * If one was already registered, this will emit an error.\n     *\n     * This is used to check duplicate occurrences of rdf:ID in scope of the baseIRI.\n     * @param {Term} term An RDF term.\n     */\n    claimNodeId(term) {\n        if (!this.allowDuplicateRdfIds) {\n            if (this.nodeIds[term.value]) {\n                throw this.newParseError(`Found multiple occurrences of rdf:ID='${term.value}'.`);\n            }\n            this.nodeIds[term.value] = true;\n        }\n    }\n    /**\n     * Handle the given text string.\n     * @param {string} text A parsed text string.\n     */\n    onText(text) {\n        const activeTag = this.activeTagStack.length\n            ? this.activeTagStack[this.activeTagStack.length - 1] : null;\n        if (activeTag) {\n            if (activeTag.childrenStringTags) {\n                activeTag.childrenStringTags.push(text);\n            }\n            else if (activeTag.predicate) {\n                activeTag.text = text;\n            }\n        }\n    }\n    /**\n     * Handle the closing of the last tag.\n     */\n    onCloseTag() {\n        const poppedTag = this.activeTagStack.pop();\n        // If we were converting a tag to a string, and the tag was not self-closing, close it here.\n        if (poppedTag.childrenStringEmitClosingTag) {\n            poppedTag.childrenStringTags.push(poppedTag.childrenStringEmitClosingTag);\n        }\n        // Set the literal value if we were collecting XML tags to string\n        if (poppedTag.childrenTagsToString) {\n            poppedTag.datatype = this.dataFactory.namedNode(RdfXmlParser.RDF + 'XMLLiteral');\n            poppedTag.text = poppedTag.childrenStringTags.join('');\n            poppedTag.hadChildren = false; // Force a literal triple to be emitted hereafter\n        }\n        if (poppedTag.childrenCollectionSubject) {\n            // Terminate the rdf:List\n            this.emitTriple(poppedTag.childrenCollectionSubject, poppedTag.childrenCollectionPredicate, this.dataFactory.namedNode(RdfXmlParser.RDF + 'nil'), poppedTag.reifiedStatementId);\n        }\n        else if (poppedTag.predicate) {\n            if (!poppedTag.hadChildren && poppedTag.childrenParseType !== ParseType.PROPERTY) {\n                // Property element contains text\n                this.emitTriple(poppedTag.subject, poppedTag.predicate, this.dataFactory.literal(poppedTag.text || '', poppedTag.datatype || poppedTag.language), poppedTag.reifiedStatementId);\n            }\n            else if (!poppedTag.predicateEmitted) {\n                // Emit remaining properties on an anonymous property element\n                const subject = this.dataFactory.blankNode();\n                this.emitTriple(poppedTag.subject, poppedTag.predicate, subject, poppedTag.reifiedStatementId);\n                for (let i = 0; i < poppedTag.predicateSubPredicates.length; i++) {\n                    this.emitTriple(subject, poppedTag.predicateSubPredicates[i], poppedTag.predicateSubObjects[i], null);\n                }\n            }\n        }\n    }\n    /**\n     * Fetch local DOCTYPE ENTITY's and make the parser recognise them.\n     * @param {string} doctype The read doctype.\n     */\n    onDoctype(doctype) {\n        doctype.replace(/<!ENTITY\\s+([^\\s]+)\\s+[\"']([^\"']+)[\"']\\s*>/g, (match, prefix, uri) => {\n            this.saxParser.ENTITIES[prefix] = uri;\n            return '';\n        });\n    }\n}\nexports.RdfXmlParser = RdfXmlParser;\nRdfXmlParser.MIME_TYPE = 'application/rdf+xml';\nRdfXmlParser.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nRdfXmlParser.XML = 'http://www.w3.org/XML/1998/namespace';\nRdfXmlParser.FORBIDDEN_NODE_ELEMENTS = [\n    'RDF',\n    'ID',\n    'about',\n    'bagID',\n    'parseType',\n    'resource',\n    'nodeID',\n    'li',\n    'aboutEach',\n    'aboutEachPrefix',\n];\nRdfXmlParser.FORBIDDEN_PROPERTY_ELEMENTS = [\n    'Description',\n    'RDF',\n    'ID',\n    'about',\n    'bagID',\n    'parseType',\n    'resource',\n    'nodeID',\n    'aboutEach',\n    'aboutEachPrefix',\n];\n// tslint:disable-next-line:max-line-length\nRdfXmlParser.NCNAME_MATCHER = /^([A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\u{F8}-\\u{2FF}\\u{370}-\\u{37D}\\u{37F}-\\u{1FFF}\\u{200C}-\\u{200D}\\u{2070}-\\u{218F}\\u{2C00}-\\u{2FEF}\\u{3001}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFFD}\\u{10000}-\\u{EFFFF}_])([A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\u{F8}-\\u{2FF}\\u{370}-\\u{37D}\\u{37F}-\\u{1FFF}\\u{200C}-\\u{200D}\\u{2070}-\\u{218F}\\u{2C00}-\\u{2FEF}\\u{3001}-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFFD}\\u{10000}-\\u{EFFFF}_\\-.0-9#xB7\\u{0300}-\\u{036F}\\u{203F}-\\u{2040}])*$/u;\nvar ParseType;\n(function (ParseType) {\n    ParseType[ParseType[\"RESOURCE\"] = 0] = \"RESOURCE\";\n    ParseType[ParseType[\"PROPERTY\"] = 1] = \"PROPERTY\";\n})(ParseType || (exports.ParseType = ParseType = {}));\n//# sourceMappingURL=RdfXmlParser.js.map"],"names":["CustomRdfXmlParser","RdfXmlParser","constructor","factory","args","super","dataFactory","__createBinding","this","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__exportStar","exports","p","prototype","hasOwnProperty","call","value","resolve","relativeIRI","baseIRI","baseFragmentPos","indexOf","substr","length","Error","startsWith","baseQueryPos","relativeColonPos","removeDotSegmentsOfPath","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","removeDotSegments","baseIRIPath","baseIRILastSlashPos","lastIndexOf","path","segmentBuffers","i","isCharacterAllowedAfterRelativePathSegment","push","pop","map","buffer","join","iri","colonPosition","searchOffset","pathSeparator","base","character","ParseError","parser","message","saxParser","trackPosition","line","column","CHAR","S","NAME_START_CHAR","NAME_CHAR","CHAR_RE","RegExp","S_RE","NAME_START_CHAR_RE","NAME_CHAR_RE","NAME_RE","NMTOKEN_RE","TAB","NL","CR","SPACE","isChar","c","isS","isNameStartChar","isNameChar","S_LIST","buildAbsoluteIriRfc3987Regex","sub_delims_raw","sub_delims","pct_encoded","dec_octet","ipv4address","h16","ls32","ipv6address","ipvfuture","ip_literal","port","scheme","iprivate_raw","iprivate","ucschar_raw","iunreserved_raw","iunreserved","ipchar","ifragment","iquery","isegment_nz","isegment","ipath_empty","ipath_rootless","ipath_absolute","ipath_abempty","ireg_name","ihost","iuserinfo","iauthority","ihier_part","validateIri","IriValidationStrategy","STRICT_IRI_REGEX","PRAGMATIC_IRI_REGEX","strategy","Strict","test","Pragmatic","None","Quad","subject","predicate","object","graph","termType","equals","other","NamedNode","BlankNode","SaxesParser","EVENTS","ed5","ed2","NSed3","isChar10","isChar11","isNCNameStartChar","isNCNameChar","NC_NAME_RE","XML_NAMESPACE","XMLNS_NAMESPACE","rootNS","__proto__","xml","xmlns","XML_ENTITIES","amp","gt","lt","quot","apos","EOC","NL_LIKE","S_BEGIN","S_BEGIN_WHITESPACE","S_DOCTYPE","S_DOCTYPE_QUOTE","S_DTD","S_DTD_QUOTED","S_DTD_OPEN_WAKA","S_DTD_OPEN_WAKA_BANG","S_DTD_COMMENT","S_DTD_COMMENT_ENDING","S_DTD_COMMENT_ENDED","S_DTD_PI","S_DTD_PI_ENDING","S_TEXT","S_ENTITY","S_OPEN_WAKA","S_OPEN_WAKA_BANG","S_COMMENT","S_COMMENT_ENDING","S_COMMENT_ENDED","S_CDATA","S_CDATA_ENDING","S_CDATA_ENDING_2","S_PI_FIRST_CHAR","S_PI_REST","S_PI_BODY","S_PI_ENDING","S_XML_DECL_NAME_START","S_XML_DECL_NAME","S_XML_DECL_EQ","S_XML_DECL_VALUE_START","S_XML_DECL_VALUE","S_XML_DECL_SEPARATOR","S_XML_DECL_ENDING","S_OPEN_TAG","S_OPEN_TAG_SLASH","S_ATTRIB","S_ATTRIB_NAME","S_ATTRIB_NAME_SAW_WHITE","S_ATTRIB_VALUE","S_ATTRIB_VALUE_QUOTED","S_ATTRIB_VALUE_CLOSED","S_ATTRIB_VALUE_UNQUOTED","S_CLOSE_TAG","S_CLOSE_TAG_SAW_WHITE","BANG","DQUOTE","AMP","SQUOTE","MINUS","FORWARD_SLASH","SEMICOLON","LESS","EQUAL","GREATER","QUESTION","OPEN_BRACKET","CLOSE_BRACKET","NEL","LS","isQuote","QUOTES","DOCTYPE_TERMINATOR","DTD_TERMINATOR","XML_DECL_NAME_TERMINATOR","ATTRIB_VALUE_UNQUOTED_TERMINATOR","nsPairCheck","prefix","uri","fail","nsMappingCheck","mapping","local","keys","isNCName","name","isName","FORBIDDEN_START","FORBIDDEN_BRACKET","FORBIDDEN_BRACKET_BRACKET","EVENT_NAME_TO_HANDLER_NAME","xmldecl","text","processinginstruction","doctype","comment","opentagstart","attribute","opentag","closetag","cdata","error","end","ready","closed","_closed","opt","fragmentOpt","fragment","xmlnsOpt","position","fileName","nameStartCheck","nameCheck","processAttribs","processAttribsNS","pushAttrib","pushAttribNS","ns","assign","additional","additionalNamespaces","processAttribsPlain","pushAttribPlain","stateTable","sBegin","sBeginWhitespace","sDoctype","sDoctypeQuote","sDTD","sDTDQuoted","sDTDOpenWaka","sDTDOpenWakaBang","sDTDComment","sDTDCommentEnding","sDTDCommentEnded","sDTDPI","sDTDPIEnding","sText","sEntity","sOpenWaka","sOpenWakaBang","sComment","sCommentEnding","sCommentEnded","sCData","sCDataEnding","sCDataEnding2","sPIFirstChar","sPIRest","sPIBody","sPIEnding","sXMLDeclNameStart","sXMLDeclName","sXMLDeclEq","sXMLDeclValueStart","sXMLDeclValue","sXMLDeclSeparator","sXMLDeclEnding","sOpenTag","sOpenTagSlash","sAttrib","sAttribName","sAttribNameSawWhite","sAttribValue","sAttribValueQuoted","sAttribValueClosed","sAttribValueUnquoted","sCloseTag","sCloseTagSawWhite","_init","_a","openWakaBang","piTarget","entity","q","tags","tag","topNS","chunk","chunkPosition","prevI","carriedFromPrevious","forbiddenState","attribList","state","reportedTextBeforeRoot","reportedTextAfterRoot","closedRoot","sawRoot","xmlDeclPossible","xmlDeclExpects","entityReturnState","defaultXMLVersion","forceXMLVersion","setXMLVersion","positionAtNewLine","xmlDecl","version","encoding","standalone","ENTITIES","readyHandler","columnIndex","on","handler","off","makeError","msg","err","errorHandler","write","toString","limit","lastCode","charCodeAt","slice","close","getCode10","code","final","getCode11","next","getCodeNorm","getCode","unget","captureTo","chars","start","isNLLike","includes","captureToChar","char","captureNameChars","skipSpaces","currentXMLVersion","iBefore","doctypeHandler","String","fromCodePoint","owb","handleTextInRoot","handleTextOutsideRoot","loop","parsed","parseEntity","textHandler","commentHandler","cdataHandler","isQuestion","toLowerCase","piHandler","target","body","xmldeclHandler","attributes","openTagStartHandler","openTag","openSelfClosingTag","closeTag","scanLoop","nonSpace","outRootLoop","qname","attr","attributeHandler","trimmed","trim","_b","endHandler","index","resolvePrefix","colon","JSON","stringify","seen","Set","eqname","has","add","isSelfClosing","openTagHandler","_c","closeTagHandler","top","l","defined","num","NaN","parseInt","NC_NAME_START_CHAR","NC_NAME_CHAR","NC_NAME_START_CHAR_RE","NC_NAME_CHAR_RE","Literal","NamedNode_1","languageOrDatatype","language","datatype","RDF_LANGUAGE_STRING","XSD_STRING","RESTRICTED_CHAR","RESTRICTED_CHAR_RE","isRestrictedChar","isCharAndNotRestricted","Variable","DataFactory","BlankNode_1","DefaultGraph_1","Literal_1","Quad_1","Variable_1","dataFactoryCounter","options","blankNodeCounter","blankNodePrefix","namedNode","blankNode","literal","variable","defaultGraph","DefaultGraph","INSTANCE","quad","fromTerm","original","fromQuad","resetBlankNodeCounter","ParseType","relative_to_absolute_iri_1","saxes_1","readable_stream_1","ParseError_1","rdf_data_factory_1","validate_iri_1","Transform","readableObjectMode","activeTagStack","nodeIds","validateUri","iriValidationStrategy","attachSaxListeners","import","stream","output","PassThrough","emit","data","pipe","_transform","callback","e","newParseError","valueToUri","activeTag","uriToNamedNode","uriValidationResult","validateNcname","NCNAME_MATCHER","onTag","bind","onText","onCloseTag","onDoctype","parentTag","currentParseType","RESOURCE","hadChildren","childrenParseType","childrenStringTags","tagName","attributeKey","tagContents","tagString","stringActiveTag","childrenStringEmitClosingTag","onTagResource","onTagProperty","rootTag","PROPERTY","typedNode","RDF","FORBIDDEN_NODE_ELEMENTS","predicates","objects","activeSubjectValue","claimSubjectNodeId","subjectValueBlank","explicitType","XML","claimNodeId","type","emitTriple","reifiedStatementId","childrenCollectionSubject","linkTerm","childrenCollectionPredicate","predicateSubPredicates","predicateSubObjects","predicateEmitted","listItemCounter","FORBIDDEN_PROPERTY_ELEMENTS","parseType","attributedProperty","activeSubSubjectValue","subSubjectValueBlank","propertyAttributeKey","propertyAttribute","nestedBNode","childrenTagsToString","subjectParent","statementId","term","allowDuplicateRdfIds","poppedTag","replace","match","MIME_TYPE"],"sourceRoot":""}