{"version":3,"file":"js/159.0575a0bf.js","mappings":"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","sources":["webpack://mobilitydcatap-ui/./node_modules/canonicalize/lib/canonicalize.js","webpack://mobilitydcatap-ui/./node_modules/cross-fetch/dist/browser-polyfill.js","webpack://mobilitydcatap-ui/./node_modules/http-link-header/lib/link.js","webpack://mobilitydcatap-ui/./node_modules/jsonld-context-parser/index.js","webpack://mobilitydcatap-ui/./node_modules/jsonld-context-parser/lib/ContextParser.js","webpack://mobilitydcatap-ui/./node_modules/jsonld-context-parser/lib/ErrorCoded.js","webpack://mobilitydcatap-ui/./node_modules/jsonld-context-parser/lib/FetchDocumentLoader.js","webpack://mobilitydcatap-ui/./node_modules/jsonld-context-parser/lib/IDocumentLoader.js","webpack://mobilitydcatap-ui/./node_modules/jsonld-context-parser/lib/JsonLdContext.js","webpack://mobilitydcatap-ui/./node_modules/jsonld-context-parser/lib/JsonLdContextNormalized.js","webpack://mobilitydcatap-ui/./node_modules/jsonld-context-parser/lib/Util.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/index.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/BlankNode.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/DataFactory.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/DefaultGraph.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/Literal.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/NamedNode.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/Quad.js","webpack://mobilitydcatap-ui/./node_modules/rdf-data-factory/lib/Variable.js","webpack://mobilitydcatap-ui/./node_modules/relative-to-absolute-iri/index.js","webpack://mobilitydcatap-ui/./node_modules/relative-to-absolute-iri/lib/Resolve.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* jslint node: true */\n'use strict';\n\nmodule.exports = function serialize (object) {\n  if (object === null || typeof object !== 'object' || object.toJSON != null) {\n    return JSON.stringify(object);\n  }\n\n  if (Array.isArray(object)) {\n    return '[' + object.reduce((t, cv, ci) => {\n      const comma = ci === 0 ? '' : ',';\n      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;\n      return t + comma + serialize(value);\n    }, '') + ']';\n  }\n\n  return '{' + Object.keys(object).sort().reduce((t, cv, ci) => {\n    if (object[cv] === undefined ||\n        typeof object[cv] === 'symbol') {\n      return t;\n    }\n    const comma = t.length === 0 ? '' : ',';\n    return t + comma + serialize(cv) + ':' + serialize(object[cv]);\n  }, '') + '}';\n};\n","(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(typeof self !== 'undefined' ? self : this);\n","'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value ) ||\n    !TOKEN_PATTERN.test( value )\n}\n\n/**\n * Shallow compares two objects to check if their properties match.\n * @param {object} object1 First object to compare.\n * @param {object} object2 Second object to compare.\n * @returns {boolean} Do the objects have matching properties.\n */\nfunction shallowCompareObjects( object1, object2 ) {\n  return (\n    Object.keys( object1 ).length === Object.keys( object2 ).length &&\n    Object.keys( object1 ).every(\n      ( key ) => key in object2 && object1[ key ] === object2[ key ]\n    )\n  );\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n    var type = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ].rel === 'string' && this.refs[ i ].rel.toLowerCase() === type ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n    value = value.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ][ attr ] === 'string' && this.refs[ i ][ attr ].toLowerCase() === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /** Sets a reference. */\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  /**\n   * Sets a reference if a reference with similar properties isnt already set.\n   */\n  setUnique( link ) {\n\n    if( !this.refs.some(( ref ) => shallowCompareObjects( ref, link )) ) {\n      this.refs.push( link )\n    }\n\n    return this\n\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n    value = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ][ attr ] === 'string' && this.refs[ i ][ attr ].toLowerCase() === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          if( ref != null ) {\n            ref.rel != null ?\n              this.refs.push( ...Link.expandRelations( ref ) ) :\n              this.refs.push( ref )\n          }\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          // this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) end = value.indexOf( ';', offset )\n        if( end === -1 ) end = value.length\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    if( ref != null ) {\n      ref.rel != null ?\n        this.refs.push( ...Link.expandRelations( ref ) ) :\n        this.refs.push( ref )\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\nLink.expandRelations = function( ref ) {\n  var rels = ref.rel.split( ' ' )\n  return rels.map( function( rel ) {\n    var value = Object.assign( {}, ref )\n    value.rel = rel\n    return value\n  })\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/ContextParser\"), exports);\n__exportStar(require(\"./lib/ErrorCoded\"), exports);\n__exportStar(require(\"./lib/FetchDocumentLoader\"), exports);\n__exportStar(require(\"./lib/IDocumentLoader\"), exports);\n__exportStar(require(\"./lib/JsonLdContext\"), exports);\n__exportStar(require(\"./lib/JsonLdContextNormalized\"), exports);\n__exportStar(require(\"./lib/Util\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextParser = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst FetchDocumentLoader_1 = require(\"./FetchDocumentLoader\");\nconst JsonLdContextNormalized_1 = require(\"./JsonLdContextNormalized\");\nconst Util_1 = require(\"./Util\");\n/**\n * Parses JSON-LD contexts.\n */\nclass ContextParser {\n    constructor(options) {\n        options = options || {};\n        this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();\n        this.documentCache = {};\n        this.validateContext = !options.skipValidation;\n        this.expandContentTypeToBase = !!options.expandContentTypeToBase;\n        this.remoteContextsDepthLimit = options.remoteContextsDepthLimit || 32;\n        this.redirectSchemaOrgHttps = 'redirectSchemaOrgHttps' in options ? !!options.redirectSchemaOrgHttps : true;\n    }\n    /**\n     * Validate the given @language value.\n     * An error will be thrown if it is invalid.\n     * @param value An @language value.\n     * @param {boolean} strictRange If the string value should be strictly checked against a regex.\n     * @param {string} errorCode The error code to emit on errors.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateLanguage(value, strictRange, errorCode) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(value)}'`, errorCode);\n        }\n        if (!Util_1.Util.REGEX_LANGUAGE_TAG.test(value)) {\n            if (strictRange) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(value)}'`, errorCode);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate the given @direction value.\n     * An error will be thrown if it is invalid.\n     * @param value An @direction value.\n     * @param {boolean} strictValues If the string value should be strictly checked against a regex.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateDirection(value, strictValues) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n        }\n        if (!Util_1.Util.REGEX_DIRECTION_TAG.test(value)) {\n            if (strictValues) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Add an @id term for all @reverse terms.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     */\n    idifyReverseTerms(context) {\n        for (const key of Object.keys(context)) {\n            let value = context[key];\n            if (value && typeof value === 'object') {\n                if (value['@reverse'] && !value['@id']) {\n                    if (typeof value['@reverse'] !== 'string' || Util_1.Util.isValidKeyword(value['@reverse'])) {\n                        throw new ErrorCoded_1.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${value['@reverse']}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                    }\n                    value = context[key] = Object.assign(Object.assign({}, value), { '@id': value['@reverse'] });\n                    value['@id'] = value['@reverse'];\n                    if (Util_1.Util.isPotentialKeyword(value['@reverse'])) {\n                        delete value['@reverse'];\n                    }\n                    else {\n                        value['@reverse'] = true;\n                    }\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Expand all prefixed terms in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded\n     *                                          via @base if @vocab is set to null.\n     * @param {string[]} keys Optional set of keys from the context to expand. If left undefined, all\n     * keys in the context will be expanded.\n     */\n    expandPrefixedTerms(context, expandContentTypeToBase, keys) {\n        const contextRaw = context.getContextRaw();\n        for (const key of (keys || Object.keys(contextRaw))) {\n            // Only expand allowed keys\n            if (Util_1.Util.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0 && !Util_1.Util.isReservedInternalKeyword(key)) {\n                // Error if we try to alias a keyword to something else.\n                const keyValue = contextRaw[key];\n                if (Util_1.Util.isPotentialKeyword(key) && Util_1.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(key) >= 0) {\n                    if (key !== '@type' || typeof contextRaw[key] === 'object'\n                        && !(contextRaw[key]['@protected'] || contextRaw[key]['@container'] === '@set')) {\n                        throw new ErrorCoded_1.ErrorCoded(`Keywords can not be aliased to something else.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                    }\n                }\n                // Error if we try to alias to an illegal keyword\n                if (Util_1.Util.ALIAS_RANGE_BLACKLIST.indexOf(Util_1.Util.getContextValueId(keyValue)) >= 0) {\n                    throw new ErrorCoded_1.ErrorCoded(`Aliasing to certain keywords is not allowed.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.INVALID_KEYWORD_ALIAS);\n                }\n                // Error if this term was marked as prefix as well\n                if (keyValue && Util_1.Util.isPotentialKeyword(Util_1.Util.getContextValueId(keyValue))\n                    && keyValue['@prefix'] === true) {\n                    throw new ErrorCoded_1.ErrorCoded(`Tried to use keyword aliases as prefix: '${key}': '${JSON.stringify(keyValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                // Loop because prefixes might be nested\n                while (Util_1.Util.isPrefixValue(contextRaw[key])) {\n                    const value = contextRaw[key];\n                    let changed = false;\n                    if (typeof value === 'string') {\n                        contextRaw[key] = context.expandTerm(value, true);\n                        changed = changed || value !== contextRaw[key];\n                    }\n                    else {\n                        const id = value['@id'];\n                        const type = value['@type'];\n                        // If @id is missing, don't allow @id to be added if @prefix: true and key not being a valid IRI.\n                        const canAddIdEntry = !('@prefix' in value) || Util_1.Util.isValidIri(key);\n                        if ('@id' in value) {\n                            // Use @id value for expansion\n                            if (id !== undefined && id !== null && typeof id === 'string') {\n                                contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { '@id': context.expandTerm(id, true) });\n                                changed = changed || id !== contextRaw[key]['@id'];\n                            }\n                        }\n                        else if (!Util_1.Util.isPotentialKeyword(key) && canAddIdEntry) {\n                            // Add an explicit @id value based on the expanded key value\n                            const newId = context.expandTerm(key, true);\n                            if (newId !== key) {\n                                // Don't set @id if expansion failed\n                                contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { '@id': newId });\n                                changed = true;\n                            }\n                        }\n                        if (type && typeof type === 'string' && type !== '@vocab'\n                            && (!value['@container'] || !value['@container']['@type'])\n                            && canAddIdEntry) {\n                            // First check @vocab, then fallback to @base\n                            let expandedType = context.expandTerm(type, true);\n                            if (expandContentTypeToBase && type === expandedType) {\n                                expandedType = context.expandTerm(type, false);\n                            }\n                            if (expandedType !== type) {\n                                changed = true;\n                                contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { '@type': expandedType });\n                            }\n                        }\n                    }\n                    if (!changed) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Normalize the @language entries in the given context to lowercase.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} parseOptions The parsing options.\n     */\n    normalize(context, { processingMode, normalizeLanguageTags }) {\n        // Lowercase language keys in 1.0\n        if (normalizeLanguageTags || processingMode === 1.0) {\n            for (const key of Object.keys(context)) {\n                if (key === '@language' && typeof context[key] === 'string') {\n                    context[key] = context[key].toLowerCase();\n                }\n                else {\n                    const value = context[key];\n                    if (value && typeof value === 'object') {\n                        if (typeof value['@language'] === 'string') {\n                            const lowercase = value['@language'].toLowerCase();\n                            if (lowercase !== value['@language']) {\n                                context[key] = Object.assign(Object.assign({}, value), { '@language': lowercase });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Convert all @container strings and array values to hash-based values.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     */\n    containersToHash(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (typeof value['@container'] === 'string') {\n                    context[key] = Object.assign(Object.assign({}, value), { '@container': { [value['@container']]: true } });\n                }\n                else if (Array.isArray(value['@container'])) {\n                    const newValue = {};\n                    for (const containerValue of value['@container']) {\n                        newValue[containerValue] = true;\n                    }\n                    context[key] = Object.assign(Object.assign({}, value), { '@container': newValue });\n                }\n            }\n        }\n    }\n    /**\n     * Normalize and apply context-level @protected terms onto each term separately.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {number} processingMode The processing mode.\n     */\n    applyScopedProtected(context, { processingMode }, expandOptions) {\n        if (processingMode && processingMode >= 1.1) {\n            if (context['@protected']) {\n                for (const key of Object.keys(context)) {\n                    if (Util_1.Util.isReservedInternalKeyword(key)) {\n                        continue;\n                    }\n                    if (!Util_1.Util.isPotentialKeyword(key) && !Util_1.Util.isTermProtected(context, key)) {\n                        const value = context[key];\n                        if (value && typeof value === 'object') {\n                            if (!('@protected' in context[key])) {\n                                // Mark terms with object values as protected if they don't have an @protected: false annotation\n                                context[key] = Object.assign(Object.assign({}, context[key]), { '@protected': true });\n                            }\n                        }\n                        else {\n                            // Convert string-based term values to object-based values with @protected: true\n                            context[key] = {\n                                '@id': value,\n                                '@protected': true,\n                            };\n                            if (Util_1.Util.isSimpleTermDefinitionPrefix(value, expandOptions)) {\n                                context[key] = Object.assign(Object.assign({}, context[key]), { '@prefix': true });\n                            }\n                        }\n                    }\n                }\n                delete context['@protected'];\n            }\n        }\n    }\n    /**\n     * Check if the given context inheritance does not contain any overrides of protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.\n     * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.\n     * @param {string[]} keys Optional set of keys from the context to validate. If left undefined, all\n     * keys defined in contextAfter will be checked.\n     */\n    validateKeywordRedefinitions(contextBefore, contextAfter, expandOptions, keys) {\n        for (const key of (keys !== null && keys !== void 0 ? keys : Object.keys(contextAfter))) {\n            if (Util_1.Util.isTermProtected(contextBefore, key)) {\n                // The entry in the context before will always be in object-mode\n                // If the new entry is in string-mode, convert it to object-mode\n                // before checking if it is identical.\n                if (typeof contextAfter[key] === 'string') {\n                    contextAfter[key] = { '@id': contextAfter[key], '@protected': true };\n                }\n                else {\n                    // We modify this deliberately,\n                    // as we need it for the value comparison (they must be identical modulo '@protected')),\n                    // and for the fact that this new value will override the first one.\n                    contextAfter[key] = Object.assign(Object.assign({}, contextAfter[key]), { '@protected': true });\n                }\n                // Error if they are not identical\n                if (!Util_1.Util.deepEqual(contextBefore[key], contextAfter[key])) {\n                    throw new ErrorCoded_1.ErrorCoded(`Attempted to override the protected keyword ${key} from ${JSON.stringify(Util_1.Util.getContextValueId(contextBefore[key]))} to ${JSON.stringify(Util_1.Util.getContextValueId(contextAfter[key]))}`, ErrorCoded_1.ERROR_CODES.PROTECTED_TERM_REDEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Validate the entries of the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options The parse options.\n     */\n    validate(context, { processingMode }) {\n        for (const key of Object.keys(context)) {\n            // Ignore reserved internal keywords.\n            if (Util_1.Util.isReservedInternalKeyword(key)) {\n                continue;\n            }\n            // Do not allow empty term\n            if (key === '') {\n                throw new ErrorCoded_1.ErrorCoded(`The empty term is not allowed, got: '${key}': '${JSON.stringify(context[key])}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n            }\n            const value = context[key];\n            const valueType = typeof value;\n            // First check if the key is a keyword\n            if (Util_1.Util.isPotentialKeyword(key)) {\n                switch (key.substr(1)) {\n                    case 'vocab':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @vocab IRI: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                        }\n                        break;\n                    case 'base':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @base IRI: ${context[key]}`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_IRI);\n                        }\n                        break;\n                    case 'language':\n                        if (value !== null) {\n                            ContextParser.validateLanguage(value, true, ErrorCoded_1.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);\n                        }\n                        break;\n                    case 'version':\n                        if (value !== null && valueType !== 'number') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @version number: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n                        }\n                        break;\n                    case 'direction':\n                        if (value !== null) {\n                            ContextParser.validateDirection(value, true);\n                        }\n                        break;\n                    case 'propagate':\n                        if (processingMode === 1.0) {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an illegal @propagate keyword: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                        }\n                        if (value !== null && valueType !== 'boolean') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @propagate value: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_PROPAGATE_VALUE);\n                        }\n                        break;\n                }\n                // Don't allow keywords to be overridden\n                if (Util_1.Util.isValidKeyword(key) && Util_1.Util.isValidKeyword(Util_1.Util.getContextValueId(value))) {\n                    throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${Util_1.Util\n                        .getContextValueId(value)}'`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                }\n                continue;\n            }\n            // Otherwise, consider the key a term\n            if (value !== null) {\n                switch (valueType) {\n                    case 'string':\n                        if (Util_1.Util.getPrefix(value, context) === key) {\n                            throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                        }\n                        if (Util_1.Util.isValidIriWeak(key)) {\n                            if (value === '@type') {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                            else if (Util_1.Util.isValidIri(value) && value !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                        }\n                        break;\n                    case 'object':\n                        if (!Util_1.Util.isCompactIri(key) && !('@id' in value)\n                            && (value['@type'] === '@id' ? !context['@base'] : !context['@vocab'])) {\n                            throw new ErrorCoded_1.ErrorCoded(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                        }\n                        for (const objectKey of Object.keys(value)) {\n                            const objectValue = value[objectKey];\n                            if (!objectValue) {\n                                continue;\n                            }\n                            switch (objectKey) {\n                                case '@id':\n                                    if (Util_1.Util.isValidKeyword(objectValue)\n                                        && objectValue !== '@type' && objectValue !== '@id' && objectValue !== '@graph' && objectValue !== '@nest') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.isValidIriWeak(key)) {\n                                        if (objectValue === '@type') {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                        else if (Util_1.Util.isValidIri(objectValue)\n                                            && objectValue !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected non-string @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.getPrefix(objectValue, context) === key) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                            .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                                    }\n                                    break;\n                                case '@type':\n                                    if (value['@container'] === '@type' && objectValue !== '@id' && objectValue !== '@vocab') {\n                                        throw new ErrorCoded_1.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (objectValue !== '@id' && objectValue !== '@vocab'\n                                        && (processingMode === 1.0 || objectValue !== '@json')\n                                        && (processingMode === 1.0 || objectValue !== '@none')\n                                        && (objectValue[0] === '_' || !Util_1.Util.isValidIri(objectValue))) {\n                                        throw new ErrorCoded_1.ErrorCoded(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    break;\n                                case '@reverse':\n                                    if (typeof objectValue === 'string' && value['@id'] && value['@id'] !== objectValue) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found non-matching @id and @reverse term values in '${key}':\\\n'${objectValue}' and '${value['@id']}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    if ('@nest' in value) {\n                                        throw new ErrorCoded_1.ErrorCoded(`@nest is not allowed in the reverse property '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    break;\n                                case '@container':\n                                    if (processingMode === 1.0) {\n                                        if (Object.keys(objectValue).length > 1\n                                            || Util_1.Util.CONTAINERS_1_0.indexOf(Object.keys(objectValue)[0]) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${Object.keys(objectValue)}') in 1.0, \\\nmust be only one of ${Util_1.Util.CONTAINERS_1_0.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    for (const containerValue of Object.keys(objectValue)) {\n                                        if (containerValue === '@list' && value['@reverse']) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                        }\n                                        if (Util_1.Util.CONTAINERS.indexOf(containerValue) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${containerValue}'), \\\nmust be one of ${Util_1.Util.CONTAINERS.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    break;\n                                case '@language':\n                                    ContextParser.validateLanguage(objectValue, true, ErrorCoded_1.ERROR_CODES.INVALID_LANGUAGE_MAPPING);\n                                    break;\n                                case '@direction':\n                                    ContextParser.validateDirection(objectValue, true);\n                                    break;\n                                case '@prefix':\n                                    if (objectValue !== null && typeof objectValue !== 'boolean') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @prefix boolean in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_PREFIX_VALUE);\n                                    }\n                                    if (!('@id' in value) && !Util_1.Util.isValidIri(key)) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Invalid @prefix definition for '${key}' ('${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@index':\n                                    if (processingMode === 1.0 || !value['@container'] || !value['@container']['@index']) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Attempt to add illegal key to value object: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@nest':\n                                    if (Util_1.Util.isPotentialKeyword(objectValue) && objectValue !== '@nest') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @nest value in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_NEST_VALUE);\n                                    }\n                            }\n                        }\n                        break;\n                    default:\n                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term value: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Apply the @base context entry to the given context under certain circumstances.\n     * @param context A context.\n     * @param options Parsing options.\n     * @param inheritFromParent If the @base value from the parent context can be inherited.\n     * @return The given context.\n     */\n    applyBaseEntry(context, options, inheritFromParent) {\n        // In some special cases, this can be a string, so ignore those.\n        if (typeof context === 'string') {\n            return context;\n        }\n        // Give priority to @base in the parent context\n        if (inheritFromParent && !('@base' in context) && options.parentContext\n            && typeof options.parentContext === 'object' && '@base' in options.parentContext) {\n            context['@base'] = options.parentContext['@base'];\n            if (options.parentContext['@__baseDocument']) {\n                context['@__baseDocument'] = true;\n            }\n        }\n        // Override the base IRI if provided.\n        if (options.baseIRI && !options.external) {\n            if (!('@base' in context)) {\n                // The context base is the document base\n                context['@base'] = options.baseIRI;\n                context['@__baseDocument'] = true;\n            }\n            else if (context['@base'] !== null && typeof context['@base'] === 'string'\n                && !Util_1.Util.isValidIri(context['@base'])) {\n                // The context base is relative to the document base\n                context['@base'] = (0, relative_to_absolute_iri_1.resolve)(context['@base'], options.parentContext && options.parentContext['@base'] || options.baseIRI);\n            }\n        }\n        return context;\n    }\n    /**\n     * Resolve relative context IRIs, or return full IRIs as-is.\n     * @param {string} contextIri A context IRI.\n     * @param {string} baseIRI A base IRI.\n     * @return {string} The normalized context IRI.\n     */\n    normalizeContextIri(contextIri, baseIRI) {\n        if (!Util_1.Util.isValidIri(contextIri)) {\n            try {\n                contextIri = (0, relative_to_absolute_iri_1.resolve)(contextIri, baseIRI);\n            }\n            catch (_a) {\n                throw new Error(`Invalid context IRI: ${contextIri}`);\n            }\n        }\n        // TODO: Temporary workaround for fixing schema.org CORS issues (https://github.com/schemaorg/schemaorg/issues/2578#issuecomment-652324465)\n        if (this.redirectSchemaOrgHttps && contextIri.startsWith('http://schema.org')) {\n            contextIri = 'https://schema.org/';\n        }\n        return contextIri;\n    }\n    /**\n     * Parse scoped contexts in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options Parsing options.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     * @param {string[]} keys Optional set of keys from the context to parseInnerContexts of. If left undefined, all\n     * keys in the context will be iterated over.\n     */\n    async parseInnerContexts(context, options, keys) {\n        for (const key of (keys !== null && keys !== void 0 ? keys : Object.keys(context))) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if ('@context' in value && value['@context'] !== null && !options.ignoreScopedContexts) {\n                    // Simulate a processing based on the parent context to check if there are any (potential errors).\n                    // Honestly, I find it a bit weird to do this here, as the context may be unused,\n                    // and the final effective context may differ based on any other embedded/scoped contexts.\n                    // But hey, it's part of the spec, so we have no choice...\n                    // https://w3c.github.io/json-ld-api/#h-note-10\n                    if (this.validateContext) {\n                        try {\n                            const parentContext = Object.assign(Object.assign({}, context), { [key]: Object.assign({}, context[key]) });\n                            delete parentContext[key]['@context'];\n                            await this.parse(value['@context'], Object.assign(Object.assign({}, options), { external: false, parentContext, ignoreProtection: true, ignoreRemoteScopedContexts: true, ignoreScopedContexts: true }));\n                        }\n                        catch (e) {\n                            throw new ErrorCoded_1.ErrorCoded(e.message, ErrorCoded_1.ERROR_CODES.INVALID_SCOPED_CONTEXT);\n                        }\n                    }\n                    context[key] = Object.assign(Object.assign({}, value), { '@context': (await this.parse(value['@context'], Object.assign(Object.assign({}, options), { external: false, minimalProcessing: true, ignoreRemoteScopedContexts: true, parentContext: context })))\n                            .getContextRaw() });\n                }\n            }\n        }\n        return context;\n    }\n    async parse(context, options = {}, \n    // These options are only for internal use on recursive calls and should not be used by\n    // libraries consuming this function\n    internalOptions = {}) {\n        const { baseIRI, parentContext, external, processingMode = ContextParser.DEFAULT_PROCESSING_MODE, normalizeLanguageTags, ignoreProtection, minimalProcessing, } = options;\n        const remoteContexts = options.remoteContexts || {};\n        // Avoid remote context overflows\n        if (Object.keys(remoteContexts).length >= this.remoteContextsDepthLimit) {\n            throw new ErrorCoded_1.ErrorCoded('Detected an overflow in remote context inclusions: ' + Object.keys(remoteContexts), ErrorCoded_1.ERROR_CODES.CONTEXT_OVERFLOW);\n        }\n        if (context === null || context === undefined) {\n            // Don't allow context nullification and there are protected terms\n            if (!ignoreProtection && parentContext && Util_1.Util.hasProtectedTerms(parentContext)) {\n                throw new ErrorCoded_1.ErrorCoded('Illegal context nullification when terms are protected', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);\n            }\n            // Context that are explicitly set to null are empty.\n            return new JsonLdContextNormalized_1.JsonLdContextNormalized(this.applyBaseEntry({}, options, false));\n        }\n        else if (typeof context === 'string') {\n            const contextIri = this.normalizeContextIri(context, baseIRI);\n            const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n            if (overriddenLoad) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(overriddenLoad);\n            }\n            const parsedStringContext = await this.parse(await this.load(contextIri), Object.assign(Object.assign({}, options), { baseIRI: contextIri, external: true, remoteContexts: Object.assign(Object.assign({}, remoteContexts), { [contextIri]: true }) }));\n            this.applyBaseEntry(parsedStringContext.getContextRaw(), options, true);\n            return parsedStringContext;\n        }\n        else if (Array.isArray(context)) {\n            // As a performance consideration, first load all external contexts in parallel.\n            const contextIris = [];\n            const contexts = await Promise.all(context.map((subContext, i) => {\n                if (typeof subContext === 'string') {\n                    const contextIri = this.normalizeContextIri(subContext, baseIRI);\n                    contextIris[i] = contextIri;\n                    const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n                    if (overriddenLoad) {\n                        return overriddenLoad;\n                    }\n                    return this.load(contextIri);\n                }\n                else {\n                    return subContext;\n                }\n            }));\n            // Don't apply inheritance logic on minimal processing\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(contexts);\n            }\n            const reducedContexts = await contexts.reduce((accContextPromise, contextEntry, i) => accContextPromise\n                .then((accContext) => this.parse(contextEntry, Object.assign(Object.assign({}, options), { baseIRI: contextIris[i] || options.baseIRI, external: !!contextIris[i] || options.external, parentContext: accContext.getContextRaw(), remoteContexts: contextIris[i] ? Object.assign(Object.assign({}, remoteContexts), { [contextIris[i]]: true }) : remoteContexts }), \n            // @ts-expect-error: This third argument causes a type error because we have hidden it from consumers\n            {\n                skipValidation: i < contexts.length - 1,\n            })), Promise.resolve(new JsonLdContextNormalized_1.JsonLdContextNormalized(parentContext || {})));\n            // Override the base IRI if provided.\n            this.applyBaseEntry(reducedContexts.getContextRaw(), options, true);\n            return reducedContexts;\n        }\n        else if (typeof context === 'object') {\n            if ('@context' in context) {\n                return await this.parse(context['@context'], options);\n            }\n            // Make a deep clone of the given context, to avoid modifying it.\n            context = Object.assign({}, context);\n            // According to the JSON-LD spec, @base must be ignored from external contexts.\n            if (external) {\n                delete context['@base'];\n            }\n            // Override the base IRI if provided.\n            this.applyBaseEntry(context, options, true);\n            // Hashify container entries\n            // Do this before protected term validation as that influences term format\n            this.containersToHash(context);\n            // Don't perform any other modifications if only minimal processing is needed.\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(context);\n            }\n            // In JSON-LD 1.1, load @import'ed context prior to processing.\n            let importContext = {};\n            if ('@import' in context) {\n                if (processingMode >= 1.1) {\n                    // Only accept string values\n                    if (typeof context['@import'] !== 'string') {\n                        throw new ErrorCoded_1.ErrorCoded('An @import value must be a string, but got ' + typeof context['@import'], ErrorCoded_1.ERROR_CODES.INVALID_IMPORT_VALUE);\n                    }\n                    // Load context\n                    importContext = await this.loadImportContext(this.normalizeContextIri(context['@import'], baseIRI));\n                    delete context['@import'];\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded('Context importing is not supported in JSON-LD 1.0', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                }\n            }\n            this.applyScopedProtected(importContext, { processingMode }, JsonLdContextNormalized_1.defaultExpandOptions);\n            const newContext = Object.assign(importContext, context);\n            // Handle terms (before protection checks)\n            this.idifyReverseTerms(newContext);\n            this.normalize(newContext, { processingMode, normalizeLanguageTags });\n            this.applyScopedProtected(newContext, { processingMode }, JsonLdContextNormalized_1.defaultExpandOptions);\n            const keys = Object.keys(newContext);\n            const overlappingKeys = [];\n            if (typeof parentContext === 'object') {\n                // Merge different parts of the final context in order\n                for (const key in parentContext) {\n                    if (key in newContext) {\n                        overlappingKeys.push(key);\n                    }\n                    else {\n                        newContext[key] = parentContext[key];\n                    }\n                }\n            }\n            // Parse inner contexts with minimal processing\n            await this.parseInnerContexts(newContext, options, keys);\n            const newContextWrapped = new JsonLdContextNormalized_1.JsonLdContextNormalized(newContext);\n            // In JSON-LD 1.1, @vocab can be relative to @vocab in the parent context, or a compact IRI.\n            if ((newContext && newContext['@version'] || ContextParser.DEFAULT_PROCESSING_MODE) >= 1.1\n                && ((context['@vocab'] && typeof context['@vocab'] === 'string') || context['@vocab'] === '')) {\n                if (parentContext && '@vocab' in parentContext && context['@vocab'].indexOf(':') < 0) {\n                    newContext['@vocab'] = parentContext['@vocab'] + context['@vocab'];\n                }\n                else if (Util_1.Util.isCompactIri(context['@vocab']) || context['@vocab'] in newContext) {\n                    // @vocab is a compact IRI or refers exactly to a prefix\n                    newContext['@vocab'] = newContextWrapped.expandTerm(context['@vocab'], true);\n                }\n            }\n            this.expandPrefixedTerms(newContextWrapped, this.expandContentTypeToBase, keys);\n            // In JSON-LD 1.1, check if we are not redefining any protected keywords\n            if (!ignoreProtection && parentContext && processingMode >= 1.1) {\n                this.validateKeywordRedefinitions(parentContext, newContext, JsonLdContextNormalized_1.defaultExpandOptions, overlappingKeys);\n            }\n            if (this.validateContext && !internalOptions.skipValidation) {\n                this.validate(newContext, { processingMode });\n            }\n            return newContextWrapped;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${context}`, ErrorCoded_1.ERROR_CODES.INVALID_LOCAL_CONTEXT);\n        }\n    }\n    /**\n     * Fetch the given URL as a raw JSON-LD context.\n     * @param url An URL.\n     * @return A promise resolving to a raw JSON-LD context.\n     */\n    async load(url) {\n        // First try to retrieve the context from cache\n        const cached = this.documentCache[url];\n        if (cached) {\n            return cached;\n        }\n        // If not in cache, load it\n        let document;\n        try {\n            document = await this.documentLoader.load(url);\n        }\n        catch (e) {\n            throw new ErrorCoded_1.ErrorCoded(`Failed to load remote context ${url}: ${e.message}`, ErrorCoded_1.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);\n        }\n        // Validate the context\n        if (!('@context' in document)) {\n            throw new ErrorCoded_1.ErrorCoded(`Missing @context in remote context at ${url}`, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        return this.documentCache[url] = document['@context'];\n    }\n    /**\n     * Override the given context that may be loaded.\n     *\n     * This will check whether or not the url is recursively being loaded.\n     * @param url An URL.\n     * @param options Parsing options.\n     * @return An overridden context, or null.\n     *         Optionally an error can be thrown if a cyclic context is detected.\n     */\n    getOverriddenLoad(url, options) {\n        if (url in (options.remoteContexts || {})) {\n            if (options.ignoreRemoteScopedContexts) {\n                return url;\n            }\n            else {\n                throw new ErrorCoded_1.ErrorCoded('Detected a cyclic context inclusion of ' + url, ErrorCoded_1.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);\n            }\n        }\n        return null;\n    }\n    /**\n     * Load an @import'ed context.\n     * @param importContextIri The full URI of an @import value.\n     */\n    async loadImportContext(importContextIri) {\n        // Load the context - and do a deep clone since we are about to mutate it\n        let importContext = await this.load(importContextIri);\n        // Require the context to be a non-array object\n        if (typeof importContext !== 'object' || Array.isArray(importContext)) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context must be a single object: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        // Error if the context contains another @import\n        if ('@import' in importContext) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context can not import another context: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n        }\n        importContext = Object.assign({}, importContext);\n        // Containers have to be converted into hash values the same way as for the importing context\n        // Otherwise context validation will fail for container values\n        this.containersToHash(importContext);\n        return importContext;\n    }\n}\nContextParser.DEFAULT_PROCESSING_MODE = 1.1;\nexports.ContextParser = ContextParser;\n//# sourceMappingURL=ContextParser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ERROR_CODES = exports.ErrorCoded = void 0;\n/**\n * An error that has a certain error code.\n *\n * The error code can be any string.\n * All standardized error codes are listed in {@link ERROR_CODES}.\n */\nclass ErrorCoded extends Error {\n    /* istanbul ignore next */\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nexports.ErrorCoded = ErrorCoded;\n/**\n * All standardized JSON-LD error codes.\n * @see https://w3c.github.io/json-ld-api/#dom-jsonlderrorcode\n */\n// tslint:disable:object-literal-sort-keys\nvar ERROR_CODES;\n(function (ERROR_CODES) {\n    ERROR_CODES[\"COLLIDING_KEYWORDS\"] = \"colliding keywords\";\n    ERROR_CODES[\"CONFLICTING_INDEXES\"] = \"conflicting indexes\";\n    ERROR_CODES[\"CYCLIC_IRI_MAPPING\"] = \"cyclic IRI mapping\";\n    ERROR_CODES[\"INVALID_ID_VALUE\"] = \"invalid @id value\";\n    ERROR_CODES[\"INVALID_INDEX_VALUE\"] = \"invalid @index value\";\n    ERROR_CODES[\"INVALID_NEST_VALUE\"] = \"invalid @nest value\";\n    ERROR_CODES[\"INVALID_PREFIX_VALUE\"] = \"invalid @prefix value\";\n    ERROR_CODES[\"INVALID_PROPAGATE_VALUE\"] = \"invalid @propagate value\";\n    ERROR_CODES[\"INVALID_REVERSE_VALUE\"] = \"invalid @reverse value\";\n    ERROR_CODES[\"INVALID_IMPORT_VALUE\"] = \"invalid @import value\";\n    ERROR_CODES[\"INVALID_VERSION_VALUE\"] = \"invalid @version value\";\n    ERROR_CODES[\"INVALID_BASE_IRI\"] = \"invalid base IRI\";\n    ERROR_CODES[\"INVALID_CONTAINER_MAPPING\"] = \"invalid container mapping\";\n    ERROR_CODES[\"INVALID_CONTEXT_ENTRY\"] = \"invalid context entry\";\n    ERROR_CODES[\"INVALID_CONTEXT_NULLIFICATION\"] = \"invalid context nullification\";\n    ERROR_CODES[\"INVALID_DEFAULT_LANGUAGE\"] = \"invalid default language\";\n    ERROR_CODES[\"INVALID_INCLUDED_VALUE\"] = \"invalid @included value\";\n    ERROR_CODES[\"INVALID_IRI_MAPPING\"] = \"invalid IRI mapping\";\n    ERROR_CODES[\"INVALID_JSON_LITERAL\"] = \"invalid JSON literal\";\n    ERROR_CODES[\"INVALID_KEYWORD_ALIAS\"] = \"invalid keyword alias\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAP_VALUE\"] = \"invalid language map value\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAPPING\"] = \"invalid language mapping\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_STRING\"] = \"invalid language-tagged string\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_VALUE\"] = \"invalid language-tagged value\";\n    ERROR_CODES[\"INVALID_LOCAL_CONTEXT\"] = \"invalid local context\";\n    ERROR_CODES[\"INVALID_REMOTE_CONTEXT\"] = \"invalid remote context\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY\"] = \"invalid reverse property\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_MAP\"] = \"invalid reverse property map\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_VALUE\"] = \"invalid reverse property value\";\n    ERROR_CODES[\"INVALID_SCOPED_CONTEXT\"] = \"invalid scoped context\";\n    ERROR_CODES[\"INVALID_SCRIPT_ELEMENT\"] = \"invalid script element\";\n    ERROR_CODES[\"INVALID_SET_OR_LIST_OBJECT\"] = \"invalid set or list object\";\n    ERROR_CODES[\"INVALID_TERM_DEFINITION\"] = \"invalid term definition\";\n    ERROR_CODES[\"INVALID_TYPE_MAPPING\"] = \"invalid type mapping\";\n    ERROR_CODES[\"INVALID_TYPE_VALUE\"] = \"invalid type value\";\n    ERROR_CODES[\"INVALID_TYPED_VALUE\"] = \"invalid typed value\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT\"] = \"invalid value object\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT_VALUE\"] = \"invalid value object value\";\n    ERROR_CODES[\"INVALID_VOCAB_MAPPING\"] = \"invalid vocab mapping\";\n    ERROR_CODES[\"IRI_CONFUSED_WITH_PREFIX\"] = \"IRI confused with prefix\";\n    ERROR_CODES[\"KEYWORD_REDEFINITION\"] = \"keyword redefinition\";\n    ERROR_CODES[\"LOADING_DOCUMENT_FAILED\"] = \"loading document failed\";\n    ERROR_CODES[\"LOADING_REMOTE_CONTEXT_FAILED\"] = \"loading remote context failed\";\n    ERROR_CODES[\"MULTIPLE_CONTEXT_LINK_HEADERS\"] = \"multiple context link headers\";\n    ERROR_CODES[\"PROCESSING_MODE_CONFLICT\"] = \"processing mode conflict\";\n    ERROR_CODES[\"PROTECTED_TERM_REDEFINITION\"] = \"protected term redefinition\";\n    ERROR_CODES[\"CONTEXT_OVERFLOW\"] = \"context overflow\";\n    ERROR_CODES[\"INVALID_BASE_DIRECTION\"] = \"invalid base direction\";\n    ERROR_CODES[\"RECURSIVE_CONTEXT_INCLUSION\"] = \"recursive context inclusion\";\n    ERROR_CODES[\"INVALID_STREAMING_KEY_ORDER\"] = \"invalid streaming key order\";\n    /**\n     * JSON-LD-star\n     */\n    ERROR_CODES[\"INVALID_EMBEDDED_NODE\"] = \"invalid embedded node\";\n    ERROR_CODES[\"INVALID_ANNOTATION\"] = \"invalid annotation\";\n})(ERROR_CODES = exports.ERROR_CODES || (exports.ERROR_CODES = {}));\n//# sourceMappingURL=ErrorCoded.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FetchDocumentLoader = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst http_link_header_1 = require(\"http-link-header\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n/**\n * Loads documents via the fetch API.\n */\nclass FetchDocumentLoader {\n    constructor(fetcher) {\n        this.fetcher = fetcher;\n    }\n    async load(url) {\n        const response = await (this.fetcher || fetch)(url, { headers: new Headers({ accept: 'application/ld+json' }) });\n        if (response.ok && response.headers) {\n            let mediaType = response.headers.get('Content-Type');\n            if (mediaType) {\n                const colonPos = mediaType.indexOf(';');\n                if (colonPos > 0) {\n                    mediaType = mediaType.substr(0, colonPos);\n                }\n            }\n            if (mediaType === 'application/ld+json') {\n                // Return JSON-LD if proper content type was returned\n                return (await response.json());\n            }\n            else {\n                // Check for alternate link for a non-JSON-LD response\n                if (response.headers.has('Link')) {\n                    let alternateUrl;\n                    response.headers.forEach((value, key) => {\n                        if (key === 'link') {\n                            const linkHeader = (0, http_link_header_1.parse)(value);\n                            for (const link of linkHeader.get('type', 'application/ld+json')) {\n                                if (link.rel === 'alternate') {\n                                    if (alternateUrl) {\n                                        throw new Error('Multiple JSON-LD alternate links were found on ' + url);\n                                    }\n                                    alternateUrl = (0, relative_to_absolute_iri_1.resolve)(link.uri, url);\n                                }\n                            }\n                        }\n                    });\n                    if (alternateUrl) {\n                        return this.load(alternateUrl);\n                    }\n                }\n                throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`, ErrorCoded_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);\n            }\n        }\n        else {\n            throw new Error(response.statusText || `Status code: ${response.status}`);\n        }\n    }\n}\nexports.FetchDocumentLoader = FetchDocumentLoader;\n//# sourceMappingURL=FetchDocumentLoader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IDocumentLoader.js.map","\"use strict\";\n// tslint:disable:max-line-length\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=JsonLdContext.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultExpandOptions = exports.JsonLdContextNormalized = void 0;\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst Util_1 = require(\"./Util\");\n/**\n * A class exposing operations over a normalized JSON-LD context.\n */\nclass JsonLdContextNormalized {\n    constructor(contextRaw) {\n        this.contextRaw = contextRaw;\n    }\n    /**\n     * @return The raw inner context.\n     */\n    getContextRaw() {\n        return this.contextRaw;\n    }\n    /**\n     * Expand the term or prefix of the given term if it has one,\n     * otherwise return the term as-is.\n     *\n     * This will try to expand the IRI as much as possible.\n     *\n     * Iff in vocab-mode, then other references to other terms in the context can be used,\n     * such as to `myTerm`:\n     * ```\n     * {\n     *   \"myTerm\": \"http://example.org/myLongTerm\"\n     * }\n     * ```\n     *\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,\n     *                              otherwise it is considered a regular term that is expanded based on @base.\n     * @param {IExpandOptions} options Options that define the way how expansion must be done.\n     * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.\n     * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).\n     */\n    expandTerm(term, expandVocab, options = exports.defaultExpandOptions) {\n        const contextValue = this.contextRaw[term];\n        // Immediately return if the term was disabled in the context\n        if (contextValue === null || (contextValue && contextValue['@id'] === null)) {\n            return null;\n        }\n        // Check the @id\n        let validIriMapping = true;\n        if (contextValue && expandVocab) {\n            const value = Util_1.Util.getContextValueId(contextValue);\n            if (value && value !== term) {\n                if (typeof value !== 'string' || (!Util_1.Util.isValidIri(value) && !Util_1.Util.isValidKeyword(value))) {\n                    // Don't mark this mapping as invalid if we have an unknown keyword, but of the correct form.\n                    if (!Util_1.Util.isPotentialKeyword(value)) {\n                        validIriMapping = false;\n                    }\n                }\n                else {\n                    return value;\n                }\n            }\n        }\n        // Check if the term is prefixed\n        const prefix = Util_1.Util.getPrefix(term, this.contextRaw);\n        const vocab = this.contextRaw['@vocab'];\n        const vocabRelative = (!!vocab || vocab === '') && vocab.indexOf(':') < 0;\n        const base = this.contextRaw['@base'];\n        const potentialKeyword = Util_1.Util.isPotentialKeyword(term);\n        if (prefix) {\n            const contextPrefixValue = this.contextRaw[prefix];\n            const value = Util_1.Util.getContextValueId(contextPrefixValue);\n            if (value) {\n                if (typeof contextPrefixValue === 'string' || !options.allowPrefixForcing) {\n                    // If we have a simple term definition,\n                    // check the last character of the prefix to determine whether or not it is a prefix.\n                    // Validate that prefix ends with gen-delim character, unless @prefix is true\n                    if (!Util_1.Util.isSimpleTermDefinitionPrefix(value, options)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                else {\n                    // If we have an expanded term definition, default to @prefix: false\n                    if (value[0] !== '_' && !potentialKeyword && !contextPrefixValue['@prefix'] && !(term in this.contextRaw)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                return value + term.substr(prefix.length + 1);\n            }\n        }\n        else if (expandVocab && ((vocab || vocab === '') || (options.allowVocabRelativeToBase && (base && vocabRelative)))\n            && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            if (vocabRelative) {\n                if (options.allowVocabRelativeToBase) {\n                    return ((vocab || base) ? (0, relative_to_absolute_iri_1.resolve)(vocab, base) : '') + term;\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded(`Relative vocab expansion for term '${term}' with vocab '${vocab}' is not allowed.`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                }\n            }\n            else {\n                return vocab + term;\n            }\n        }\n        else if (!expandVocab && base && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            return (0, relative_to_absolute_iri_1.resolve)(term, base);\n        }\n        // Return the term as-is, unless we discovered an invalid IRI mapping for this term in the context earlier.\n        if (validIriMapping) {\n            return term;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Invalid IRI mapping found for context entry '${term}': '${JSON.stringify(contextValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n        }\n    }\n    /**\n     * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.\n     *\n     * This will try to compact the IRI as much as possible.\n     *\n     * @param {string} iri An IRI to compact.\n     * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,\n     *                        otherwise it is considered a regular term that is compacted based on @base.\n     * @return {string} The compacted term or the IRI as-is.\n     */\n    compactIri(iri, vocab) {\n        // Try @vocab compacting\n        if (vocab && this.contextRaw['@vocab'] && iri.startsWith(this.contextRaw['@vocab'])) {\n            return iri.substr(this.contextRaw['@vocab'].length);\n        }\n        // Try @base compacting\n        if (!vocab && this.contextRaw['@base'] && iri.startsWith(this.contextRaw['@base'])) {\n            return iri.substr(this.contextRaw['@base'].length);\n        }\n        // Loop over all terms in the context\n        // This will try to prefix as short as possible.\n        // Once a fully compacted alias is found, return immediately, as we can not go any shorter.\n        const shortestPrefixing = { prefix: '', suffix: iri };\n        for (const key in this.contextRaw) {\n            const value = this.contextRaw[key];\n            if (value && !Util_1.Util.isPotentialKeyword(key)) {\n                const contextIri = Util_1.Util.getContextValueId(value);\n                if (iri.startsWith(contextIri)) {\n                    const suffix = iri.substr(contextIri.length);\n                    if (!suffix) {\n                        if (vocab) {\n                            // Immediately return on compacted alias\n                            return key;\n                        }\n                    }\n                    else if (suffix.length < shortestPrefixing.suffix.length) {\n                        // Overwrite the shortest prefix\n                        shortestPrefixing.prefix = key;\n                        shortestPrefixing.suffix = suffix;\n                    }\n                }\n            }\n        }\n        // Return the shortest prefix\n        if (shortestPrefixing.prefix) {\n            return shortestPrefixing.prefix + ':' + shortestPrefixing.suffix;\n        }\n        return iri;\n    }\n}\nexports.JsonLdContextNormalized = JsonLdContextNormalized;\nexports.defaultExpandOptions = {\n    allowPrefixForcing: true,\n    allowPrefixNonGenDelims: false,\n    allowVocabRelativeToBase: true,\n};\n//# sourceMappingURL=JsonLdContextNormalized.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nclass Util {\n    /**\n     * Check if the given term is a valid compact IRI.\n     * Otherwise, it may be an IRI.\n     * @param {string} term A term.\n     * @return {boolean} If it is a compact IRI.\n     */\n    static isCompactIri(term) {\n        return term.indexOf(':') > 0 && !(term && term[0] === '#');\n    }\n    /**\n     * Get the prefix from the given term.\n     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {string} The prefix or null.\n     */\n    static getPrefix(term, context) {\n        // Do not consider relative IRIs starting with a hash as compact IRIs\n        if (term && term[0] === '#') {\n            return null;\n        }\n        const separatorPos = term.indexOf(':');\n        if (separatorPos >= 0) {\n            // Suffix can not begin with two slashes\n            if (term.length > separatorPos + 1\n                && term.charAt(separatorPos + 1) === '/'\n                && term.charAt(separatorPos + 2) === '/') {\n                return null;\n            }\n            const prefix = term.substr(0, separatorPos);\n            // Prefix can not be an underscore (this is a blank node)\n            if (prefix === '_') {\n                return null;\n            }\n            // Prefix must match a term in the active context\n            if (context[prefix]) {\n                return prefix;\n            }\n        }\n        return null;\n    }\n    /**\n     * From a given context entry value, get the string value, or the @id field.\n     * @param contextValue A value for a term in a context.\n     * @return {string} The id value, or null.\n     */\n    static getContextValueId(contextValue) {\n        if (contextValue === null || typeof contextValue === 'string') {\n            return contextValue;\n        }\n        const id = contextValue['@id'];\n        return id ? id : null;\n    }\n    /**\n     * Check if the given simple term definition (string-based value of a context term)\n     * should be considered a prefix.\n     * @param value A simple term definition value.\n     * @param options Options that define the way how expansion must be done.\n     */\n    static isSimpleTermDefinitionPrefix(value, options) {\n        return !Util.isPotentialKeyword(value)\n            && (options.allowPrefixNonGenDelims || (typeof value === 'string' && (value[0] === '_' || Util.isPrefixIriEndingWithGenDelim(value))));\n    }\n    /**\n     * Check if the given keyword is of the keyword format \"@\"1*ALPHA.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is of the keyword format.\n     */\n    static isPotentialKeyword(keyword) {\n        return typeof keyword === 'string' && Util.KEYWORD_REGEX.test(keyword);\n    }\n    /**\n     * Check if the given prefix ends with a gen-delim character.\n     * @param {string} prefixIri A prefix IRI.\n     * @return {boolean} If the given prefix IRI is valid.\n     */\n    static isPrefixIriEndingWithGenDelim(prefixIri) {\n        return Util.ENDS_WITH_GEN_DELIM.test(prefixIri);\n    }\n    /**\n     * Check if the given context value can be a prefix value.\n     * @param value A context value.\n     * @return {boolean} If it can be a prefix value.\n     */\n    static isPrefixValue(value) {\n        return value && (typeof value === 'string' || (value && typeof value === 'object'));\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return Boolean(iri && Util.IRI_REGEX.test(iri));\n    }\n    /**\n     * Check if the given IRI is valid, this includes the possibility of being a relative IRI.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIriWeak(iri) {\n        return !!iri && iri[0] !== ':' && Util.IRI_REGEX_WEAK.test(iri);\n    }\n    /**\n     * Check if the given keyword is a defined according to the JSON-LD specification.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is valid.\n     */\n    static isValidKeyword(keyword) {\n        return Util.VALID_KEYWORDS[keyword];\n    }\n    /**\n     * Check if the given term is protected in the context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {string} key A context term.\n     * @return {boolean} If the given term has an @protected flag.\n     */\n    static isTermProtected(context, key) {\n        const value = context[key];\n        return !(typeof value === 'string') && value && value['@protected'];\n    }\n    /**\n     * Check if the given context has at least one protected term.\n     * @param context A context.\n     * @return If the context has a protected term.\n     */\n    static hasProtectedTerms(context) {\n        for (const key of Object.keys(context)) {\n            if (Util.isTermProtected(context, key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Check if the given key is an internal reserved keyword.\n     * @param key A context key.\n     */\n    static isReservedInternalKeyword(key) {\n        return key.startsWith('@__');\n    }\n    /**\n     * Check if two objects are deepEqual to on another.\n     * @param object1 The first object to test.\n     * @param object2 The second object to test.\n     */\n    static deepEqual(object1, object2) {\n        const objKeys1 = Object.keys(object1);\n        const objKeys2 = Object.keys(object2);\n        if (objKeys1.length !== objKeys2.length)\n            return false;\n        return objKeys1.every((key) => {\n            const value1 = object1[key];\n            const value2 = object2[key];\n            return (value1 === value2) || (value1 !== null &&\n                value2 !== null &&\n                typeof value1 === \"object\" &&\n                typeof value2 === \"object\" &&\n                this.deepEqual(value1, value2));\n        });\n    }\n    ;\n}\n// Regex for valid IRIs\nUtil.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`#]*(#[^#]*)?$/;\n// Weaker regex for valid IRIs, this includes relative IRIs\nUtil.IRI_REGEX_WEAK = /(?::[^:])|\\//;\n// Regex for keyword form\nUtil.KEYWORD_REGEX = /^@[a-z]+$/i;\n// Regex to see if an IRI ends with a gen-delim character (see RFC 3986)\nUtil.ENDS_WITH_GEN_DELIM = /[:/?#\\[\\]@]$/;\n// Regex for language tags\nUtil.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;\n// Regex for base directions\nUtil.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/;\n// All known valid JSON-LD keywords\n// @see https://www.w3.org/TR/json-ld11/#keywords\nUtil.VALID_KEYWORDS = {\n    '@annotation': true,\n    '@base': true,\n    '@container': true,\n    '@context': true,\n    '@direction': true,\n    '@graph': true,\n    '@id': true,\n    '@import': true,\n    '@included': true,\n    '@index': true,\n    '@json': true,\n    '@language': true,\n    '@list': true,\n    '@nest': true,\n    '@none': true,\n    '@prefix': true,\n    '@propagate': true,\n    '@protected': true,\n    '@reverse': true,\n    '@set': true,\n    '@type': true,\n    '@value': true,\n    '@version': true,\n    '@vocab': true,\n};\n// Keys in the contexts that will not be expanded based on the base IRI\nUtil.EXPAND_KEYS_BLACKLIST = [\n    '@base',\n    '@vocab',\n    '@language',\n    '@version',\n    '@direction',\n];\n// Keys in the contexts that may not be aliased from\nUtil.ALIAS_DOMAIN_BLACKLIST = [\n    '@container',\n    '@graph',\n    '@id',\n    '@index',\n    '@list',\n    '@nest',\n    '@none',\n    '@prefix',\n    '@reverse',\n    '@set',\n    '@type',\n    '@value',\n    '@version',\n];\n// Keys in the contexts that may not be aliased to\nUtil.ALIAS_RANGE_BLACKLIST = [\n    '@context',\n    '@preserve',\n];\n// All valid @container values\nUtil.CONTAINERS = [\n    '@list',\n    '@set',\n    '@index',\n    '@language',\n    '@graph',\n    '@id',\n    '@type',\n];\n// All valid @container values under processing mode 1.0\nUtil.CONTAINERS_1_0 = [\n    '@list',\n    '@set',\n    '@index',\n];\nexports.Util = Util;\n//# sourceMappingURL=Util.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/BlankNode\"), exports);\n__exportStar(require(\"./lib/DataFactory\"), exports);\n__exportStar(require(\"./lib/DefaultGraph\"), exports);\n__exportStar(require(\"./lib/Literal\"), exports);\n__exportStar(require(\"./lib/NamedNode\"), exports);\n__exportStar(require(\"./lib/Quad\"), exports);\n__exportStar(require(\"./lib/Variable\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlankNode = void 0;\n/**\n * A term that represents an RDF blank node with a label.\n */\nclass BlankNode {\n    constructor(value) {\n        this.termType = 'BlankNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'BlankNode' && other.value === this.value;\n    }\n}\nexports.BlankNode = BlankNode;\n//# sourceMappingURL=BlankNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataFactory = void 0;\nconst BlankNode_1 = require(\"./BlankNode\");\nconst DefaultGraph_1 = require(\"./DefaultGraph\");\nconst Literal_1 = require(\"./Literal\");\nconst NamedNode_1 = require(\"./NamedNode\");\nconst Quad_1 = require(\"./Quad\");\nconst Variable_1 = require(\"./Variable\");\nlet dataFactoryCounter = 0;\n/**\n * A factory for instantiating RDF terms and quads.\n */\nclass DataFactory {\n    constructor(options) {\n        this.blankNodeCounter = 0;\n        options = options || {};\n        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;\n    }\n    /**\n     * @param value The IRI for the named node.\n     * @return A new instance of NamedNode.\n     * @see NamedNode\n     */\n    namedNode(value) {\n        return new NamedNode_1.NamedNode(value);\n    }\n    /**\n     * @param value The optional blank node identifier.\n     * @return A new instance of BlankNode.\n     *         If the `value` parameter is undefined a new identifier\n     *         for the blank node is generated for each call.\n     * @see BlankNode\n     */\n    blankNode(value) {\n        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);\n    }\n    /**\n     * @param value              The literal value.\n     * @param languageOrDatatype The optional language or datatype.\n     *                           If `languageOrDatatype` is a NamedNode,\n     *                           then it is used for the value of `NamedNode.datatype`.\n     *                           Otherwise `languageOrDatatype` is used for the value\n     *                           of `NamedNode.language`.\n     * @return A new instance of Literal.\n     * @see Literal\n     */\n    literal(value, languageOrDatatype) {\n        return new Literal_1.Literal(value, languageOrDatatype);\n    }\n    /**\n     * This method is optional.\n     * @param value The variable name\n     * @return A new instance of Variable.\n     * @see Variable\n     */\n    variable(value) {\n        return new Variable_1.Variable(value);\n    }\n    /**\n     * @return An instance of DefaultGraph.\n     */\n    defaultGraph() {\n        return DefaultGraph_1.DefaultGraph.INSTANCE;\n    }\n    /**\n     * @param subject   The quad subject term.\n     * @param predicate The quad predicate term.\n     * @param object    The quad object term.\n     * @param graph     The quad graph term.\n     * @return A new instance of Quad.\n     * @see Quad\n     */\n    quad(subject, predicate, object, graph) {\n        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());\n    }\n    /**\n     * Create a deep copy of the given term using this data factory.\n     * @param original An RDF term.\n     * @return A deep copy of the given term.\n     */\n    fromTerm(original) {\n        // TODO: remove nasty any casts when this TS bug has been fixed:\n        //  https://github.com/microsoft/TypeScript/issues/26933\n        switch (original.termType) {\n            case 'NamedNode':\n                return this.namedNode(original.value);\n            case 'BlankNode':\n                return this.blankNode(original.value);\n            case 'Literal':\n                if (original.language) {\n                    return this.literal(original.value, original.language);\n                }\n                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {\n                    return this.literal(original.value, this.fromTerm(original.datatype));\n                }\n                return this.literal(original.value);\n            case 'Variable':\n                return this.variable(original.value);\n            case 'DefaultGraph':\n                return this.defaultGraph();\n            case 'Quad':\n                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));\n        }\n    }\n    /**\n     * Create a deep copy of the given quad using this data factory.\n     * @param original An RDF quad.\n     * @return A deep copy of the given quad.\n     */\n    fromQuad(original) {\n        return this.fromTerm(original);\n    }\n    /**\n     * Reset the internal blank node counter.\n     */\n    resetBlankNodeCounter() {\n        this.blankNodeCounter = 0;\n    }\n}\nexports.DataFactory = DataFactory;\n//# sourceMappingURL=DataFactory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultGraph = void 0;\n/**\n * A singleton term instance that represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass DefaultGraph {\n    constructor() {\n        this.termType = 'DefaultGraph';\n        this.value = '';\n        // Private constructor\n    }\n    equals(other) {\n        return !!other && other.termType === 'DefaultGraph';\n    }\n}\nexports.DefaultGraph = DefaultGraph;\nDefaultGraph.INSTANCE = new DefaultGraph();\n//# sourceMappingURL=DefaultGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Literal = void 0;\nconst NamedNode_1 = require(\"./NamedNode\");\n/**\n * A term that represents an RDF literal, containing a string with an optional language tag or datatype.\n */\nclass Literal {\n    constructor(value, languageOrDatatype) {\n        this.termType = 'Literal';\n        this.value = value;\n        if (typeof languageOrDatatype === 'string') {\n            this.language = languageOrDatatype;\n            this.datatype = Literal.RDF_LANGUAGE_STRING;\n        }\n        else if (languageOrDatatype) {\n            this.language = '';\n            this.datatype = languageOrDatatype;\n        }\n        else {\n            this.language = '';\n            this.datatype = Literal.XSD_STRING;\n        }\n    }\n    equals(other) {\n        return !!other && other.termType === 'Literal' && other.value === this.value &&\n            other.language === this.language && this.datatype.equals(other.datatype);\n    }\n}\nexports.Literal = Literal;\nLiteral.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');\nLiteral.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');\n//# sourceMappingURL=Literal.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NamedNode = void 0;\n/**\n * A term that contains an IRI.\n */\nclass NamedNode {\n    constructor(value) {\n        this.termType = 'NamedNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'NamedNode' && other.value === this.value;\n    }\n}\nexports.NamedNode = NamedNode;\n//# sourceMappingURL=NamedNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quad = void 0;\n/**\n * An instance of DefaultGraph represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass Quad {\n    constructor(subject, predicate, object, graph) {\n        this.termType = 'Quad';\n        this.value = '';\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph;\n    }\n    equals(other) {\n        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n        return !!other && (other.termType === 'Quad' || !other.termType) &&\n            this.subject.equals(other.subject) &&\n            this.predicate.equals(other.predicate) &&\n            this.object.equals(other.object) &&\n            this.graph.equals(other.graph);\n    }\n}\nexports.Quad = Quad;\n//# sourceMappingURL=Quad.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\n/**\n * A term that represents a variable.\n */\nclass Variable {\n    constructor(value) {\n        this.termType = 'Variable';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'Variable' && other.value === this.value;\n    }\n}\nexports.Variable = Variable;\n//# sourceMappingURL=Variable.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Resolve\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDotSegmentsOfPath = exports.removeDotSegments = exports.resolve = void 0;\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map"],"names":["module","exports","serialize","object","toJSON","JSON","stringify","Array","isArray","reduce","t","cv","ci","comma","value","undefined","Object","keys","sort","length","self","support","searchParams","iterable","Symbol","blob","Blob","e","formData","arrayBuffer","isDataView","obj","DataView","prototype","isPrototypeOf","viewClasses","isArrayBufferView","ArrayBuffer","isView","indexOf","toString","call","normalizeName","name","String","test","TypeError","toLowerCase","normalizeValue","iteratorFor","items","iterator","next","shift","done","Headers","headers","this","map","forEach","append","header","getOwnPropertyNames","consumed","body","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","result","onerror","error","readBlobAsArrayBuffer","FileReader","promise","readAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","buf","view","Uint8Array","chars","i","fromCharCode","join","bufferClone","slice","byteLength","set","buffer","Body","_initBody","_bodyInit","_bodyText","_bodyBlob","FormData","_bodyFormData","URLSearchParams","_bodyArrayBuffer","get","type","rejected","Error","then","text","decode","json","parse","oldValue","has","hasOwnProperty","callback","thisArg","push","values","entries","methods","normalizeMethod","method","upcased","toUpperCase","Request","input","options","url","credentials","mode","signal","referrer","form","trim","split","bytes","replace","decodeURIComponent","parseHeaders","rawHeaders","preProcessedHeaders","line","parts","key","Response","bodyInit","status","ok","statusText","clone","response","redirectStatuses","redirect","RangeError","location","DOMException","err","message","stack","create","constructor","fetch","init","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","getAllResponseHeaders","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","defineProperty","COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","TOKEN_PATTERN","STATE","IDLE","URI","ATTR","hasWhitespace","skipWhitespace","offset","needsQuotes","shallowCompareObjects","object1","object2","every","Link","refs","rel","links","attr","link","setUnique","some","ref","state","expandRelations","end","uri","attrValue","isSingleOccurenceAttr","parseExtendedValue","formatAttribute","isCompatibleEncoding","isTokenAttr","escapeQuotes","rels","assign","exec","language","encoding","formatExtendedAttribute","data","encodedValue","Buffer","isBuffer","encodeURIComponent","item","__createBinding","o","m","k","k2","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","__exportStar","p","ContextParser","relative_to_absolute_iri_1","ErrorCoded_1","FetchDocumentLoader_1","JsonLdContextNormalized_1","Util_1","documentLoader","FetchDocumentLoader","documentCache","validateContext","skipValidation","expandContentTypeToBase","remoteContextsDepthLimit","redirectSchemaOrgHttps","validateLanguage","strictRange","errorCode","ErrorCoded","Util","REGEX_LANGUAGE_TAG","validateDirection","strictValues","ERROR_CODES","INVALID_BASE_DIRECTION","REGEX_DIRECTION_TAG","idifyReverseTerms","context","isValidKeyword","INVALID_IRI_MAPPING","isPotentialKeyword","expandPrefixedTerms","contextRaw","getContextRaw","EXPAND_KEYS_BLACKLIST","isReservedInternalKeyword","keyValue","ALIAS_DOMAIN_BLACKLIST","KEYWORD_REDEFINITION","ALIAS_RANGE_BLACKLIST","getContextValueId","INVALID_KEYWORD_ALIAS","INVALID_TERM_DEFINITION","isPrefixValue","changed","expandTerm","id","canAddIdEntry","isValidIri","newId","expandedType","normalize","processingMode","normalizeLanguageTags","lowercase","containersToHash","newValue","containerValue","applyScopedProtected","expandOptions","isTermProtected","isSimpleTermDefinitionPrefix","validateKeywordRedefinitions","contextBefore","contextAfter","deepEqual","PROTECTED_TERM_REDEFINITION","validate","valueType","substr","INVALID_VOCAB_MAPPING","INVALID_BASE_IRI","INVALID_DEFAULT_LANGUAGE","INVALID_VERSION_VALUE","INVALID_CONTEXT_ENTRY","INVALID_PROPAGATE_VALUE","getPrefix","CYCLIC_IRI_MAPPING","isValidIriWeak","JsonLdContextNormalized","isCompactIri","objectKey","objectValue","INVALID_TYPE_MAPPING","INVALID_REVERSE_PROPERTY","CONTAINERS_1_0","INVALID_CONTAINER_MAPPING","CONTAINERS","INVALID_LANGUAGE_MAPPING","INVALID_PREFIX_VALUE","INVALID_NEST_VALUE","applyBaseEntry","inheritFromParent","parentContext","baseIRI","external","normalizeContextIri","contextIri","_a","startsWith","parseInnerContexts","ignoreScopedContexts","ignoreProtection","ignoreRemoteScopedContexts","INVALID_SCOPED_CONTEXT","minimalProcessing","internalOptions","DEFAULT_PROCESSING_MODE","remoteContexts","CONTEXT_OVERFLOW","hasProtectedTerms","INVALID_CONTEXT_NULLIFICATION","overriddenLoad","getOverriddenLoad","parsedStringContext","load","contextIris","contexts","all","subContext","reducedContexts","accContextPromise","contextEntry","accContext","importContext","INVALID_IMPORT_VALUE","loadImportContext","defaultExpandOptions","newContext","overlappingKeys","newContextWrapped","INVALID_LOCAL_CONTEXT","cached","document","LOADING_REMOTE_CONTEXT_FAILED","INVALID_REMOTE_CONTEXT","RECURSIVE_CONTEXT_INCLUSION","importContextIri","code","super","http_link_header_1","fetcher","accept","mediaType","colonPos","alternateUrl","linkHeader","LOADING_DOCUMENT_FAILED","term","expandVocab","contextValue","validIriMapping","prefix","vocab","vocabRelative","base","potentialKeyword","contextPrefixValue","allowPrefixForcing","allowVocabRelativeToBase","compactIri","iri","shortestPrefixing","suffix","allowPrefixNonGenDelims","separatorPos","charAt","isPrefixIriEndingWithGenDelim","keyword","KEYWORD_REGEX","prefixIri","ENDS_WITH_GEN_DELIM","Boolean","IRI_REGEX","IRI_REGEX_WEAK","VALID_KEYWORDS","objKeys1","objKeys2","value1","value2","BlankNode","termType","equals","other","DataFactory","BlankNode_1","DefaultGraph_1","Literal_1","NamedNode_1","Quad_1","Variable_1","dataFactoryCounter","blankNodeCounter","blankNodePrefix","namedNode","NamedNode","blankNode","literal","languageOrDatatype","Literal","variable","Variable","defaultGraph","DefaultGraph","INSTANCE","quad","subject","predicate","graph","Quad","fromTerm","original","datatype","XSD_STRING","fromQuad","resetBlankNodeCounter","RDF_LANGUAGE_STRING","relativeIRI","baseFragmentPos","baseQueryPos","relativeColonPos","removeDotSegmentsOfPath","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","removeDotSegments","baseIRIPath","baseIRILastSlashPos","lastIndexOf","path","segmentBuffers","isCharacterAllowedAfterRelativePathSegment","pop","colonPosition","searchOffset","pathSeparator","character"],"sourceRoot":""}