{"version":3,"file":"js/577.4bbb23fa.js","mappings":"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","sources":["webpack://pko-rapid-triples/./node_modules/http-link-header/lib/link.js","webpack://pko-rapid-triples/./node_modules/relative-to-absolute-iri/lib/Resolve.js","webpack://pko-rapid-triples/./node_modules/relative-to-absolute-iri/index.js","webpack://pko-rapid-triples/./node_modules/canonicalize/lib/canonicalize.js"],"sourcesContent":["'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value ) ||\n    !TOKEN_PATTERN.test( value )\n}\n\n/**\n * Shallow compares two objects to check if their properties match.\n * @param {object} object1 First object to compare.\n * @param {object} object2 Second object to compare.\n * @returns {boolean} Do the objects have matching properties.\n */\nfunction shallowCompareObjects( object1, object2 ) {\n  return (\n    Object.keys( object1 ).length === Object.keys( object2 ).length &&\n    Object.keys( object1 ).every(\n      ( key ) => key in object2 && object1[ key ] === object2[ key ]\n    )\n  );\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n    var type = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ].rel === 'string' && this.refs[ i ].rel.toLowerCase() === type ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n    value = value.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ][ attr ] === 'string' && this.refs[ i ][ attr ].toLowerCase() === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /** Sets a reference. */\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  /**\n   * Sets a reference if a reference with similar properties isnâ€™t already set.\n   */\n  setUnique( link ) {\n\n    if( !this.refs.some(( ref ) => shallowCompareObjects( ref, link )) ) {\n      this.refs.push( link )\n    }\n\n    return this\n\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n    value = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ][ attr ] === 'string' && this.refs[ i ][ attr ].toLowerCase() === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          if( ref != null ) {\n            ref.rel != null ?\n              this.refs.push( ...Link.expandRelations( ref ) ) :\n              this.refs.push( ref )\n          }\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          // this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) end = value.indexOf( ';', offset )\n        if( end === -1 ) end = value.length\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    if( ref != null ) {\n      ref.rel != null ?\n        this.refs.push( ...Link.expandRelations( ref ) ) :\n        this.refs.push( ref )\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\nLink.expandRelations = function( ref ) {\n  var rels = ref.rel.split( ' ' )\n  return rels.map( function( rel ) {\n    var value = Object.assign( {}, ref )\n    value.rel = rel\n    return value\n  })\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDotSegmentsOfPath = exports.removeDotSegments = exports.resolve = void 0;\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Resolve\"), exports);\n//# sourceMappingURL=index.js.map","/* jshint esversion: 6 */\n/* jslint node: true */\n'use strict';\n\nmodule.exports = function serialize (object) {\n  if (object === null || typeof object !== 'object' || object.toJSON != null) {\n    return JSON.stringify(object);\n  }\n\n  if (Array.isArray(object)) {\n    return '[' + object.reduce((t, cv, ci) => {\n      const comma = ci === 0 ? '' : ',';\n      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;\n      return t + comma + serialize(value);\n    }, '') + ']';\n  }\n\n  return '{' + Object.keys(object).sort().reduce((t, cv, ci) => {\n    if (object[cv] === undefined ||\n        typeof object[cv] === 'symbol') {\n      return t;\n    }\n    const comma = t.length === 0 ? '' : ',';\n    return t + comma + serialize(cv) + ':' + serialize(object[cv]);\n  }, '') + '}';\n};\n"],"names":["COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","TOKEN_PATTERN","STATE","IDLE","URI","ATTR","trim","value","replace","hasWhitespace","test","skipWhitespace","offset","needsQuotes","shallowCompareObjects","object1","object2","Object","keys","length","every","key","Link","constructor","this","refs","parse","rel","links","type","toLowerCase","i","push","get","attr","set","link","setUnique","some","ref","has","slice","state","Error","expandRelations","end","indexOf","uri","attrValue","isSingleOccurenceAttr","parseExtendedValue","Array","isArray","toString","reduce","formatAttribute","join","isCompatibleEncoding","isTokenAttr","escapeQuotes","rels","split","map","assign","parts","exec","language","encoding","decodeURIComponent","formatExtendedAttribute","data","toUpperCase","encodedValue","Buffer","isBuffer","encodeURIComponent","item","module","exports","resolve","relativeIRI","baseIRI","baseFragmentPos","substr","startsWith","baseQueryPos","relativeColonPos","removeDotSegmentsOfPath","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","removeDotSegments","baseIRIPath","baseIRILastSlashPos","lastIndexOf","path","segmentBuffers","isCharacterAllowedAfterRelativePathSegment","pop","buffer","iri","colonPosition","searchOffset","pathSeparator","base","character","defineProperty","__createBinding","create","o","m","k","k2","undefined","enumerable","__exportStar","p","prototype","hasOwnProperty","call","serialize","object","toJSON","JSON","stringify","t","cv","ci","comma","sort"],"sourceRoot":""}