{"version":3,"file":"js/55.a22c6327.js","mappings":"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","sources":["webpack://mobilitydcatap-ui/./node_modules/@graphy/content.trig.read/main.js","webpack://mobilitydcatap-ui/./node_modules/@graphy/core.iso.stream/main.js"],"sourcesContent":["\n\n\n// queueMicrotask shim\n{\n\t// not defined or not a function\n\tif('function' !== typeof queueMicrotask) {\n\t\t// create resolved promise\n\t\tlet dp_resolve = Promise.resolve();\n\n\t\t// try to redefine\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-global-assign\n\t\t\tqueueMicrotask = fk => dp_resolve.then(fk)\n\t\t\t\t.catch(e_callback => setTimeout(() => {\n\t\t\t\t\tthrow e_callback;\n\t\t\t\t}, 0));\n\t\t}\n\t\t// oh well, at least we tried\n\t\tcatch(e_define) {}\n\t}\n}\n\n\n\nconst uri = require('uri-js');\nconst string_decoder = require('string_decoder');\n\nconst stream = require('@graphy/core.iso.stream');\nconst factory = require('@graphy/core.data.factory');\nconst quad = k => factory.quad(k._kt_subject, k._kt_predicate, k._kt_object, k._kt_graph);\n\n// eslint-disable-next-line no-misleading-character-class\nconst RT_PREFIXED_NAME_NAMESPACE_VALID = /^([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}]([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.]*[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}])?)?$/u;\n// eslint-disable-next-line no-misleading-character-class\nconst RT_PREFIXED_NAME_LOCAL_NAME_VALID = /^([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_:0-9]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])(([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])*([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%]))?$/u;\n// eslint-disable-next-line no-misleading-character-class\nconst RT_BLANK_NODE_VALID = /^[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_0-9]([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.]*[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}])?$/u;\nconst RT_NAMED_NODE_VALID = /^([^\\0-\\x20<>\"{}|^`\\\\]|\\\\u[A-Fa-f0-9]{4}|\\\\U[A-Fa-f0-9]{8})*$/;\nconst RT_NAMED_NODE_ESCAPELESS_VALID = /^([^\\0-\\x20<>\"{}|^`])*$/;\n\nconst RT_LITERAL_CONTENTS_VALID = /^(?:[^\\\\]|\\\\[tbnrf\"'\\\\]|\\\\u[A-Fa-f0-9]{4}|\\\\U[A-Fa-f0-9]{8})*$/;\n\nconst R_UNICODE_ANY = /\\\\u([0-9A-Fa-f]{4})|\\\\U([0-9A-Fa-f]{8})/g;\n\nconst F_REPLACE_UNICODE_ANY = \t(s_, s_4, s_8) => String.fromCodePoint(parseInt(s_4 || s_8, 16));\n\nconst OPHOP = Object.prototype.hasOwnProperty;\n\n\n\nconst R_PREFIXED_NAME_QUICK = /([A-Za-z][A-Za-z0-9_-]*)?:([A-Za-z_0-9:][A-Za-z0-9_:-]*)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\n\nconst R_PREFIXED_NAME_ESCAPELESS = /([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:[^\\s#@<[(\"'.;,{})\\]\\\\](?:[^\\s#@<[(\"';,{})\\]\\\\]*[^\\s#@<[(\"'.;,{})\\]\\\\])?)?)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\n\n\nconst R_PREFIXED_NAME = /([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))(?:(?:[^\\s#@<[(\"';,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))*(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"])))?)?)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\nconst R_PN_LOCAL_ESCAPES = /\\\\(.)/g;\n\n\nconst R_BLANK_NODE_LABEL = /_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)(?:\\s+|(?=[<:{,;\\])#]))/y;\nconst R_BLANK_NODE_LABEL_TERMINAL = /_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)(?:\\s+|(?=\\.?[<:{,;\\])#])|(?=\\.[\\s@#<({[}]))/y;\n\nconst R_IRIREF_ESCAPELESS = /<([^\\\\>]*)>\\s*/y;\nconst R_IRIREF = /<([^>]*)>\\s*/y;\n\nconst R_NUMERIC_LITERAL = /([+-]?(?:[0-9]+(\\.[0-9]+)?|(\\.[0-9]+))(\\.?[eE][+-]?[0-9]+)?)(?:\\s+|(?=\\.[^eE0-9]|[;,)\\]]))/y;\nconst R_BOOLEAN_LITERAL = /(?:(true|TRUE)|false|FALSE)\\s*/y;\nconst R_A = /a(?:\\s+|(?=[[(\"'<#]))/y;\n\nconst R_DOUBLE_CARET = /\\^\\^/y;\nconst R_WS = /\\s*/y;\nconst R_LANGTAG = /@([A-Za-z]+(?:-[A-Za-z0-9-]+)*)(?:\\s+|(?=[.},;\\])#]))/y;\n\nconst R_PREFIX_KEYWORD = /(?:(@prefix)|[pP][rR][eE][fF][iI][xX])\\s*/y;\nconst R_PREFIX_ID = /([^#:]*):\\s*/iy;\nconst R_BASE_KEYWORD = /(?:(@base)|[bB][aA][sS][eE])\\s*/y;\n\nconst R_GRAPH_IRI_ESCAPELESS = /(?:graph)?\\s*<([^\\\\>]*)>\\s*\\{\\s*/iy;\nconst R_GRAPH_PREFIXED_NAME = /(?:graph)?\\s*([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))(?:(?:[^\\s#@<[(\"';,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))*(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"])))?)?)\\s*\\{\\s*/iy;\nconst R_GRAPH_LABELED_BLANK_NODE = /(?:graph)?\\s*_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)\\s*\\{\\s*/iy;\nconst R_GRAPH_ANONYMOUS_BLANK_NODE = /(?:graph)?\\s*\\[\\s*\\]\\s*\\{\\s*/iy;\nconst R_GRAPH_IRI = /(?:graph)?\\s*<([^>]*)>\\s*\\{\\s*/iy;\nconst R_GRAPH = /graph(?:\\s+|(?=[#<[{]))/iy;\n\nconst R_COMMENT = /(#[^\\n]*\\n\\s*)+/y;\n\nconst RT_IRI_ABSOLUTE = /^[A-Za-z][A-Za-z0-9.\\-+]*:/;\nconst R_RELATIVE_URI = /^(\\/[^?#]+)([?#].*)?$/;\nconst R_BASE_IRI = /^((([A-Za-z0-9.\\-+]*:\\/)?\\/[^/>]*)?(\\/(?:[^/>]*\\/)*)?[^>]*)$/;\n\nconst R_ANONYMOUS_BLANK_NODE = /\\[\\s*\\]\\s*/y;\nconst R_CHAR_BLANK_NODE = /\\[(?:\\s+|(?=[^\\]]))/y;\nconst R_CHAR_COLLECTION = /\\(\\s*/y;\n\nconst R_CHAR_KET = /\\]\\s*/y;\n\nconst R_CHAR_OPEN = /\\{\\s*/y;\nconst R_CHAR_CLOSE = /\\}\\s*/y;\n\nconst R_CHAR_STOP = /\\.\\s*/y;\n\n\n\nconst R_STRLIT_SHORT_DOUBLE_BREAK = /[\\\\\"\\r\\n]/g;\nconst R_STRLIT_SHORT_SINGLE_BREAK = /[\\\\'\\r\\n]/g;\n\nconst R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM = /\"{1,2}$/g;\nconst R_STRLIT_LONG_SINGLE_UNFINISHED_TERM = /'{1,2}$/g;\n\nconst R_STRLIT_LONG_DOUBLE_BREAK = /(\\\\|\"\"\")/g;\nconst R_STRLIT_LONG_SINGLE_BREAK = /(\\\\|''')/g;\n\n\nconst F_REPLACE_STRLIT_CONTENTS = (s_, s_whitespace, s_auto, s_4, s_8, s_invalid) => {\n\tif(s_whitespace) {\n\t\tswitch(s_whitespace) {\n\t\t\tcase 't': return '\\t';\n\t\t\tcase 'n': return '\\n';\n\t\t\tcase 'r': return '\\r';\n\t\t\tcase 'f': return '\\f';\n\t\t\tcase 'b': return '\\b';\n\t\t\tdefault: {\n\t\t\t\tconsole.assert(`bad regex escape char mapping: '${s_whitespace}'`);\n\t\t\t}\n\t\t}\n\t}\n\telse if(s_auto) {\n\t\treturn s_auto;\n\t}\n\telse if(s_4) {\n\t\treturn String.fromCodePoint(parseInt(s_4, 16));\n\t}\n\telse if(s_8) {\n\t\treturn String.fromCodePoint(parseInt(s_8, 16));\n\t}\n\telse if(s_invalid) {\n\t\t// pointless escape\n\t\tif('\\\\' === s_invalid[0]) {\n\t\t\t\t// // relaxed\n\t\t\t\t// return s_invalid[1];\n\t\t\t// if relaxed then return s_invalid, otherwise throw:\n\t\t\tthrow new Error(`expected string_literal but invalid escape sequence within contents: '${s_invalid}'. failed to parse a valid token`);\n\t\t}\n\t\t// bad character\n\t\telse {\n\t\t\tthrow new Error(`expected string_literal but invalid whitespace character within contents: ${JSON.stringify(s_invalid)}. failed to parse a valid token`);\n\t\t}\n\t}\n\telse {\n\t\tconsole.assert(`unexpected no match branch in escape sequence replace callback`);\n\t}\n};\n\n\nconst R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\\r\\n]|\\\\.))/g;\nconst R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\\r\\n]|\\\\[^uU]|\\\\u[^]{4}|\\\\U[^]{8}))/g;\n\nconst unescape_literal_short_hard = s_literal => s_literal\n\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD, F_REPLACE_STRLIT_CONTENTS);\n\nconst unescape_literal_short_soft = (s_literal) => {\n\tlet m_incomplete = R_STRLIT_ESCAPE_INCOMPLETE.exec(s_literal);\n\n\t// incomplete escape\n\tif(m_incomplete) {\n\t\tlet i_safe = m_incomplete.index;\n\n\t\t// rewind\n\t\treturn [\n\t\t\ts_literal.slice(0, i_safe)\n\t\t\t\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\ts_literal.slice(i_safe),\n\t\t];\n\t}\n\t// done\n\telse {\n\t\treturn [\n\t\t\ts_literal\n\t\t\t\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\t'',\n\t\t];\n\t}\n};\n\n\nconst R_STRLIT_LONG_CONTENTS_ESCAPES_HARD = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|(\\\\.))/g;\nconst R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|(\\\\[^uU]|\\\\u[^]{4}|\\\\U[^]{8}))/g;\n\nconst unescape_literal_long_hard = s_literal => s_literal\n\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_HARD, F_REPLACE_STRLIT_CONTENTS);\n\nconst unescape_literal_long_soft = (s_literal) => {\n\tlet m_incomplete = R_STRLIT_ESCAPE_INCOMPLETE.exec(s_literal);\n\n\t// incomplete escape\n\tif(m_incomplete) {\n\t\tlet i_safe = m_incomplete.index;\n\n\t\t// rewind\n\t\treturn [\n\t\t\ts_literal.slice(0, i_safe)\n\t\t\t\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\ts_literal.slice(i_safe),\n\t\t];\n\t}\n\t// done\n\telse {\n\t\treturn [\n\t\t\ts_literal\n\t\t\t\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\t'',\n\t\t];\n\t}\n};\n\n// lookbehind regexes\nconst [\n\tR_STRLIT_ESCAPE_INCOMPLETE,\n\tR_STRLIT_SHORT_DOUBLE_TERM,\n\tR_STRLIT_SHORT_SINGLE_TERM,\n\tR_STRLIT_LONG_DOUBLE_TERM,\n\tR_STRLIT_LONG_SINGLE_TERM,\n] = (() => {\n\tfunction RegExp_$lookbehind_polyfill(s_input) {\n\t\tlet m_match = RegExp.prototype.exec.call(this, s_input);\n\n\t\tif(m_match) {\n\t\t\tlet i_start = m_match[0].length - m_match[1].length;\n\t\t\tm_match.index += i_start;\n\t\t\tm_match[0] = m_match[0].slice(i_start);\n\t\t}\n\n\t\treturn m_match;\n\t}\n\tlet mk_lookbehind_regex = (() => {\n\t\ttry {\n\t\t\tnew RegExp('(?<!h)i');  // eslint-disable-line no-new\n\t\t}\n\t\tcatch(e_compile) {\n\t\t\treturn (f_lookbehind, r_polyfill, f_polyfill) => {\n\t\t\t\tr_polyfill.exec = f_polyfill;\n\t\t\t\treturn r_polyfill;\n\t\t\t};\n\t\t}\n\t\treturn f_lookbehind => f_lookbehind();\n\t})();\n\treturn [\n\t\t// R_STRLIT_ESCAPE_INCOMPLETE\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\\\\\\\(|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7})$'),\n\t\t\t/^(?:(?:[^\\\\]|\\\\.)*)(\\\\(?:|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7}))$/,\n\t\t\tfunction RegExp_$lookbehind_polyfill_n(s_input) {\n\t\t\t\tlet m_match = RegExp.prototype.exec.call(this, s_input);\n\t\t\t\tif(m_match) {\n\t\t\t\t\tm_match.index += m_match[0].length - m_match[1].length;\n\t\t\t\t}\n\n\t\t\t\treturn m_match;\n\t\t\t},\n\t\t),\n\t\t// R_STRLIT_SHORT_DOUBLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\"\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\\"]|\\\\.)*(\"\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\t\t// R_STRLIT_SHORT_SINGLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\'\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\']|\\\\.)*('\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t\t// R_STRLIT_LONG_DOUBLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\"\"\"\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\\"]|\\\\.|\"\"?(?!\"))*(\"\"\"\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t\t// R_STRLIT_LONG_SINGLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\'\\'\\'\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\']|\\\\.|''?(?!'))*('''\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t];\n})();\n\nconst match_prefixed_name_quick = (s, i) => {\n\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\treturn [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];\n};\n\nconst match_prefixed_name_escapeless = (s, i) => {\n\tR_PREFIXED_NAME_ESCAPELESS.lastIndex = i;\n\treturn [R_PREFIXED_NAME_ESCAPELESS.exec(s), R_PREFIXED_NAME_ESCAPELESS.lastIndex];\n};\n\nconst match_prefixed_name = (s, i) => {\n\tR_PREFIXED_NAME.lastIndex = i;\n\treturn [R_PREFIXED_NAME.exec(s), R_PREFIXED_NAME.lastIndex];\n};\n\n\n\nfunction Reader$syntax_error(k_self, i, si_state, s_info) {\n\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\tlet s = k_self.s;\n\n\treturn k_self.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t+`expected ${si_state} ${s_info || ''}.  failed to parse a valid token starting at ${s[i]? '\"'+s[i]+'\"': '<<EOF>>'}`);\n}\n\n\n\nclass TriG_Reader extends stream.Transform {\n\tconstructor(g_impls) {\n\t\tsuper({\n\t\t\t// do not decode strings into buffers\n\t\t\tdecodeStrings: false,\n\n\t\t\t// accept strings as input on writable side\n\t\t\twritableObjectMode: false,\n\n\t\t\t// output quad objects on readable side\n\t\t\treadableObjectMode: true,\n\n\t\t\t// implementations\n\t\t\tflush: g_impls.flush,\n\t\t\ttransform: g_impls.transform,\n\t\t});\n\t}\n\n\t// intercept pipe\n\tpipe(ds_out) {\n\t\tlet ds_dst = ds_out;\n\n\t\t// non-object mode\n\t\tif(!ds_dst._writableState.objectMode) {\n\t\t\t// transform to JSON\n\t\t\tds_out = stream.quads_to_json();\n\t\t}\n\t\t// yet object mode and graphy writable\n\t\telse if(ds_out.isGraphyWritable) {\n\t\t\t// transform to writable data events\n\t\t\tds_out = stream.quads_to_writable();\n\t\t}\n\n\t\t// interim stream created\n\t\tif(ds_out !== ds_dst) {\n\t\t\t// forward output to super\n\t\t\tsuper.pipe(ds_out);\n\n\t\t\t// pipe outpu to destination\n\t\t\treturn ds_out.pipe(ds_dst);\n\t\t}\n\t\t// forward as-is to super\n\t\telse {\n\t\t\treturn super.pipe(ds_dst);\n\t\t}\n\t}\n}\n\n\nclass Reader {\n\tconstructor(g_config={}) {\n\t\t// impl-specific configs\n\t\tlet {\n\t\t\t// input medium\n\t\t\tinput: g_input=null,\n\n\t\t\t// a state to inherit\n\t\t\tstate: g_state={},\n\t\t} = g_config;\n\n\t\t// inherit state from creator\n\t\tlet {\n\t\t\t// index for anonymous blank node labels\n\t\t\tblank_node_index: i_anon=0,\n\n\t\t\t// prefix map\n\t\t\tprefixes: h_prefixes={},\n\n\t\t\t// blank node label map\n\t\t\tlabels: h_labels={},\n\t\t} = g_state;\n\n\n\t\tlet dc_factory = factory.adopt(g_config.dataFactory || g_config.data_factory || factory.unfiltered);\n\n\t\tlet kt_default_graph = dc_factory.defaultGraph();\n\n\t\t// if data factory is not graphy, it might be returning the same object on each call to .defaultGraph()\n\t\tif(dc_factory !== factory.unfiltered) {\n\t\t\t// do not trust it, create a new object\n\t\t\tkt_default_graph = Object.create(kt_default_graph);\n\t\t}\n\n\t\tlet kt_rdf_first = dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first');\n\n\t\tlet blankNode = dc_factory.blankNode;\n\t\tlet namedNode = dc_factory.namedNode;\n\n\t\tthis.emit_data = factory.unfiltered === dc_factory\n\t\t\t? function() {\n\t\t\t\tds_transform.push(quad(this));\n\t\t\t}\n\t\t\t: function() {\n\t\t\t\tlet g_quad = dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);\n\t\t\t\tds_transform.push(g_quad);\n\t\t\t};\n\n\t\t// fields\n\t\tObject.assign(this, {\n\t\t\t// read index\n\t\t\ti: 0,\n\n\t\t\t// string buffer\n\t\t\ts: '',\n\n\t\t\t// string buffer length\n\t\t\tn: 0,\n\n\t\t\t// left-over string from previous data chunk\n\t\t\tpre: g_config.prepend || '',\n\n\t\t\t// debug state\n\t\t\t_b_debug: g_config.debug || false,\n\n\t\t\t// relax\n\t\t\t_b_relax: g_config.relax || false,\n\n\t\t\t// factory\n\t\t\t_dc_factory: dc_factory,\n\n\t\t\t// current reader state\n\t\t\t_f_state: this.block,\n\n\t\t\t// map of current prefix ids => iris\n\t\t\t_h_prefixes: h_prefixes,\n\n\n\t\t\t// reader was destroyed by an error\n\t\t\t_b_destroyed: false,\n\n\t\t\t// current @base url\n\t\t\t_s_base_url: '',\n\t\t\t_s_base_url_scheme: '',\n\t\t\t_s_base_url_root: '',\n\t\t\t_s_base_url_path: '',\n\n\t\t\t// current data\n\t\t\t_kt_subject: null,\n\t\t\t_kt_predicate: kt_rdf_first,\n\t\t\t_kt_object: null,\n\t\t\t_kt_graph: kt_default_graph,\n\t\t\t_s_literal: '',\n\n\t\t\t// static terms\n\t\t\t_kt_rdf_type: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),\n\t\t\t_kt_rdf_first: kt_rdf_first,\n\t\t\t_kt_rdf_rest: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest'),\n\t\t\t_kt_rdf_nil: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil'),\n\t\t\t_kt_default_graph: kt_default_graph,\n\n\t\t\t// queue of nested subject, predicate, state for blanknodes and collections\n\t\t\t_a_nested: [],\n\n\t\t\t// hash to keep track of all blank node labels in use\n\t\t\t_h_labels: h_labels,\n\n\t\t\t// event routing\n\t\t\tevent: this.emit,\n\t\t\tdata: this.emit_data,\n\n\t\t\t// for restoring the original event callback when resuming paused stream\n\t\t\trestore_data: this.emit_data,\n\n\t\t\t// keep a queue of data events to hold onto until stream resumes (only happens in rare conditions)\n\t\t\t_a_queue_event: [],\n\n\t\t\t// helper states\n\t\t\t_b_expecting_full_stop: false,\n\t\t\t_s_temp_prefix_id: null,\n\t\t\t_b_trim_start: true,\n\n\t\t\tanonymous_blank_node: s_label => blankNode(s_label, true),\n\n\t\t\t// finds the next non-conflicting blank node label\n\t\t\tnext_label() {\n\t\t\t\tlet s_label = '';\n\t\t\t\tdo {\n\t\t\t\t\ts_label = 'g'+(i_anon++);\n\t\t\t\t} while(this._h_labels[s_label]);\n\n\t\t\t\t// claim this label, and remember that we invented it\n\t\t\t\tthis._h_labels[s_label] = 2;\n\n\t\t\t\t// return the label\n\t\t\t\treturn s_label;\n\t\t\t},\n\n\t\t\t// what to do when reach eos\n\t\t\teos: null,\n\n\t\t\t// which state to go to after end of statement\n\t\t\tafter_end_of_statement: this.post_object,\n\n\t\t\t// maximum length of a token: defaults to 2048 => http://stackoverflow.com/a/417184/1641160\n\t\t\t_n_max_token_length: g_config.max_token_length || g_config.maxTokenLength || 2048,\n\n\t\t\t// maximum length of a string (overrides max_token_length): defaults to Infinity\n\t\t\t_n_max_string_length: g_config.max_string_length || g_config.maxStringLength || Infinity,\n\n\t\t\t// byte tracking\n\t\t\t_b_byte_tracking: g_config.byte_tracking || g_config.byteTracking || false,\n\t\t\t_nb_seen: 0,\n\t\t\t_nb_last: 0,\n\t\t\t_nb_curr: 0,\n\t\t});\n\n\t\tif(g_config.relaxed) {\n\t\t\tconsole.warn((new Error(`no such option 'relaxed'; did you mean 'relax' ?`)).stack.replace(/^Error:/, 'Warning:'));\n\t\t}\n\t\tif('validate' in g_config) {\n\t\t\tconsole.warn((new Error(`option 'validate' has been deprecated. Validation is now enabled by default. Use the 'relax' option if you wish to disable validation.`)).stack.replace(/^Error:/, 'Warning:'));\n\t\t}\n\n\n\n\t\t// term constructors\n\t\tObject.assign(this, !g_config.relax\n\t\t\t? {\n\t\t\t\tblank_node(s_label) {\n\t\t\t\t\t// test valid blank node label\n\t\t\t\t\tif(!RT_BLANK_NODE_VALID.test(s_label)) return this.error(`invalid blank node label: \"${s_label}\"`);\n\n\t\t\t\t\t// not first time use of label\n\t\t\t\t\tlet z_label_state = this._h_labels[s_label];\n\t\t\t\t\tif(z_label_state) {\n\t\t\t\t\t\t// label was used previously by document and has no conflict\n\t\t\t\t\t\tif(1 === z_label_state) {}  // eslint-disable-line no-empty\n\t\t\t\t\t\t// label is in use by invention, this would cause a conflict\n\t\t\t\t\t\telse if(2 === z_label_state) {\n\t\t\t\t\t\t\t// so create a redirect mapping for this actual label & use it instead\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label] = this.next_label();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// label already has a redirect mapping\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// use redirected label\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first time use of label\n\t\t\t\t\telse {\n\t\t\t\t\t\t// store label in hash so we avoid future collisions\n\t\t\t\t\t\tthis._h_labels[s_label] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// make term\n\t\t\t\t\treturn blankNode(s_label);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node(p_iri) {\n\t\t\t\t\tif(!RT_NAMED_NODE_VALID.test(p_iri)) return this.error(`invalid IRI: \"${p_iri}\"`);\n\t\t\t\t\treturn namedNode(p_iri);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node_escapeless(p_iri) {\n\t\t\t\t\tif(!RT_NAMED_NODE_ESCAPELESS_VALID.test(p_iri)) return this.error(`invalid IRI: \"${p_iri}\"`);\n\t\t\t\t\treturn namedNode(p_iri);\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name_quick(s, i) {\n\t\t\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t\t\treturn [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name_escapeless(s, i) {\n\t\t\t\t\tlet [m_prefixed_name_e, im_prefixed_name_e] = match_prefixed_name_escapeless(s, i);\n\t\t\t\t\tif(m_prefixed_name_e) {\n\t\t\t\t\t\t// invalid local name\n\t\t\t\t\t\tif(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name_e[2]) && m_prefixed_name_e[2]) {\n\t\t\t\t\t\t\tthis.error(`invalid prefixed name local name: \"${m_prefixed_name_e[2]}:\"`);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [m_prefixed_name_e, im_prefixed_name_e];\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name(s, i) {\n\t\t\t\t\tlet [m_prefixed_name, im_prefixed_name] = match_prefixed_name(s, i);\n\t\t\t\t\tif(m_prefixed_name) {\n\t\t\t\t\t\t// invalid local name\n\t\t\t\t\t\tif(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name[2])) {\n\t\t\t\t\t\t\tthis.error(`invalid prefixed name local name: \"${m_prefixed_name[2]}:\"`);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [m_prefixed_name, im_prefixed_name];\n\t\t\t\t},\n\t\t\t}\n\t\t\t: {\n\t\t\t\t// term constructors\n\t\t\t\tblank_node(s_label) {\n\t\t\t\t\t// not first time use of label\n\t\t\t\t\tlet z_label_state = this._h_labels[s_label];\n\t\t\t\t\tif(z_label_state) {\n\t\t\t\t\t\t// label was used previously by document and has no conflict\n\t\t\t\t\t\tif(1 === z_label_state) {}  // eslint-disable-line no-empty\n\t\t\t\t\t\t// label is in use by invention, this would cause a conflict\n\t\t\t\t\t\telse if(2 === z_label_state) {\n\t\t\t\t\t\t\t// so create a redirect mapping for this actual label & use it instead\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label] = this.next_label();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// label already has a redirect mapping\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// use redirected label\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first time use of label\n\t\t\t\t\telse {\n\t\t\t\t\t\t// store label in hash so we avoid future collisions\n\t\t\t\t\t\tthis._h_labels[s_label] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// make term\n\t\t\t\t\treturn blankNode(s_label);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node: namedNode,\n\n\t\t\t\tcheck_named_node_escapeless: namedNode,\n\n\t\t\t\tmatch_prefixed_name_escapeless,\n\n\t\t\t\tmatch_prefixed_name,\n\t\t\t});\n\n\n\t\tthis.named_node = namedNode;\n\n\t\tthis.prefixed_name = function(si_prefix, s_suffix) {\n\t\t\treturn namedNode(h_prefixes[si_prefix] + s_suffix);\n\t\t};\n\n\n\t\t// oops -- user passed string into `base`\n\t\tif('string' === typeof g_config.base) {\n\t\t\tthrow new TypeError(`invalid type 'string' was given for 'base' event listener: '${g_config.base}'\\n`\n\t\t\t\t+`did you mean to use the 'base_uri' key instead?`);\n\t\t}\n\n\t\t// base uri\n\t\tlet p_set_base_uri = g_config.base_uri || g_config.baseUri || g_config.baseURI || g_config.base_iri || g_config.baseIri || g_config.baseIRI;\n\t\tif(p_set_base_uri) {\n\t\t\tlet m_base_iri = R_BASE_IRI.exec(p_set_base_uri);\n\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\t\t}\n\t\t// not set; 'url' variant is\n\t\telse if(g_config.base_url || g_config.baseUrl || g_config.baseURL) {\n\t\t\tthrow new Error(`invalid option: .base${g_config.base_url? '_url': g_config.baseUrl? 'Url': g_config.baseURL? 'URL': ''}; use the '.base_uri' key instead`);\n\t\t}\n\n\t\t// transform stream\n\t\tlet ds_transform = this.transform = new TriG_Reader({\n\t\t\t// on data event\n\t\t\ttransform: (s_chunk, s_encoding, fke_chunk) => {\n\t\t\t\t// concatenate current chunk to previous chunk\n\t\t\t\tlet s = this.s = this.pre + s_chunk;\n\n\t\t\t\t// cache chunk length\n\t\t\t\tthis.n = s.length;\n\n\t\t\t\t// eat whitespace before token and reset index\n\t\t\t\tif(this._b_trim_start) {\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\tR_WS.lastIndex = 0;\n\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\tthis.i = R_WS.lastIndex;\n\t\t\t\t}\n\t\t\t\t// do not eat whitespace; start at beginning\n\t\t\t\telse {\n\t\t\t\t\tthis.i = 0;\n\t\t\t\t}\n\n\t\t\t\t// resume parsing; no errors\n\t\t\t\tif(this.safe_parse(true)) {\n\t\t\t\t\t// emit progress event updates\n\t\t\t\t\tds_transform.emit('progress', s_chunk.length);\n\n\t\t\t\t\t// done transforming this chunk\n\t\t\t\t\tfke_chunk();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// once there's no more data to consume, invoke eof\n\t\t\tflush: (fke_flush) => {\n\t\t\t\t// now that input stream has ended, clean up remainder\n\t\t\t\ttry {\n\t\t\t\t\tthis.eof(1);\n\t\t\t\t}\n\t\t\t\t// read error occurred\n\t\t\t\tcatch(e_eof) {\n\t\t\t\t\t// destroy self and stream\n\t\t\t\t\tthis.destroy(e_eof);\n\n\t\t\t\t\t// exit gracefully\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// no errors. done flushing, close read stream\n\t\t\t\tfke_flush();\n\t\t\t},\n\t\t});\n\n\t\t// when the writable side is piped into\n\t\tds_transform.on('pipe', (ds_input) => {\n\t\t\tthis._ds_input = ds_input;\n\n\t\t\tlet b_byte_tracking = this._b_byte_tracking;\n\n\t\t\t// byte-tracking is disable & input stream has encoding option; ensure stream encoding is utf8\n\t\t\tif(!b_byte_tracking && 'function' === typeof ds_input.setEncoding) {\n\t\t\t\tds_input.setEncoding('utf8');\n\t\t\t}\n\t\t\t// set decoding on write\n\t\t\telse {\n\t\t\t\tlet f_write = ds_transform.write;\n\t\t\t\tlet d_decoder = new string_decoder.StringDecoder('utf8');\n\n\t\t\t\tlet f_write_track = (s_chunk, s_encoding, fk_write) => {\n\t\t\t\t\t// TODO: optimize by testing for multibyte chars and using string length instead?\n\t\t\t\t\tlet nb_chunk = Buffer.from(s_chunk, 'utf8').length;\n\t\t\t\t\tthis._nb_seen += nb_chunk;\n\t\t\t\t\tthis._nb_last = nb_chunk;\n\t\t\t\t\treturn f_write.call(ds_transform, s_chunk, s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\tlet f_decode_write_track = (ab_chunk, s_encoding, fk_write) => {\n\t\t\t\t\tlet nb_chunk = this._nb_last = ab_chunk.length;\n\t\t\t\t\tthis._nb_seen += nb_chunk;\n\t\t\t\t\treturn f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\tlet f_decode_write = (ab_chunk, s_encoding, fk_write) => f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);\n\n\t\t\t\tds_transform.write = function(z_chunk, s_encoding, fk_write) {\n\t\t\t\t\t// not null\n\t\t\t\t\tif(null !== z_chunk) {\n\t\t\t\t\t\t// chunk is string; adapt by resetting method to original\n\t\t\t\t\t\tif('string' === typeof z_chunk) {\n\t\t\t\t\t\t\tds_transform.write = b_byte_tracking? f_write_track: f_write;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// chunk is buffer; adapt by setting decoder write method\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tds_transform.write = b_byte_tracking? f_decode_write_track: f_decode_write;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// use set method\n\t\t\t\t\t\treturn ds_transform.write(z_chunk, s_encoding, fk_write);\n\t\t\t\t\t}\n\n\t\t\t\t\t// null, use parent\n\t\t\t\t\treturn f_write.call(ds_transform, z_chunk, s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\t// byte tracking is enabled\n\t\t\t\tif(b_byte_tracking) {\n\t\t\t\t\t// overwrite emit_data method\n\t\t\t\t\tthis.emit_data = this.data = this.restore_data = function() {\n\t\t\t\t\t\tlet g_quad = this._dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);\n\t\t\t\t\t\tlet nb_post = Buffer.from(this.s.slice(this.i)).length;\n\t\t\t\t\t\tlet ib_post = this._nb_seen - nb_post;\n\t\t\t\t\t\tg_quad.byteRange = [this._nb_curr, ib_post];\n\t\t\t\t\t\tthis._nb_curr = ib_post;\n\t\t\t\t\t\tthis.transform.push(g_quad);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// new listener added\n\t\tds_transform.on('newListener', (s_event) => {\n\t\t\t// comment\n\t\t\tif('comment' === s_event) {\n\t\t\t\tthis.emit_comments = (s_captured) => {\n\t\t\t\t\tlet a_comments = s_captured.slice(1).replace(/\\n\\s+$/, '').split(/\\n+\\s*#/g);\n\n\t\t\t\t\tfor(let s_comment of a_comments) {\n\t\t\t\t\t\tds_transform.emit('comment', s_comment);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\t// destroy\n\t\tds_transform._destroy = (...a_args) => {\n\t\t\tthis.destroy(...a_args);\n\t\t};\n\n\t\t// bind events to transform stream\n\t\tthis.bind(g_config);\n\n\t\t// input given\n\t\tif(g_input) {\n\t\t\t// input is stream\n\t\t\tif(g_input.stream) {\n\t\t\t\tlet ds_input = g_input.stream;\n\n\t\t\t\t// go async so caller has chance to bind event listeners\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tds_input.pipe(ds_transform);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// string\n\t\t\telse if('string' === typeof g_input.string) {\n\t\t\t\tlet s_input = g_input.string;\n\n\t\t\t\t// go async so caller has chance to bind event listeners\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tds_transform.end(s_input, 'utf8');\n\t\t\t\t});\n\t\t\t}\n\t\t\t// invalid arg\n\t\t\telse {\n\t\t\t\tthrow new TypeError(`Invalid argument for input parameter: ${'object' === typeof g_input? JSON.stringify(g_input): g_input}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// begin parsing, keep applying until no more stack bail-outs\n\tsafe_parse() {\n\t\ttry {\n\t\t\tlet f_sync = this._f_state();\n\t\t\twhile('function' === typeof f_sync) {\n\t\t\t\tf_sync = f_sync.apply(this);\n\t\t\t}\n\t\t}\n\t\t// read error occurred\n\t\tcatch(e_read) {\n\t\t\t// destroy self and stream\n\t\t\tthis.destroy(e_read);\n\n\t\t\t// failure\n\t\t\treturn false;\n\t\t}\n\n\t\t// okay\n\t\treturn true;\n\t}\n\n\n\temit(s_event, ...a_args) {\n\t\tthis.transform.emit(s_event, ...a_args);\n\t}\n\n\tqueue(s_event, ...a_args) {\n\t\tthis._a_queue_event.push({\n\t\t\tevent: s_event,\n\t\t\targs: a_args,\n\t\t});\n\t}\n\n\terror(s_message) {\n\t\t// bail out\n\t\tthrow new Error(s_message);\n\t}\n\n\t// parse_error (not meant to be an event callback)\n\tparse_error(s_expected, b_eof=false) {\n\t\tlet i = this.i;\n\n\t\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\t\tlet s = this.s;\n\n\t\treturn this.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t\t+`expected ${s_expected} ${b_eof? 'but encountered <<EOF>>': ''}.  failed to parse a valid token starting at ${s[i]? '\"'+s[i]+'\"': '<<EOF>>'}`);\n\t}\n\n\tinfo_error(s_message) {\n\t\tlet i = this.i;\n\n\t\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\t\tlet s = this.s;\n\n\t\tthis.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t\t+s_message);\n\t}\n\n\t// end of file\n\teof() {\n\t\t// there are events queued\n\t\tif(this._a_queue_event.length) {\n\t\t\tlet a_queue = this._a_queue_event;\n\n\t\t\t// drain event queue\n\t\t\twhile(a_queue.length) {\n\t\t\t\t// remove event from front of queue\n\t\t\t\tlet h_event = a_queue.shift();\n\n\t\t\t\t// make event callback\n\t\t\t\tthis[h_event.event](h_event.data);\n\t\t\t}\n\t\t}\n\n\t\t// invalid parsing state\n\t\tif(this.block !== this._f_state) {\n\t\t\t// append EOF char\n\t\t\tthis.s += '\\0';\n\n\t\t\t// exit \"flowing\" mode\n\t\t\tthis.n = this.s.length;\n\n\t\t\t// resume parsing; no errors\n\t\t\tif(this.safe_parse()) {\n\t\t\t\t// eof has occurred under safe parse\n\t\t\t\tif(null === this.s) return;\n\n\t\t\t\t// still invalid parsing state\n\t\t\t\tif(this.block !== this._f_state) {\n\t\t\t\t\treturn this.parse_error(this._f_state.name, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// there are still unparsed characters\n\t\tif(this.i < this.n) {\n\t\t\t// consume whitespace and comments\n\t\t\tlet s = this.s;\n\t\t\tlet i = this.i;\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i;\n\t\t\tR_WS.exec(s);\n\t\t\ti = R_WS.lastIndex;\n\t\t\tR_COMMENT.lastIndex = i;\n\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t// advance beyond comment\n\t\t\tif(R_COMMENT.lastIndex > i) {\n\t\t\t\tthis.i = i = R_COMMENT.lastIndex;\n\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t}\n\n\t\t\t// still unparsed characters\n\t\t\tif(i < this.n) {\n\t\t\t\t// not EOF\n\t\t\t\tif(!(i === this.n - 1 && '\\0' === s[i])) {\n\t\t\t\t\t// bad input; parse error\n\t\t\t\t\treturn this.parse_error(this._f_state.name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// make buffer's alloc eligible for gc\n\t\tthis.s = null;\n\n\t\t// transform stream\n\t\tlet ds_transform = this.transform;\n\n\t\t// final progress update: no additional bytes were read\n\t\tds_transform.emit('progress', 0);\n\n\t\t// call end event listener\n\t\tds_transform.emit('eof', this._h_prefixes);\n\n\t\t// close write stream (EOF-signaling)\n\t\tds_transform.push(null);\n\t}\n\n\n\n\t// bind event listeners to transform stream\n\tbind(g_config) {\n\t\tlet ds_transform = this.transform;\n\t\tif(g_config.base) ds_transform.on('base', g_config.base);\n\t\tif(g_config.prefix) ds_transform.on('prefix', g_config.prefix);\n\t\tif(g_config.enter) ds_transform.on('enter', g_config.enter);\n\t\tif(g_config.exit) ds_transform.on('exit', g_config.exit);\n\t\tif(g_config.comment) ds_transform.on('comment', g_config.comment);\n\t\tif(g_config.error) ds_transform.on('error', g_config.error);\n\t\tif(g_config.read) ds_transform.once('read', g_config.read);\n\t\tif(g_config.progress) ds_transform.on('progress', g_config.progress);\n\t\tif(g_config.eof) ds_transform.once('eof', g_config.eof);\n\t\tif(g_config.end) ds_transform.once('end', g_config.end);\n\t\tif(g_config.finish) ds_transform.once('finish', g_config.finish);\n\t\tif(g_config.data) ds_transform.on('data', g_config.data);\n\t}\n\n\t// after a blank node subject (either property-list or colleciton)\n\tpost_blank_subject() {\n\t\tlet {s, i} = this;\n\t\tif('.' === s[i]) {\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i+1;\n\t\t\tR_WS.exec(s);\n\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t// not inside block\n\t\t\tif(this._kt_default_graph === this._kt_graph) {\n\t\t\t\treturn this.block();\n\t\t\t}\n\t\t\t// inside block\n\t\t\telse {\n\t\t\t\treturn this.statement();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// prepare sticky regex index\n\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t// empty collection\n\t\t\t\tif(this._kt_rdf_nil.equals(this._kt_subject)) {\n\t\t\t\t\treturn this.error('empty collection');\n\t\t\t\t}\n\n\t\t\t\t// emit graph_close event\n\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t// reset graph\n\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t// goto block state\n\t\t\t\treturn this.block();\n\t\t\t}\n\t\t} // brace #1\n\n\t\treturn this.pairs();\n\t}\n\n\n\n\t// parse state for statement\n\tstatement() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefixed name quick\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_pnq_subject = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_pnq_subject) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_pnq_subject[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// commit subject iri from resolve prefixed name\n\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_pnq_subject[2]);\n\n\t\t\t\t// predicate-object pairs state\n\t\t\t\treturn this.pairs();\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_subject = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_subject) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_subject[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set subject\n\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t}\n\n\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\treturn this.pairs();\n\n\n\n\t\t\t\t// prefixed name\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// try match\n\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t// stack bail out\n\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\tlet [m_prefixed_named_e_subject, im_prefixed_named_e_subject] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\tif(m_prefixed_named_e_subject) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = im_prefixed_named_e_subject;\n\n\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_subject[1] || '';\n\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_prefixed_named_e_subject[2]);\n\n\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t// blank node label\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_blank_node_label_subject = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_blank_node_label_subject) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t// extract label\n\t\t\t\t\t\t\tlet s_label = m_blank_node_label_subject[1];\n\n\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\tthis._kt_subject = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// anonymous blank node subject\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t// set new blank node as subject\n\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t// anonymous blank node property list subject\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_CHAR_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\tif(R_CHAR_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t// how to resume when we pop state\n\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_blank_subject']);\n\n\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t// rdf collection\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_CHAR_COLLECTION.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\tif(R_CHAR_COLLECTION.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_COLLECTION.lastIndex;\n\t\t\t\t\t\t\t\t\t\t// indicate that collection subject should emit an initial statement\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = null;\n\n// (don't push state, we don't have a subject yet)\n\n\t\t\t\t\t\t\t\t\t\t// goto collection-subject state\n\t\t\t\t\t\t\t\t\t\treturn this.collection_subject();\n\n\n\t\t\t\t\t\t\t\t\t// closing graph '}'\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t// emit graph_close event\n\t\t\t\t\t\t\t\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t\t\t\t\t\t\t\t// reset graph\n\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t\t\t\t\t\t\t\t// goto block state\n\t\t\t\t\t\t\t\t\t\t\treturn this.block();\n\n\t\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\tlet m_iriref_subject = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\tif(m_iriref_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_subject[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_subject, im_prefixed_named_subject] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_subject;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_subject[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t// match counter: 10\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} // brace #10\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('statement');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.statement;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for block\n\tblock() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prepare sticky regex index\n\t\t\tR_GRAPH_IRI_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_graph_iriref_e_graph = R_GRAPH_IRI_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_graph_iriref_e_graph) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_GRAPH_IRI_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_graph_iriref_e_graph[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set graph\n\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_GRAPH_PREFIXED_NAME.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_graph_prefixed_name = R_GRAPH_PREFIXED_NAME.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_graph_prefixed_name) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_GRAPH_PREFIXED_NAME.lastIndex;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_graph_prefixed_name[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// make subject key\n\t\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, m_graph_prefixed_name[2]);\n\n\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t// statement state\n\t\t\t\t\treturn this.statement();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_CHAR_OPEN.lastIndex = i;\n\n\t\t\t\t\tif(R_CHAR_OPEN.exec(s)) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_CHAR_OPEN.lastIndex;\n\t\t\t\t\t\t// make new default graph\n\t\t\t\t\t\tthis._kt_graph = this._dc_factory.defaultGraph();\n\n\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t// goto statement state\n\t\t\t\t\t\treturn this.statement();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_GRAPH_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_graph_anonymous_blank_node = R_GRAPH_ANONYMOUS_BLANK_NODE.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_graph_anonymous_blank_node) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_GRAPH_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t// make new label & set graph to blank node\n\t\t\t\t\t\t\tthis._kt_graph = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\treturn this.statement();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_GRAPH_LABELED_BLANK_NODE.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_graph_labeled_blank_node = R_GRAPH_LABELED_BLANK_NODE.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_graph_labeled_blank_node) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_GRAPH_LABELED_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\tlet s_label = m_graph_labeled_blank_node[1];\n\n\t\t\t\t\t\t\t\tthis._kt_graph = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\t\treturn this.statement();\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_e_graph_subject = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_e_graph_subject) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_e_graph_subject[1];\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// graph or subject\n\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_e_subject, im_prefixed_named_e_subject] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_e_subject) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_e_subject;\n\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_prefixed_named_e_subject[2]);\n\n\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t// blank node label\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_blank_node_label_subject = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_blank_node_label_subject) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t// extract label\n\t\t\t\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_subject[1];\n\n\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t// anonymous blank node subject\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t// set new blank node as subject\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t// anonymous blank node property list subject\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\tR_CHAR_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif(R_CHAR_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// how to resume when we pop state\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_blank_subject']);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject_property_list();\n\n\t\t\t\t\t\t\t\t\t\t\t\t// rdf collection\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\tR_CHAR_COLLECTION.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(R_CHAR_COLLECTION.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_COLLECTION.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// indicate that collection subject should emit an initial statement\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = null;\n\n// (don't push state, we don't have a subject yet)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto collection-subject state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.collection_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prefix with interupt (e.g., a comment)\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_PREFIX_KEYWORD.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_prefix_keyword = R_PREFIX_KEYWORD.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefix_keyword) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_PREFIX_KEYWORD.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save whether or not to expect a full stop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._b_expecting_full_stop = !!m_prefix_keyword[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto prefix state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.prefix_id();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// base with interupt (e.g., a comment)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_BASE_KEYWORD.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_base_keyword = R_BASE_KEYWORD.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_base_keyword) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_BASE_KEYWORD.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save whether or not to expect a full stop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._b_expecting_full_stop = !!m_base_keyword[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto base state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.base_iri();\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_iriref_subject = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_iriref_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_subject[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_subject, im_prefixed_named_subject] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_subject;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_subject[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_GRAPH_IRI.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_graph_iriref_graph = R_GRAPH_IRI.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_graph_iriref_graph) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_GRAPH_IRI.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_graph_iriref_graph[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// set graph\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.statement();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_GRAPH.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(R_GRAPH.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_GRAPH.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_keyword();\n\n\t\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t\t// match counter: 17\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #17\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #16\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #15\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #14\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #13\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #12\n\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #11\n\t\t\t\t\t\t\t\t\t\t\t\t} // brace #10\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('block');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.block;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject\n\tgraph_or_subject() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// shift placeholder subject\n\t\t\t\tthis._kt_graph = this._kt_subject;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// reset subject in case of collections\n\t\t\t\tthis._kt_subject = null;\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject_property_list\n\tgraph_or_subject_property_list() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif(']' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// next state\n\t\t\t\treturn this.graph_or_subject_anon();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject_property_list');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject_property_list;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject_anon\n\tgraph_or_subject_anon() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// shift placeholder subject\n\t\t\t\tthis._kt_graph = this._kt_subject;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// reset subject in case of collections\n\t\t\t\tthis._kt_subject = null;\n\n\t\t\t\t// pop dummy state\n\t\t\t\tthis._a_nested.pop();\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject_anon');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject_anon;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_keyword\n\tgraph_keyword() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prefixed name\n\t\t\t// try match\n\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t// stack bail out\n\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\tlet [m_prefixed_named_e_graph, im_prefixed_named_e_graph] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\tif(m_prefixed_named_e_graph) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = im_prefixed_named_e_graph;\n\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_prefixed_named_e_graph[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// make subject key\n\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, m_prefixed_named_e_graph[2]);\n\n\t\t\t\t// predicate-object pairs state\n\t\t\t\treturn this.graph_post_name();\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_graph = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_graph) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_graph[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set graph\n\t\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t}\n\n\t\t\t\t\t// graph\n\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t// blank node label\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_blank_node_label_graph = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_blank_node_label_graph) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t// extract label\n\t\t\t\t\t\tlet s_label = m_blank_node_label_graph[1];\n\n\t\t\t\t\t\t// make graph key\n\t\t\t\t\t\tthis._kt_graph = this.blank_node(s_label);\n\n\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t// anonymous blank node graph\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t// set new blank node as graph\n\t\t\t\t\t\t\tthis._kt_graph = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_iriref_graph = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_iriref_graph) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\tlet s_iri = m_iriref_graph[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t// set graph\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\tlet [m_prefixed_named_graph, im_prefixed_named_graph] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\tif(m_prefixed_named_graph) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_graph;\n\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_graph[1] || '';\n\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_graph[2]\n\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t\t// match counter: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_keyword');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_keyword;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_post_name\n\tgraph_post_name() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_post_name');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_post_name;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for pairs\n\tpairs() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// benchmarks indicate: regex for end of blank node property list faster than ch\n\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_predicate = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_predicate) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_predicate[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set predicate\n\t\t\t\t\tthis._kt_predicate = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_predicate = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t\t// object-list state\n\t\t\t\treturn this.object_list();\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_predicate, im_prefixed_named_e_predicate] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_predicate) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = im_prefixed_named_e_predicate;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_predicate[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// make predicate key\n\t\t\t\t\tthis._kt_predicate = this.prefixed_name(s_prefix_id, m_prefixed_named_e_predicate[2]);\n\n\t\t\t\t\t// object-list state\n\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t// 'a'\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_A.lastIndex = i;\n\n\t\t\t\t\tif(R_A.exec(s)) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_A.lastIndex;\n\t\t\t\t\t\t// make predicate key\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_type;\n\n\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t\t// ']' end of blank node property list\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_CHAR_KET.lastIndex = i;\n\n\t\t\t\t\t\tif(R_CHAR_KET.exec(s)) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_CHAR_KET.lastIndex;\n\t\t\t\t\t\t\tlet s_resume_state;\n\t\t\t\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\t\t\t\treturn this[s_resume_state]();\n\n\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_iriref_predicate = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_iriref_predicate) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\tlet s_iri = m_iriref_predicate[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t// set predicate\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\tlet [m_prefixed_named_predicate, im_prefixed_named_predicate] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\tif(m_prefixed_named_predicate) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_predicate;\n\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_predicate[1] || '';\n\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_predicate[2]\n\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t// make predicate key\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\t\t\t\treturn this.object_list();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not 'a'\n\t\t\t// match counter: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('pairs');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.pairs;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for object_list\n\tobject_list() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// string literal * double\n\t\t\tif('\"' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif('\"' === s[i+1] && '\"' === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_double();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && '\"' !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// prefixed name quick\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_pnq_object = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_pnq_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_pnq_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_pnq_object[2]);\n\n\t\t\t\t// iriref\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_iriref_e_object) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// prefixed name\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// try match\n\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = im_prefixed_named_e_object;\n\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t\t\t// string literal * single\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('\\'' === x) {\n\t\t\t\t\t\t\t// enough chars to deduce type\n\t\t\t\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t\t\t\t// long type\n\t\t\t\t\t\t\t\tif(\"'\" === s[i+1] && \"'\" === s[i+2]) {\n\t\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\t\treturn this.string_literal_long_single();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// not long type\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// enough chars to eliminate long type\n\t\t\t\t\t\t\telse if((i+1) < n && \"'\" !== s[i+1]) {\n\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// numeric literal\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t// boolean literal\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);\n\n\n\t\t\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t// emit statement event\n\t\t\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t\t\t// push state to stack\n\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_object']);\n\n\t\t\t\t\t\t\t\t\t// set new subject\n\t\t\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\n\t\t\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_BLANK_NODE_LABEL_TERMINAL.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL_TERMINAL.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL_TERMINAL.lastIndex;\n\t\t\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\t\t// collection\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t// state to resume after collection ends\n\t\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_object']);\n\n\t\t\t\t\t\t\t\t\t\t// goto collection-object state\n\t\t\t\t\t\t\t\t\t\treturn this.collection_object();\n\n\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 9\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\t// fall through for cases that did not change state on their own\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('object_list');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.object_list;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_short_double\n\tstring_literal_short_double() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_short_double: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_SHORT_DOUBLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_SHORT_DOUBLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_SHORT_DOUBLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase '\"': {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 1;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_SHORT_DOUBLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_SHORT_DOUBLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_short_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_short_double;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\n'\n\t\t\t\t\tcase '\\n': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_double but invalid line feed character '\\\\n' (newline) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\r'\n\t\t\t\t\tcase '\\r': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_double but invalid form feed character '\\\\r' (carriage return) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_short_double`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// save\n\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t// set unparsed index\n\t\t\t\ti = n;\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_short_double');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_short_double;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_short_single\n\tstring_literal_short_single() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_short_single: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_SHORT_SINGLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_SHORT_SINGLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_SHORT_SINGLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase \"'\": {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 1;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_SHORT_SINGLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_SHORT_SINGLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_short_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_short_single;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\n'\n\t\t\t\t\tcase '\\n': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_single but invalid line feed character '\\\\n' (newline) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\r'\n\t\t\t\t\tcase '\\r': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_single but invalid form feed character '\\\\r' (carriage return) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_short_single`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// save\n\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t// set unparsed index\n\t\t\t\ti = n;\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_short_single');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_short_single;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_long_double\n\tstring_literal_long_double() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_long_double: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_LONG_DOUBLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_LONG_DOUBLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_LONG_DOUBLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase '\"': {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 3;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_LONG_DOUBLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_LONG_DOUBLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_long_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_long_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_long_double;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_long_double`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// could be unfinished terminator\n\t\t\t\tR_STRLIT_LONG_DOUBLE_UNFINISHED_TERM.lastIndex = i;\n\t\t\t\tlet m_unfinished = R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM.exec(s);\n\n\t\t\t\t// unfinished terminator\n\t\t\t\tif(m_unfinished) {\n\t\t\t\t\t// save valid portion\n\t\t\t\t\tthis._s_literal += s.slice(i, m_unfinished.index);\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = m_unfinished.index;\n\t\t\t\t}\n\t\t\t\t// not unfinished\n\t\t\t\telse {\n\t\t\t\t\t// save\n\t\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = n;\n\t\t\t\t}\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_long_double');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_long_double;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_long_single\n\tstring_literal_long_single() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_long_single: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_LONG_SINGLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_LONG_SINGLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_LONG_SINGLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase \"'\": {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 3;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_LONG_SINGLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_LONG_SINGLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_long_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_long_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_long_single;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_long_single`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// could be unfinished terminator\n\t\t\t\tR_STRLIT_LONG_SINGLE_UNFINISHED_TERM.lastIndex = i;\n\t\t\t\tlet m_unfinished = R_STRLIT_LONG_SINGLE_UNFINISHED_TERM.exec(s);\n\n\t\t\t\t// unfinished terminator\n\t\t\t\tif(m_unfinished) {\n\t\t\t\t\t// save valid portion\n\t\t\t\t\tthis._s_literal += s.slice(i, m_unfinished.index);\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = m_unfinished.index;\n\t\t\t\t}\n\t\t\t\t// not unfinished\n\t\t\t\telse {\n\t\t\t\t\t// save\n\t\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = n;\n\t\t\t\t}\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_long_single');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_long_single;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal\n\tstring_literal() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref character\n\t\t\tlet x = s[i];\n\n\t\t\t// string literal * double\n\t\t\tif('\"' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif('\"' === s[i+1] && '\"' === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_double();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && '\"' !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// string literal * single\n\t\t\t}\n\t\t\telse \tif('\\'' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif(\"'\" === s[i+1] && \"'\" === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_single();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && \"'\" !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// not string literal long single quote, not string literal single quote\n\t\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_string_length) {\n\t\t\t\t\treturn this.parse_error('string_literal');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for datatype_or_langtag\n\tdatatype_or_langtag() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref character\n\t\t\tlet x = s[i];\n\n\t\t\t// next token indicates datatype or langtag\n\t\t\tif('^' === x || '@' === x) {\n// '^^' datatype\n\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_DOUBLE_CARET.lastIndex = i;\n\n\t\t\t\tif(R_DOUBLE_CARET.exec(s)) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_DOUBLE_CARET.lastIndex;\n\t\t\t\t\treturn this.datatype();\n\n\t\t\t\t// '@' language tag\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_LANGTAG.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_langtag = R_LANGTAG.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_langtag) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_LANGTAG.lastIndex;\n\t\t\t\t\t\tthis._kt_object = this._dc_factory.languagedLiteral(this._s_literal, m_langtag[1]);\n\n\t\t\t\t\t\t// reset literal\n\t\t\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t// next token definitely datatype or langtag, we are just being interrupted by eos\n\t\t\t\t// match counter: 1\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #1\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this._dc_factory.simpleLiteral(this._s_literal);\n\n\t\t\t\t\t// reset literal\n\t\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t// not datatype, not language tag => that's okay! those are optional\n\t\t\t\t}\n\t\t\t} // brace #1\n\n\n\t\t\t// goto end of statement state\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('datatype_or_langtag');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.datatype_or_langtag;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for datatype\n\tdatatype() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet kt_datatype = null;\n\n// prefixed name quick\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_pnq_datatype = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_pnq_datatype) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_pnq_datatype[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, m_pnq_datatype[2]);\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_datatype = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_datatype) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\t\t\t\t\tlet p_datatype;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_datatype[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set p_datatype\n\t\t\t\t\t\tp_datatype = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tp_datatype = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\n\n\t\t\t\t\tkt_datatype = this.check_named_node_escapeless(p_datatype);\n\n\t\t\t\t// prefixed name\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// try match\n\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t// stack bail out\n\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\tlet [m_prefixed_named_e_datatype, im_prefixed_named_e_datatype] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\tif(m_prefixed_named_e_datatype) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = im_prefixed_named_e_datatype;\n\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_datatype[1] || '';\n\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, m_prefixed_named_e_datatype[2]);\n\n\t\t\t\t\t// iriref\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_iriref_datatype = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_iriref_datatype) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\t\t\t\t\t\t\tlet p_datatype;\n\n\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\tlet s_iri = m_iriref_e_datatype[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t// set p_datatype\n\t\t\t\t\t\t\t\tp_datatype = s_iri;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tp_datatype = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tkt_datatype = this.check_named_node(p_datatype);\n\n\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\tlet [m_prefixed_named_datatype, im_prefixed_named_datatype] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\tif(m_prefixed_named_datatype) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_datatype;\n\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_datatype[1] || '';\n\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_datatype[2]\n\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t// set literal datatype\n\t\t\t\t\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t// not iriref, not prefixed name\n\t\t\t// match counter: 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\tthis._kt_object = this._dc_factory.datatypedLiteral(this._s_literal, kt_datatype);\n\n\t\t\t// reset literal\n\t\t\tthis._s_literal = '';\n\n\t\t\t// goto end of statement state\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('datatype');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.datatype;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for post_object\n\tpost_object() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet i_reset = i;\n\n\t\t\t// benchmarks confirm: character ref faster than regexes in this context\n\t\t\tlet x = s[i];\n\n\t\t\t// advance index to next token beyond delimiter\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i+1;\n\t\t\tR_WS.exec(s);\n\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t// ',' more objects\n\t\t\tif(',' === x) {\n\t\t\t\treturn this.object_list();\n\n\t\t\t// ';' more predicate-object pairs\n\t\t\t}\n\t\t\telse \tif(';' === x) {\n\t\t\t\tfor(;;) {\n\t\t\t\t\t// next token is end of outer section\n\t\t\t\t\tlet s_peek = s[this.i];\n\t\t\t\t\tif('.' === s_peek || ']' === s_peek || ';' === s_peek || '}' === s_peek) {\n\t\t\t\t\t\t// goto post_object state\n\t\t\t\t\t\treturn this.post_object();\n\t\t\t\t\t}\n\t\t\t\t\t// comment\n\t\t\t\t\telse if('#' === s_peek) {\n\t\t\t\t\t\t// comment\n\t\t\t\t\t\ti = this.i;\n\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t// retry\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// no eol to close comment (yet)\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// already consumed\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// eos\n\t\t\t\t\telse if(this.i === n) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// something else\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn this.pairs();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// rather than pushing a dedicated state, just try again next chunk\n\t\t\t\ti = i_reset;\n\t\t\t\tbreak;\n\n\t\t\t// '.' end of statement\n\t\t\t}\n\t\t\telse \tif('.' === x) {\n\t\t\t\t// assert not nested\n\t\t\t\tif(this._a_nested.length) {\n\t\t\t\t\t// reset index to that character\n\t\t\t\t\tthis.i = i;\n\n\t\t\t\t\t// emit parse error\n\t\t\t\t\treturn this.parse_error('end_of_property_list');\n\t\t\t\t}\n\n\t\t\t\treturn (this._kt_default_graph === this._kt_graph)? this.block(): this.statement();\n\n\t\t\t// ']' end of property-object pairs\n\t\t\t}\n\t\t\telse \tif(']' === x) {\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\n\t\t\t// ')' end of collection\n\t\t\t}\n\t\t\telse \tif(')' === x) {\n\t\t\t\t// should not be here\n\t\t\t\treturn Reader$syntax_error(this, i, 'post_object', 'but encountered end of collection');\n\n\t\t\t// closing graph '}'\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t\t// emit graph_close event\n\t\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t\t// reset graph\n\t\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// comment\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t// comment interrupted by eos?\n\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('post_object');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.post_object;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for base_iri\n\tbase_iri() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefix id\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_base = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_base) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_base[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set base_url\n\t\t\t\t\tthis._s_base_url = s_iri;\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._s_base_url = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t}\t\tlet m_base_iri = R_BASE_IRI.exec(this._s_base_url);\n\t\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\n\n\t\t\t\t// emit base event\n\t\t\t\tthis.emit('base', this._s_base_url);\n\n\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t// change state\n\t\t\t\t\treturn this.full_stop();\n\t\t\t\t}\n\n\t\t\t\t// goto prefix iri state\n\t\t\t\treturn this.block();\n\n\t\t\t// prefix id\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_base = R_IRIREF.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_base) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_base[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set base_url\n\t\t\t\t\t\tthis._s_base_url = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._s_base_url = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\t\tlet m_base_iri = R_BASE_IRI.exec(this._s_base_url);\n\t\t\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\n\n\t\t\t\t\t// emit base event\n\t\t\t\t\tthis.emit('base', this._s_base_url);\n\n\t\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t\t// change state\n\t\t\t\t\t\treturn this.full_stop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// goto prefix iri state\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// for poorly-placed comments\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('base_iri');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.base_iri;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for prefix_id\n\tprefix_id() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefix id\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIX_ID.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_prefix_id = R_PREFIX_ID.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_prefix_id) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIX_ID.lastIndex;\n\t\t\t\t// set temp prefix id\n\t\t\t\tthis._s_temp_prefix_id = m_prefix_id[1];\n\n\t\t\t\t// goto prefix iri state\n\t\t\t\treturn this.prefix_iri();\n\n\t\t\t// for poorly-placed comments\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t// do not change state\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('prefix_id');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.prefix_id;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for prefix_iri\n\tprefix_iri() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet h_prefixes = this._h_prefixes;\n\t\t\tlet s_prefix_id = this._s_temp_prefix_id;\n\t\t\tlet p_prefix_iri;\n\n// prefix iri\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_prefix = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_prefix) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_prefix[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set p_prefix_iri\n\t\t\t\t\tp_prefix_iri = s_iri;\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tp_prefix_iri = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t}\n\n\t\t\t\tlet b_relax = this._b_relax;\n\n// existing mapping\n\n\t\t\t\tif(s_prefix_id in h_prefixes) {\n\t\t\t\t\t// doesn't match existing\n\t\t\t\t\tif(p_prefix_iri !== h_prefixes[s_prefix_id]) {\n\t\t\t\t\t\t// emit change event\n\t\t\t\t\t\tif(this.prefix_change) {\n\t\t\t\t\t\t\tthis.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// update prefix\n\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// first mapping\n\t\t\t\telse {\n\t\t\t\t\t// check namespace, invalid\n\t\t\t\t\tif(!b_relax && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {\n\t\t\t\t\t\treturn this.error(`Invalid namespace for prefixed name: \"${s_prefix_id}:\"`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// set prefix\n\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t}\n\n\t\t\t\t// check iri, invalid\n\t\t\t\tif(!b_relax && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {\n\t\t\t\t\treturn this.error(`Invalid IRI found in prefix delcaration: \"${s_iri}\"`);\n\t\t\t\t}\n\n\t\t\t\t// emit prefix event\n\t\t\t\tthis.event('prefix', s_prefix_id, p_prefix_iri);\n\n\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t// change state\n\t\t\t\t\treturn this.full_stop();\n\t\t\t\t}\n\n\t\t\t\t// goto statement state\n\t\t\t\treturn this.block();\n\n\t\t\t// prefix iri\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_prefix = R_IRIREF.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_prefix) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_prefix[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set p_prefix_iri\n\t\t\t\t\t\tp_prefix_iri = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tp_prefix_iri = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet b_relax = this._b_relax;\n\n// existing mapping\n\n\t\t\t\t\tif(s_prefix_id in h_prefixes) {\n\t\t\t\t\t\t// doesn't match existing\n\t\t\t\t\t\tif(p_prefix_iri !== h_prefixes[s_prefix_id]) {\n\t\t\t\t\t\t\t// emit change event\n\t\t\t\t\t\t\tif(this.prefix_change) {\n\t\t\t\t\t\t\t\tthis.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// update prefix\n\t\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first mapping\n\t\t\t\t\telse {\n\t\t\t\t\t\t// check namespace, invalid\n\t\t\t\t\t\tif(!b_relax && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {\n\t\t\t\t\t\t\treturn this.error(`Invalid namespace for prefixed name: \"${s_prefix_id}:\"`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// set prefix\n\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t}\n\n\t\t\t\t\t// check iri, invalid\n\t\t\t\t\tif(!b_relax && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {\n\t\t\t\t\t\treturn this.error(`Invalid IRI found in prefix delcaration: \"${s_iri}\"`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// emit prefix event\n\t\t\t\t\tthis.event('prefix', s_prefix_id, p_prefix_iri);\n\n\t\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t\t// change state\n\t\t\t\t\t\treturn this.full_stop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// goto statement state\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// for poorly-placed comments\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('prefix_iri');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.prefix_iri;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n// in case eos happens twice during prefix / base (extremely unlikely)\n\n\n\t// parse state for full_stop\n\tfull_stop() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prepare sticky regex index\n\t\t\tR_CHAR_STOP.lastIndex = i;\n\n\t\t\tif(R_CHAR_STOP.exec(s)) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_CHAR_STOP.lastIndex;\n\t\t\t\t// resume statement\n\t\t\t\treturn this.block();\n\n\t\t\t// poorly-placed comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t// try again\n\t\t\t\t\tcontinue;\n\n\t\t\t// possibly interrupted by eos\n\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('full_stop');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.full_stop;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for collection_subject\n\tcollection_subject() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// end of collection\n\t\t\tif(')' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// no items in collection subject\n\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t// prepare subject\n\t\t\t\t\tthis._kt_subject = this._kt_rdf_nil;\n\n\t\t\t\t\t// state was never pushed to stack, jump to post_subject state\n\t\t\t\t\treturn this.post_blank_subject();\n\t\t\t\t}\n// otherwise, there must be items in collection\n\n\t\t\t\t// commit collection end\n\t\t\t\tthis._kt_object = this._kt_rdf_nil;\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// restore state from stack\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\t\t\t}\n\n\n\n\t\t\t// otherwise, pre-emptively secure the next blank node label\n\t\t\tlet s_pointer_label;\n\n\t\t\t// very first collection object\n\t\t\tlet b_pushed = false;\n\t\t\tif(null === this._kt_subject) {\n\t\t\t\t// set quasi subject (really for resume state)\n\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\tthis._kt_subject = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'pairs']);\n\t\t\t\t// reset subject for later conditional branch\n\t\t\t\tthis._kt_subject = null;\n\t\t\t\tb_pushed = true;\n\t\t\t}\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_object) {\n\t\t\t\t// advance index\n\t\t\t\ti = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set object\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = im_prefixed_named_e_object;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t// string literal\n\t\t\t\t}\n\t\t\t\telse \tif('\"' === x || '\\'' === x) {\n\t\t\t\t\t// first item in list\n\t\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t}\n\t\t\t\t\t// not first item in list\n\t\t\t\t\telse {\n\t\t\t\t\t\t// make nest list item\n\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t// setup for object literal\n\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t}\n\n\t\t\t\t\t// how to resume collection subject state after object literal\n\t\t\t\t\tthis.after_end_of_statement = function() {\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\tthis.after_end_of_statement = this.post_object;\n\t\t\t\t\t\treturn this.collection_subject();\n\t\t\t\t\t};\n\t\t\t\t\treturn this.string_literal();\n\n\t\t\t\t// numeric literal\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t// boolean literal\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\ti = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);\n\n\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// this blank node is just the next item in the list\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node;\n\t\t\t\t\t\t\tif(null !== this._kt_subject) {\n\t\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\t\tthis.data();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// subject needs to be set\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node || this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\tlet s_label = this.next_label();\n\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(s_label);\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// when resume\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\n\t\t\t\t\t\t\t// push state\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_subject']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\n\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// new collection\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\ti = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// empty collection\n\t\t\t\t\t\t\tif(')' === s[i]) {\n\t\t\t\t\t\t\t\tthis.i = i;\n\t\t\t\t\t\t\t\tthis._kt_subject = this._a_nested[this._a_nested.length-1][0];\n\t\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\t\tthis._a_nested.push([\n\t\t\t\t\t\t\t\t\tthis._kt_subject,\n\t\t\t\t\t\t\t\t\tthis._kt_rdf_rest,\n\t\t\t\t\t\t\t\t\t'collection_subject',\n\t\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\t\treturn this.collection_object();\n\t\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t\t\t// commit list item pointer\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// add this list as an item to the outer list\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\n\n\t\t\t\t\t\t\t// flowing\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\ti = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\ti = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 7\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// ran out of characters after pushing state, pop it\n\t\t\t\t\t\t\t\t\t\t\tif(b_pushed) this._a_nested.pop();\n\n\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\tlet kt_blank_node_outer;\n\t\t\tif(!s_pointer_label) s_pointer_label = this.next_label();\n\n\t\t\t// not the very first item of collection subject\n\t\t\tif(this._kt_subject !== null) {\n\t\t\t\t// ref object\n\t\t\t\tlet w_object = this._kt_object;\n\n\t\t\t\t// create blanknode to embed list\n\t\t\t\tkt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\n\t\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// swap back object\n\t\t\t\tthis._kt_object = w_object;\n\t\t\t}\n\n\t\t\t// emit statement that is item\n\t\t\tthis._kt_subject = kt_blank_node_outer || this.anonymous_blank_node(s_pointer_label);\n\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\tthis.data();\n\n\n\t\t\t// prepare next predicate\n\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('collection_subject');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.collection_subject;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for collection_object\n\tcollection_object() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// end of collection\n\t\t\tif(')' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// make & emit collection's tail \"pointer\"\n\t\t\t\tthis._kt_object = this._kt_rdf_nil;\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// restore previous state\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\t\t\t}\n\n\n\n\t\t\t// otherwise, pre-emptively secure the next blank node label\n\t\t\tlet s_pointer_label;\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_object) {\n\t\t\t\t// advance index\n\t\t\t\ti = R_IRIREF_ESCAPELESS.lastIndex;\n// commit object iri as is\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set object\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = im_prefixed_named_e_object;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t// string literal\n\t\t\t\t}\n\t\t\t\telse \tif('\"' === x || '\\'' === x) {\n\t\t\t\t\t// update index before changing states\n\t\t\t\t\tthis.i = i;\n\n\t\t\t\t\t// create blanknode to embed list\n\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t// prepare statement that is item\n\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\tthis.after_end_of_statement = function() {\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\tthis.after_end_of_statement = this.post_object;\n\t\t\t\t\t\treturn this.collection_object();\n\t\t\t\t\t};\n\t\t\t\t\treturn this.string_literal();\n\n\t\t\t\t// numeric literal\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t// boolean literal\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\ti = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);\n\n\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// commit head of list pointer\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// setup state to resume and push\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// new collection\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\ti = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// commit list item pointer\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t\t\t\tlet a_recent = this._a_nested[this._a_nested.length-1];\n\t\t\t\t\t\t\t\tthis._kt_subject = a_recent[0];\n\t\t\t\t\t\t\t\tthis._kt_predicate = a_recent[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// add this list as an item to the outer list\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\t\t\t// flowing\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\ti = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t// make collection pointer label first\n\t\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\n\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\ti = R_IRIREF.lastIndex;\n// commit object iri as is\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 7\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\n\t\t\t// ref object\n\t\t\tlet w_object = this._kt_object;\n\n\t\t\t// create blanknode to embed list\n\t\t\tif(!s_pointer_label) s_pointer_label = this.next_label();\n\t\t\tlet kt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\n\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\tthis.data();\n\n\n\t\t\t// emit statement that is item\n\t\t\tthis._kt_subject = kt_blank_node_outer;\n\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\tthis._kt_object = w_object;\n\t\t\tthis.data();\n\n\n\t\t\t// prepare next predicate\n\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('collection_object');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.collection_object;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\tdestroy(e_destroy) {\n\t\tthis.post_blank_subject = () => {};\n\n\t\tthis.statement = () => {};\n\n\t\tthis.block = () => {};\n\n\t\tthis.graph_or_subject = () => {};\n\n\t\tthis.graph_or_subject_property_list = () => {};\n\n\t\tthis.graph_or_subject_anon = () => {};\n\n\t\tthis.graph_keyword = () => {};\n\n\t\tthis.graph_post_name = () => {};\n\n\t\tthis.pairs = () => {};\n\n\t\tthis.object_list = () => {};\n\n\t\tthis.string_literal_short_double = () => {};\n\n\t\tthis.string_literal_short_single = () => {};\n\n\t\tthis.string_literal_long_double = () => {};\n\n\t\tthis.string_literal_long_single = () => {};\n\n\t\tthis.string_literal = () => {};\n\n\t\tthis.datatype_or_langtag = () => {};\n\n\t\tthis.datatype = () => {};\n\n\t\tthis.post_object = () => {};\n\n\t\tthis.base_iri = () => {};\n\n\t\tthis.prefix_id = () => {};\n\n\t\tthis.prefix_iri = () => {};\n\n\t\tthis.full_stop = () => {};\n\n\t\tthis.collection_subject = () => {};\n\n\t\tthis.collection_object = () => {};\n\n\n\t\tthis.eof = () => {\n\t\t\tthis.s = null;\n\t\t};\n\n\t\tthis._b_destroyed = true;\n\n\t\t// propagate input destroy\n\t\tif(!e_destroy && this._ds_input) {\n\t\t\tthis._ds_input.destroy(e_destroy);\n\t\t}\n\n\t\tthis.transform.demolish(e_destroy);\n\t}\n}\n\nmodule.exports = function(...a_args) {\n\tlet g_config = {};\n\n\t// at least one argument\n\tif(a_args.length) {\n\t\tlet z_arg_0 = a_args[0];\n\n\t\t// input given unspecified\n\t\tif(z_arg_0 && z_arg_0.input && 'undefined' === typeof z_arg_0.input.string && !z_arg_0.input.stream) {\n\t\t\tz_arg_0 = z_arg_0.input;\n\t\t}\n\n\t\t// string\n\t\tif('string' === typeof z_arg_0) {\n\t\t\tg_config.input = {string:z_arg_0};\n\t\t}\n\t\t// null\n\t\telse if(null === z_arg_0) {\n\t\t\tg_config.input = null;\n\t\t}\n\t\t// node stream\n\t\telse if('function' === typeof z_arg_0.setEncoding) {\n\t\t\tg_config.input = {stream:z_arg_0};\n\t\t}\n\t\t// whatwg stream\n\t\telse if('function' === typeof z_arg_0.pipeTo) {\n\t\t\tthrow new TypeError(`Sorry, WHATWG streams are currently not supported :(`);\n\t\t// g_config.input = {stream:z_arg_0};\n\t\t}\n\t\t// config struct\n\t\telse if(z_arg_0 && 'object' === typeof z_arg_0 && '[object Object]' === Object.prototype.toString.call(z_arg_0)) {\n\t\t\tg_config = z_arg_0;\n\n\t\t\t// more args; invalid\n\t\t\tif(a_args.length > 1) {\n\t\t\t\tthrow new TypeError(`unexpected argument(s) after config struct: ${a_args.slice(1)}`);\n\t\t\t}\n\t\t}\n\t\t// unknown\n\t\telse {\n\t\t\tthrow new TypeError(`unexpected input type: ${z_arg_0}`);\n\t\t}\n\n\t\t// more args\n\t\tif(a_args.length > 1) {\n\t\t\t// copy onto struct\n\t\t\tObject.assign(g_config, a_args[1]);\n\n\t\t\t// more args\n\t\t\tif(a_args.length > 2) {\n\t\t\t\tthrow new TypeError(`unexpected argument(s) after input and config struct: ${a_args.slice(2)}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// create reader, return transform stream\n\treturn (new Reader(g_config)).transform;\n};\n","const stream = require('readable-stream');\n\n\n\nclass Readable extends stream.Readable {\n\tconstructor(gc_readable={}) {\n\t\tsuper(gc_readable);\n\n\t\t// use iterator\n\t\tif(gc_readable.iterator) {\n\t\t\tthrow new Error('readable stream iterator shortcut not yet implemented');\n\t\t}\n\t}\n\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\tbucket(s_encoding='utf8') {\n\t\tlet g_readable = this._readableState;\n\n\t\t// object mode\n\t\tif(g_readable.objectMode) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet a_data = [];\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\twrite(w_event, s_write_encoding, fk_write) {\n\t\t\t\t\t\ta_data.push(w_event);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ta_data.push(...a_chunks);\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(a_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// utf8-encoded strings\n\t\telse if('utf8' === s_encoding || 'utf-8' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet s_data = '';\n\n\t\t\t\t// set encoding\n\t\t\t\tthis.setEncoding(s_encoding);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: false,\n\n\t\t\t\t\twrite(s_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\ts_data += s_chunk;\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ts_data += a_chunks.join('');\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(s_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// buffer\n\t\telse if('buffer' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet ab_data = Buffer.from([]);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: true,\n\n\t\t\t\t\twrite(ab_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\tab_data = Buffer.concat([ab_data, ab_chunk], ab_data.length+ab_chunk.length);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(ab_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n}\n\nclass Writable extends stream.Writable {\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\t// rdfjs impl\n\timport(ds_source) {\n\t\tds_source\n\t\t\t.on('data', w_chunk => this.write(w_chunk))\n\t\t\t.on('end', () => this.end())\n\t\t\t.on('error', e_read => this.emit('error', e_read));\n\n\t\treturn this;\n\t}\n}\n\nclass Duplex extends stream.Duplex {\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\tbucket(s_encoding='utf8') {\n\t\tlet g_readable = this._readableState;\n\n\t\t// object mode\n\t\tif(g_readable.objectMode) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet a_data = [];\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\twrite(w_event, s_write_encoding, fk_write) {\n\t\t\t\t\t\ta_data.push(w_event);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ta_data.push(...a_chunks);\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(a_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// utf8-encoded strings\n\t\telse if('utf8' === s_encoding || 'utf-8' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet s_data = '';\n\n\t\t\t\t// set encoding\n\t\t\t\tthis.setEncoding(s_encoding);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: false,\n\n\t\t\t\t\twrite(s_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\ts_data += s_chunk;\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ts_data += a_chunks.join('');\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(s_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// buffer\n\t\telse if('buffer' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet ab_data = Buffer.from([]);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: true,\n\n\t\t\t\t\twrite(ab_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\tab_data = Buffer.concat([ab_data, ab_chunk], ab_data.length+ab_chunk.length);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(ab_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n}\n\nclass Transform extends stream.Transform {\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\tbucket(s_encoding='utf8') {\n\t\tlet g_readable = this._readableState;\n\n\t\t// object mode\n\t\tif(g_readable.objectMode) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet a_data = [];\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\twrite(w_event, s_write_encoding, fk_write) {\n\t\t\t\t\t\ta_data.push(w_event);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ta_data.push(...a_chunks);\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(a_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// utf8-encoded strings\n\t\telse if('utf8' === s_encoding || 'utf-8' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet s_data = '';\n\n\t\t\t\t// set encoding\n\t\t\t\tthis.setEncoding(s_encoding);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: false,\n\n\t\t\t\t\twrite(s_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\ts_data += s_chunk;\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ts_data += a_chunks.join('');\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(s_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// buffer\n\t\telse if('buffer' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet ab_data = Buffer.from([]);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: true,\n\n\t\t\t\t\twrite(ab_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\tab_data = Buffer.concat([ab_data, ab_chunk], ab_data.length+ab_chunk.length);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(ab_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\t// rdfjs impl\n\timport(ds_source) {\n\t\tds_source\n\t\t\t.on('data', w_chunk => this.write(w_chunk))\n\t\t\t.on('end', () => this.end())\n\t\t\t.on('error', e_read => this.emit('error', e_read));\n\n\t\treturn this;\n\t}\n\n\tdemolish(e_destroy) {\n\t\t// do not allow to push\n\t\tthis.push = (z_chunk) => {\n\t\t\t// ignore eof signals from node core\n\t\t\tif(null === z_chunk) return;\n\n\t\t\t// anything else is bad\n\t\t\tthrow new Error(`[ERR_STREAM_DESTROYED]: Cannot push after stream was destroyed`);\n\t\t};\n\n\t\t// do not allow to emit 'end'\n\t\tthis.emit = function(s_event, ...a_args) {\n\t\t\tif('end' === s_event) return;\n\n\t\t\tObject.getPrototypeOf(this).emit.apply(this, [s_event, ...a_args]);\n\t\t};\n\n\t\t// an error was given, destroy the stream as well\n\t\tif(e_destroy) {\n\t\t\treturn stream.Transform.prototype.destroy.call(this, e_destroy);\n\t\t}\n\t}\n}\n\n// eslint-disable-next-line no-new-func\nconst b_is_node = (new Function(/* syntax: js */ `try {return this===global;}catch(e){return false;}`))();\n\n// deduce the runtime environment\nconst [B_BROWSER, B_BROWSERIFY] = (() => 'undefined' === typeof process\n\t? [true, false]\n\t: (process.browser\n\t\t? [true, true]\n\t\t: ('undefined' === process.versions || 'undefined' === process.versions.node\n\t\t\t? [true, false]\n\t\t\t: [false, false])))();\n\n// node.js or browserify; patch for node < v10\nif(B_BROWSERIFY || (b_is_node && (+(/^v(\\d+)/.exec(process.version)[1])) < 10)) {\n\t// override destroy methods\n\tTransform.prototype.destroy = Duplex.prototype.destroy = function(e_destroy, fke_destroy) {\n\t\tthis._readableState.destroyed = true;\n\t\tthis._writableState.destroyed = true;\n\n\t\tlet f_emit_close = () => {\n\t\t\tif(!this._writableState.emitClose) return;\n\t\t\tif(!this._readableState.emitClose) return;\n\t\t\tthis.emit('close');\n\t\t};\n\n\t\tthis._destroy(e_destroy || null, (e_destroy_re) => {\n\t\t\tif(!fke_destroy && e_destroy_re) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tthis.emit('error', e_destroy_re);\n\t\t\t\t\tf_emit_close();\n\t\t\t\t});\n\t\t\t\tthis._writableState.errorEmitted = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprocess.nextTick(f_emit_close);\n\t\t\t\tif(fke_destroy) fke_destroy(e_destroy_re);\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t};\n\n\t// override default _destroy implementations\n\tTransform.prototype._destroy = Duplex.prototype._destroy = (e_destroy, fke_destroy) => fke_destroy(e_destroy);\n}\n\nclass QuadsToOther extends Transform {\n\tconstructor(gc_transform={}) {\n\t\tsuper({\n\t\t\t...gc_transform,\n\t\t\twritableObjectMode: true,\n\t\t\treadableObjectMode: true,\n\t\t});\n\n\t\tthis._as_inputs = new Set();\n\n\t\t// forward prefix and comment events\n\t\tthis.on('pipe', (ds_src) => {\n\t\t\tthis._as_inputs.add(ds_src);\n\n\t\t\tds_src\n\t\t\t\t.on('prefix', (...a_args) => {\n\t\t\t\t\tthis.emit('prefix', ...a_args);\n\t\t\t\t})\n\t\t\t\t.on('comment', (...a_args) => {\n\t\t\t\t\tthis.emit('comment', ...a_args);\n\t\t\t\t});\n\t\t});\n\n\t\tthis.on('unpipe', (ds_src) => {\n\t\t\tthis._as_inputs.delete(ds_src);\n\t\t});\n\t}\n\n\t_destroy() {\n\t\tfor(let ds_input of this._as_inputs) {\n\t\t\tds_input.destroy();\n\t\t}\n\t}\n}\n\nclass Quads_To_JSON_Transform extends QuadsToOther {\n\t// serializse json\n\t_transform(g_quad, s_encoding, fk_transform) {\n\t\tfk_transform(null, JSON.stringify(g_quad.isolate())+'\\n');\n\t}\n}\n\nclass Quads_To_Writable extends QuadsToOther {\n\t_transform(g_quad, s_encoding, fk_transform) {\n\t\tfk_transform(null, {\n\t\t\ttype: 'quad',\n\t\t\tvalue: g_quad,\n\t\t});\n\t}\n}\n\nTransform.QuadsToOther = QuadsToOther;\n\nmodule.exports = {\n\t...stream,\n\tReadable,\n\tWritable,\n\tDuplex,\n\tTransform,\n\n\tQuadsToOther,\n\n\t// create a transform from quad objects into JSON strings for trivial serialization\n\tquads_to_json() {\n\t\treturn new Quads_To_JSON_Transform();\n\t},\n\n\t// create a transform from quad objects into writable data events\n\tquads_to_writable() {\n\t\treturn new Quads_To_Writable();\n\t},\n\n\t// create a simple, single-event readable stream\n\tsource(w_push, s_encoding=null) {\n\t\t// encoding not explicit, string given; assume utf8\n\t\tif(!s_encoding && 'string' === typeof w_push) s_encoding = 'utf8';\n\n\t\t// readable\n\t\treturn new Readable({\n\t\t\tobjectMode: !s_encoding && 'string' !== typeof w_push && !Buffer.isBuffer(w_push),\n\n\t\t\tread() {\n\t\t\t\tthis.push(w_push, s_encoding);\n\t\t\t\tthis.push(null);\n\t\t\t},\n\t\t});\n\t},\n};\n"],"names":["queueMicrotask","dp_resolve","Promise","resolve","fk","then","catch","e_callback","setTimeout","e_define","uri","string_decoder","stream","factory","quad","k","_kt_subject","_kt_predicate","_kt_object","_kt_graph","RT_PREFIXED_NAME_NAMESPACE_VALID","RT_PREFIXED_NAME_LOCAL_NAME_VALID","RT_BLANK_NODE_VALID","RT_NAMED_NODE_VALID","RT_NAMED_NODE_ESCAPELESS_VALID","R_UNICODE_ANY","F_REPLACE_UNICODE_ANY","s_","s_4","s_8","String","fromCodePoint","parseInt","OPHOP","Object","prototype","hasOwnProperty","R_PREFIXED_NAME_QUICK","R_PREFIXED_NAME_ESCAPELESS","R_PREFIXED_NAME","R_PN_LOCAL_ESCAPES","R_BLANK_NODE_LABEL","R_BLANK_NODE_LABEL_TERMINAL","R_IRIREF_ESCAPELESS","R_IRIREF","R_NUMERIC_LITERAL","R_BOOLEAN_LITERAL","R_A","R_DOUBLE_CARET","R_WS","R_LANGTAG","R_PREFIX_KEYWORD","R_PREFIX_ID","R_BASE_KEYWORD","R_GRAPH_IRI_ESCAPELESS","R_GRAPH_PREFIXED_NAME","R_GRAPH_LABELED_BLANK_NODE","R_GRAPH_ANONYMOUS_BLANK_NODE","R_GRAPH_IRI","R_GRAPH","R_COMMENT","RT_IRI_ABSOLUTE","R_BASE_IRI","R_ANONYMOUS_BLANK_NODE","R_CHAR_BLANK_NODE","R_CHAR_COLLECTION","R_CHAR_KET","R_CHAR_OPEN","R_CHAR_CLOSE","R_CHAR_STOP","R_STRLIT_SHORT_DOUBLE_BREAK","R_STRLIT_SHORT_SINGLE_BREAK","R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM","R_STRLIT_LONG_SINGLE_UNFINISHED_TERM","R_STRLIT_LONG_DOUBLE_BREAK","R_STRLIT_LONG_SINGLE_BREAK","F_REPLACE_STRLIT_CONTENTS","s_whitespace","s_auto","s_invalid","console","assert","Error","JSON","stringify","R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD","R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT","unescape_literal_short_hard","s_literal","replace","unescape_literal_short_soft","m_incomplete","R_STRLIT_ESCAPE_INCOMPLETE","exec","i_safe","index","slice","R_STRLIT_LONG_CONTENTS_ESCAPES_HARD","R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT","unescape_literal_long_hard","unescape_literal_long_soft","R_STRLIT_SHORT_DOUBLE_TERM","R_STRLIT_SHORT_SINGLE_TERM","R_STRLIT_LONG_DOUBLE_TERM","R_STRLIT_LONG_SINGLE_TERM","RegExp_$lookbehind_polyfill","s_input","m_match","RegExp","call","this","i_start","length","mk_lookbehind_regex","e_compile","f_lookbehind","r_polyfill","f_polyfill","match_prefixed_name_escapeless","s","i","lastIndex","match_prefixed_name","Reader$syntax_error","k_self","si_state","s_info","i_off","Math","min","abs","error","substr","repeat","TriG_Reader","Transform","constructor","g_impls","super","decodeStrings","writableObjectMode","readableObjectMode","flush","transform","pipe","ds_out","ds_dst","_writableState","objectMode","isGraphyWritable","quads_to_writable","quads_to_json","Reader","g_config","input","g_input","state","g_state","blank_node_index","i_anon","prefixes","h_prefixes","labels","h_labels","dc_factory","adopt","dataFactory","data_factory","unfiltered","kt_default_graph","defaultGraph","create","kt_rdf_first","namedNode","blankNode","emit_data","ds_transform","push","g_quad","assign","n","pre","prepend","_b_debug","debug","_b_relax","relax","_dc_factory","_f_state","block","_h_prefixes","_b_destroyed","_s_base_url","_s_base_url_scheme","_s_base_url_root","_s_base_url_path","_s_literal","_kt_rdf_type","_kt_rdf_first","_kt_rdf_rest","_kt_rdf_nil","_kt_default_graph","_a_nested","_h_labels","event","emit","data","restore_data","_a_queue_event","_b_expecting_full_stop","_s_temp_prefix_id","_b_trim_start","anonymous_blank_node","s_label","next_label","eos","after_end_of_statement","post_object","_n_max_token_length","max_token_length","maxTokenLength","_n_max_string_length","max_string_length","maxStringLength","Infinity","_b_byte_tracking","byte_tracking","byteTracking","_nb_seen","_nb_last","_nb_curr","relaxed","warn","stack","blank_node","z_label_state","check_named_node","check_named_node_escapeless","test","p_iri","match_prefixed_name_quick","m_prefixed_name_e","im_prefixed_name_e","m_prefixed_name","im_prefixed_name","named_node","prefixed_name","si_prefix","s_suffix","base","TypeError","p_set_base_uri","base_uri","baseUri","baseURI","base_iri","baseIri","baseIRI","m_base_iri","base_url","baseUrl","baseURL","s_chunk","s_encoding","fke_chunk","safe_parse","fke_flush","eof","e_eof","destroy","on","ds_input","_ds_input","b_byte_tracking","setEncoding","f_write","write","d_decoder","StringDecoder","f_write_track","fk_write","nb_chunk","Buffer","from","f_decode_write_track","ab_chunk","f_decode_write","z_chunk","nb_post","ib_post","byteRange","s_event","emit_comments","s_captured","a_comments","split","s_comment","_destroy","a_args","bind","string","end","f_sync","apply","e_read","queue","args","s_message","parse_error","s_expected","b_eof","info_error","a_queue","h_event","shift","name","m_comment","prefix","enter","exit","comment","read","once","progress","finish","post_blank_subject","statement","equals","pairs","m_pnq_subject","s_prefix_id","m_iriref_e_subject","s_iri","aw_valid_this_match_prefixed_name_escapeless","m_prefixed_named_e_subject","im_prefixed_named_e_subject","m_blank_node_label_subject","collection_subject","m_iriref_subject","aw_valid_this_match_prefixed_name","m_prefixed_named_subject","im_prefixed_named_subject","m_graph_iriref_e_graph","m_graph_prefixed_name","m_graph_anonymous_blank_node","m_graph_labeled_blank_node","m_iriref_e_graph_subject","graph_or_subject","graph_or_subject_property_list","m_prefix_keyword","prefix_id","m_base_keyword","m_graph_iriref_graph","graph_keyword","x","graph_or_subject_anon","pop","m_prefixed_named_e_graph","im_prefixed_named_e_graph","graph_post_name","m_iriref_e_graph","m_blank_node_label_graph","m_iriref_graph","m_prefixed_named_graph","im_prefixed_named_graph","m_iriref_e_predicate","object_list","m_prefixed_named_e_predicate","im_prefixed_named_e_predicate","s_resume_state","m_iriref_predicate","m_prefixed_named_predicate","im_prefixed_named_predicate","string_literal_long_double","string_literal_short_double","m_pnq_object","m_iriref_e_object","m_prefixed_named_e_object","im_prefixed_named_e_object","string_literal_long_single","string_literal_short_single","m_numeric_literal","double","decimal","integer","m_boolean_literal","boolean","kt_blank_node","m_blank_node_label_object","collection_object","m_iriref_object","m_prefixed_named_object","im_prefixed_named_object","m_break","i_break","datatype_or_langtag","m_term","i_term","s_dirty","s_clean","s_incomplete","m_unfinished","string_literal","datatype","m_langtag","languagedLiteral","simpleLiteral","kt_datatype","m_pnq_datatype","m_iriref_e_datatype","p_datatype","m_prefixed_named_e_datatype","im_prefixed_named_e_datatype","m_iriref_datatype","m_prefixed_named_datatype","im_prefixed_named_datatype","datatypedLiteral","i_reset","s_peek","m_iriref_e_base","full_stop","m_iriref_base","m_prefix_id","prefix_iri","p_prefix_iri","m_iriref_e_prefix","b_relax","prefix_change","m_iriref_prefix","s_pointer_label","b_pushed","kt_blank_node_outer","w_object","a_recent","e_destroy","demolish","module","exports","z_arg_0","pipeTo","toString","Readable","gc_readable","iterator","until","b_return_stream","fk_until","fe_until","e_stream","bucket","g_readable","_readableState","fk_bucket","fe_bucket","a_data","Writable","w_event","s_write_encoding","writev","a_chunks","fk_writev","s_data","join","ab_data","concat","import","ds_source","w_chunk","Duplex","getPrototypeOf","b_is_node","Function","B_BROWSER","B_BROWSERIFY","process","browser","versions","node","version","fke_destroy","destroyed","f_emit_close","emitClose","e_destroy_re","nextTick","errorEmitted","QuadsToOther","gc_transform","_as_inputs","Set","ds_src","add","delete","Quads_To_JSON_Transform","_transform","fk_transform","isolate","Quads_To_Writable","type","value","source","w_push","isBuffer"],"sourceRoot":""}